% ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++% description of python utility functions; generated by Johannes Gerstmayr% ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\mysubsection{Module: basicUtilities}
\label{sec:module:basicUtilities}
 	Basic utility functions and constants, not depending on numpy or other python modules.
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Johannes Gerstmayr
\item[]Date:      2020-03-10 (created)
\item[]Notes:
\vspace{-22pt}\begin{itemize}[leftmargin=0.5cm]
\setlength{\itemindent}{-0.5cm}
\item[] 	Additional constants are defined: 
\item[]			pi = 3.1415926535897932 
\item[]			sqrt2 = 2**0.5
\item[]			g=9.81
\item[]			eye2D (2x2 diagonal matrix)
\item[]			eye3D (3x3 diagonal matrix)
\item[] 			Two variables 'gaussIntegrationPoints' and 'gaussIntegrationWeights' define integration points and weights for function GaussIntegrate(...)
\ei
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L31}{DiagonalMatrix}{}}}\label{sec:basicUtilities:DiagonalMatrix}
({\it rowsColumns}, {\it value}= 1)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: create a diagonal or identity matrix; used for interface.py, avoiding the need for numpy  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it rowsColumns}: provides the number of rows and columns
    \item[] {\it        value}: initialization value for diagonal terms
  \end{itemize}
  \item[--]  {\bf output}: list of lists representing a matrix\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L45}{NormL2}{}}}\label{sec:basicUtilities:NormL2}
({\it vector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute L2 norm for vectors without switching to numpy or math module  \item[--]  {\bf input}: vector as list or in numpy format  \item[--]  {\bf output}: L2-norm of vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L54}{VSum}{}}}\label{sec:basicUtilities:VSum}
({\it vector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute sum of all values of vector  \item[--]  {\bf input}: vector as list or in numpy format  \item[--]  {\bf output}: sum of all components of vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L63}{VAdd}{}}}\label{sec:basicUtilities:VAdd}
({\it v0}, {\it v1})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: add two vectors instead using numpy  \item[--]  {\bf input}: vectors v0 and v1 as list or in numpy format  \item[--]  {\bf output}: component-wise sum of v0 and v1\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L74}{VSub}{}}}\label{sec:basicUtilities:VSub}
({\it v0}, {\it v1})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: subtract two vectors instead using numpy: result = v0-v1  \item[--]  {\bf input}: vectors v0 and v1 as list or in numpy format  \item[--]  {\bf output}: component-wise difference of v0 and v1\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L85}{VMult}{}}}\label{sec:basicUtilities:VMult}
({\it v0}, {\it v1})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: scalar multiplication of two vectors instead using numpy: result = v0'*v1  \item[--]  {\bf input}: vectors v0 and v1 as list or in numpy format  \item[--]  {\bf output}: sum of all component wise products: c0[0]*v1[0] + v0[1]*v1[0] + ...\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L95}{ScalarMult}{}}}\label{sec:basicUtilities:ScalarMult}
({\it scalar}, {\it v})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: multiplication vectors with scalar: result = s*v  \item[--]  {\bf input}: value {\it scalar} and vector {\it v} as list or in numpy format  \item[--]  {\bf output}: scalar multiplication of all components of v: [scalar*v[0], scalar*v[1], ...]\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L104}{Normalize}{}}}\label{sec:basicUtilities:Normalize}
({\it v})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: take a 3D vector and return a normalized 3D vector (L2Norm=1)  \item[--]  {\bf input}: vector v as list or in numpy format  \item[--]  {\bf output}: vector v multiplied with scalar such that L2-norm of vector is 1\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L119}{Vec2Tilde}{}}}\label{sec:basicUtilities:Vec2Tilde}
({\it v})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: apply tilde operator (skew) to 3D-vector and return skew matrix  \item[--]  {\bf input}: 3D vector v as list or in numpy format  \item[--]  {\bf output}: matrix as list of lists containing the skew-symmetric matrix computed from v: $\mr{0}{-v[2]}{v[1]} {v[2]}{0}{-v[0]} {-v[1]}{v[0]}{0}$\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L126}{Tilde2Vec}{}}}\label{sec:basicUtilities:Tilde2Vec}
({\it m})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: take skew symmetric matrix and return vector (inverse of Skew(...))  \item[--]  {\bf input}: list of lists containing a skew-symmetric matrix (3x3)  \item[--]  {\bf output}: list containing the vector v (inverse function of Vec2Tilde(...))\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/basicUtilities.py\#L153}{GaussIntegrate}{}}}\label{sec:basicUtilities:GaussIntegrate}
({\it functionOfX}, {\it integrationOrder}, {\it a}, {\it b})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute numerical integration of functionOfX in interval [a,b] using Gaussian integration  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it functionOfX}: scalar, vector or matrix-valued function with scalar argument (X or other variable)
    \item[] {\it   integrationOrder}: odd number in \{1,3,5,7,9\}; currently maximum order is 9
    \item[] {\it   a}: integration range start
    \item[] {\it   b}: integration range end
  \end{itemize}
  \item[--]  {\bf output}: (scalar or vectorized) integral value\vspace{12pt}\end{itemize}
%
\mysubsection{Module: FEM}
\label{sec:module:FEM}
  Support functions and helper classes for import of meshes, finite element models (ABAQUS, ANSYS, NETGEN) and for generation of FFRF (floating frame of reference) objects.
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Johannes Gerstmayr, Stefan Holzinger
\item[]Date:      2020-03-10 (created)
\item[]Notes:  	CSR matrices contain 3 numbers per row: [row, column, value]
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L34}{CompressedRowSparseToDenseMatrix}{}}}\label{sec:FEM:CompressedRowSparseToDenseMatrix}
({\it sparseData})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert zero-based sparse matrix data to dense numpy matrix  \item[--]  {\bf input}: sparseData: format (per row): [row, column, value] ==> converted into dense format  \item[--]  {\bf output}: a dense matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L43}{MapSparseMatrixIndices}{}}}\label{sec:FEM:MapSparseMatrixIndices}
({\it matrix}, {\it sorting})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: resort a sparse matrix (internal CSR format) with given sorting for rows and columns; changes matrix directly! used for ANSYS matrix import\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L51}{VectorDiadicUnitMatrix3D}{}}}\label{sec:FEM:VectorDiadicUnitMatrix3D}
({\it v})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute diadic product of vector v and a 3D unit matrix = diadic(v,I$_{3x3}$); used for ObjectFFRF and CMS implementation\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L58}{CyclicCompareReversed}{}}}\label{sec:FEM:CyclicCompareReversed}
({\it list1}, {\it list2})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compare cyclic two lists, reverse second list; return True, if any cyclic shifted lists are same, False otherwise\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L67}{AddEntryToCompressedRowSparseArray}{}}}\label{sec:FEM:AddEntryToCompressedRowSparseArray}
({\it sparseData}, {\it row}, {\it column}, {\it value})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] add entry to compressedRowSparse matrix, avoiding duplicates
    \item[] value is either added to existing entry (avoid duplicates) or a new entry is appended
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L85}{CSRtoRowsAndColumns}{}}}\label{sec:FEM:CSRtoRowsAndColumns}
({\it sparseMatrixCSR})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rows and columns of a compressed sparse matrix and return as tuple: (rows,columns)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L91}{CSRtoScipySparseCSR}{}}}\label{sec:FEM:CSRtoScipySparseCSR}
({\it sparseMatrixCSR})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert internal compressed CSR to scipy.sparse csr matrix\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L99}{ScipySparseCSRtoCSR}{}}}\label{sec:FEM:ScipySparseCSRtoCSR}
({\it scipyCSR})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert scipy.sparse csr matrix to internal compressed CSR\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L107}{ResortIndicesOfCSRmatrix}{}}}\label{sec:FEM:ResortIndicesOfCSRmatrix}
({\it mXXYYZZ}, {\it numberOfRows})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] resort indices of given CSR matrix in XXXYYYZZZ format to XYZXYZXYZ format; numberOfRows must be equal to columns
    \item[] needed for import from NGsolve
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L239}{ConvertHexToTrigs}{}}}\label{sec:FEM:ConvertHexToTrigs}
({\it nodeNumbers})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] convert list of Hex8/C3D8  element with 8 nodes in nodeNumbers into triangle-List
    \item[] also works for Hex20 elements, but does only take the corner nodes!
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L251}{ConvertDenseToCompressedRowMatrix}{}}}\label{sec:FEM:ConvertDenseToCompressedRowMatrix}
({\it denseMatrix})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert numpy.array dense matrix to (internal) compressed row format\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L299}{ReadMatrixFromAnsysMMF}{}}}\label{sec:FEM:ReadMatrixFromAnsysMMF}
({\it fileName}, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] This function reads either the mass or stiffness matrix from an Ansys
    \item[]            Matrix Market Format (MMF). The corresponding matrix can either be exported
    \item[]            as dense matrix or sparse matrix.
  \end{itemize}
  \item[--]  {\bf input}: fileName of MMF file  \item[--]  {\bf output}: internal compressed row sparse matrix (as (nrows x 3) numpy array)  \item[--]  {\bf author}: Stefan Holzinger  \item[--]  {\bf notes}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] A MMF file can be created in Ansys by placing the following APDL code inside
    \item[] {\it    the solution tree in Ansys Workbench}:
    \item[]    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    \item[]    ! APDL code that exports sparse stiffnes and mass matrix in MMF format. If
    \item[]    ! the dense matrix is needed, replace *SMAT with *DMAT in the following
    \item[]    ! APDL code.
    \item[]    ! Export the stiffness matrix in MMF format
    \item[]    *SMAT,MatKD,D,IMPORT,FULL,file.full,STIFF
    \item[]    *EXPORT,MatKD,MMF,fileNameStiffnessMatrix,,,
    \item[]    ! Export the mass matrix in MMF format
    \item[]    *SMAT,MatMD,D,IMPORT,FULL,file.full,MASS
    \item[]    *EXPORT,MatMD,MMF,fileNameMassMatrix,,,
    \item[]    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    \item[]  In case a lumped mass matrix is needed, place the following APDL Code inside
    \item[] {\it  the Modal Analysis Tree}:
    \item[]    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    \item[]    ! APDL code to force Ansys to use a lumped mass formulation (if available for
    \item[]    ! used elements)
    \item[]    LUMPM, ON, , 0
    \item[]    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L340}{ReadMatrixDOFmappingVectorFromAnsysTxt}{}}}\label{sec:FEM:ReadMatrixDOFmappingVectorFromAnsysTxt}
({\it fileName})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] read sorting vector for ANSYS mass and stiffness matrices and return sorting vector as np.array
    \item[]   the file contains sorting for nodes and applies this sorting to the DOF (assuming 3 DOF per node!)
    \item[]   the resulting sorted vector is already converted to 0-based indices
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L395}{ReadNodalCoordinatesFromAnsysTxt}{}}}\label{sec:FEM:ReadNodalCoordinatesFromAnsysTxt}
({\it fileName}, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: This function reads the nodal coordinates exported from Ansys.  \item[--]  {\bf input}: fileName (file name ending must be .txt!)  \item[--]  {\bf output}: nodal coordinates as numpy array  \item[--]  {\bf author}: Stefan Holzinger  \item[--]  {\bf notes}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] The nodal coordinates can be exported from Ansys by creating a named selection
    \item[]    of the body whos mesh should to exported by choosing its geometry. Next,
    \item[]    create a second named selcetion by using a worksheet. Add the named selection
    \item[]    that was created first into the worksheet of the second named selection.
    \item[]    Inside the working sheet, choose 'convert' and convert the first created
    \item[]    named selection to 'mesh node' (Netzknoten in german) and click on generate
    \item[]    to create the second named selection. Next, right click on the second
    \item[]    named selection tha was created and choose 'export' and save the nodal
    \item[]    coordinates as .txt file.
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L474}{ReadElementsFromAnsysTxt}{}}}\label{sec:FEM:ReadElementsFromAnsysTxt}
({\it fileName}, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: This function reads the nodal coordinates exported from Ansys.  \item[--]  {\bf input}: fileName (file name ending must be .txt!)  \item[--]  {\bf output}: element connectivity as numpy array  \item[--]  {\bf author}: Stefan Holzinger  \item[--]  {\bf notes}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] The elements can be exported from Ansys by creating a named selection
    \item[]    of the body whos mesh should to exported by choosing its geometry. Next,
    \item[]    create a second named selcetion by using a worksheet. Add the named selection
    \item[]    that was created first into the worksheet of the second named selection.
    \item[]    Inside the worksheet, choose 'convert' and convert the first created
    \item[]    named selection to 'mesh element' (Netzelement in german) and click on generate
    \item[]    to create the second named selection. Next, right click on the second
    \item[]    named selection tha was created and choose 'export' and save the elements
    \item[]    as .txt file.
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\mysubsubsection{CLASS ObjectFFRFinterface (in module FEM)}
\noindent\textcolor{steelblue}{{\bf class description}}:  compute terms necessary for ObjectFFRF
class used internally in FEMinterface to compute ObjectFFRF object
this class holds all data for ObjectFFRF user functions
\vspace{3pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L560}{\_\_init\_\_}{}}}\label{sec:FEM:ObjectFFRFinterface:__init__}
({\it self}, {\it femInterface})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] initialize ObjectFFRFinterface with FEMinterface class
    \item[]   initializes the ObjectFFRFinterface with nodes, modes, surface description and systemmatrices from FEMinterface
    \item[]   data is then transfered to mbs object with classFunction AddObjectFFRF(...)
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L605}{AddObjectFFRF}{}}}\label{sec:FEM:ObjectFFRFinterface:AddObjectFFRF}
({\it self}, {\it exu}, {\it mbs}, {\it positionRef}= [0,0,0], {\it eulerParametersRef}= [1,0,0,0], {\it initialVelocity}= [0,0,0], {\it initialAngularVelocity}= [0,0,0], {\it gravity}= [0,0,0], {\it constrainRigidBodyMotion}= True, {\it massProportionalDamping}= 0, {\it stiffnessProportionalDamping}= 0, {\it color}= [0.1,0.9,0.1,1.])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: add according nodes, objects and constraints for FFRF object to MainSystem mbs  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it exu}: the exudyn module
    \item[] {\it   mbs}: a MainSystem object
    \item[] {\it   positionRef}: reference position of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
    \item[] {\it   eulerParametersRef}: reference euler parameters of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
    \item[] {\it   initialVelocity}: initial velocity of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
    \item[] {\it   initialAngularVelocity}: initial angular velocity of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
    \item[] {\it   gravity}: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
    \item[] {\it   constrainRigidBodyMotion}: set True in order to add constraint (Tisserand frame) in order to suppress rigid motion of mesh nodes
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] add object to mbs as well as according nodes
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L682}{UFforce}{}}}\label{sec:FEM:ObjectFFRFinterface:UFforce}
({\it self}, {\it exu}, {\it mbs}, {\it t}, {\it q}, {\it q\_t})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: optional forceUserFunction for ObjectFFRF (per default, this user function is ignored)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L728}{UFmassGenericODE2}{}}}\label{sec:FEM:ObjectFFRFinterface:UFmassGenericODE2}
({\it self}, {\it exu}, {\it mbs}, {\it t}, {\it q}, {\it q\_t})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: optional massMatrixUserFunction for ObjectFFRF (per default, this user function is ignored)\vspace{12pt}\end{itemize}
%
\mysubsubsection{CLASS ObjectFFRFreducedOrderInterface (in module FEM)}
\noindent\textcolor{steelblue}{{\bf class description}}:  compute terms necessary for ObjectFFRFreducedOrder
  class used internally in FEMinterface to compute ObjectFFRFreducedOrder dictionary
  this class holds all data for ObjectFFRFreducedOrder user functions
\vspace{3pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L774}{\_\_init\_\_}{}}}\label{sec:FEM:ObjectFFRFreducedOrderInterface:__init__}
({\it self}, {\it femInterface}, {\it roundMassMatrix}= 1e-13, {\it roundStiffNessMatrix}= 1e-13)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] initialize ObjectFFRFreducedOrderInterface with FEMinterface class
    \item[]   initializes the ObjectFFRFreducedOrderInterface with nodes, modes, surface description and reduced system matrices from FEMinterface
    \item[]   data is then transfered to mbs object with classFunction AddObjectFFRFreducedOrderWithUserFunctions(...)
  \end{itemize}
  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it femInterface}: must provide nodes, surfaceTriangles, modeBasis, massMatrix, stiffness
    \item[] {\it   roundMassMatrix}: use this value to set entries of reduced mass matrix to zero which are below the treshold
    \item[] {\it   roundStiffNessMatrix}: use this value to set entries of reduced stiffness matrix to zero which are below the treshold
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L848}{AddObjectFFRFreducedOrderWithUserFunctions}{}}}\label{sec:FEM:ObjectFFRFreducedOrderInterface:AddObjectFFRFreducedOrderWithUserFunctions}
({\it self}, {\it exu}, {\it mbs}, {\it positionRef}= [0,0,0], {\it eulerParametersRef}= [1,0,0,0], {\it initialVelocity}= [0,0,0], {\it initialAngularVelocity}= [0,0,0], {\it gravity}= [0,0,0], {\it UFforce}= 0, {\it UFmassMatrix}= 0, {\it massProportionalDamping}= 0, {\it stiffnessProportionalDamping}= 0, {\it color}= [0.1,0.9,0.1,1.])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: add according nodes, objects and constraints for ObjectFFRFreducedOrder object to MainSystem mbs  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it exu}: the exudyn module
    \item[] {\it   mbs}: a MainSystem object
    \item[] {\it   positionRef}: reference position of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
    \item[] {\it   eulerParametersRef}: reference euler parameters of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
    \item[] {\it   initialVelocity}: initial velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
    \item[] {\it   initialAngularVelocity}: initial angular velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
    \item[] {\it   gravity}: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
    \item[] {\it   UFforce}: provide a user function, which computes the quadratic velocity vector and applied forces; usually this function reads like:\\ \texttt{def UFforceFFRFreducedOrder(mbs, t, qReduced, qReduced\_t):\\ \phantom{XXXX}return cms.UFforceFFRFreducedOrder(exu, mbs, t, qReduced, qReduced\_t)}
    \item[] {\it   UFmassMatrix}: provide a user function, which computes the quadratic velocity vector and applied forces; usually this function reads like:\\ \texttt{def UFmassFFRFreducedOrder(mbs, t, qReduced, qReduced\_t):\\  \phantom{XXXX}return cms.UFmassFFRFreducedOrder(exu, mbs, t, qReduced, qReduced\_t)}
    \item[] {\it   massProportionalDamping}: Rayleigh damping factor for mass proportional damping, added to floating frame/modal coordinates only
    \item[] {\it   stiffnessProportionalDamping}: Rayleigh damping factor for stiffness proportional damping, added to floating frame/modal coordinates only
    \item[] {\it   color}: provided as list of 4 RGBA values
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L917}{UFmassFFRFreducedOrder}{}}}\label{sec:FEM:ObjectFFRFreducedOrderInterface:UFmassFFRFreducedOrder}
({\it self}, {\it exu}, {\it mbs}, {\it t}, {\it qReduced}, {\it qReduced\_t})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: CMS mass matrix user function; qReduced and qReduced\_t contain the coordiantes of the rigid body node and the modal coordinates in one vector!\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L952}{UFforceFFRFreducedOrder}{}}}\label{sec:FEM:ObjectFFRFreducedOrderInterface:UFforceFFRFreducedOrder}
({\it self}, {\it exu}, {\it mbs}, {\it t}, {\it qReduced}, {\it qReduced\_t})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: CMS force matrix user function; qReduced and qReduced\_t contain the coordiantes of the rigid body node and the modal coordinates in one vector!\vspace{12pt}\end{itemize}
%
\mysubsubsection{CLASS FEMinterface (in module FEM)}
\noindent\textcolor{steelblue}{{\bf class description}}:  general interface to different FEM / mesh imports and export to EXUDYN functions
         use this class to import meshes from different meshing or FEM programs (NETGEN/NGsolve, ABAQUS, ANSYS, ..) and store it in a unique format
         do mesh operations, compute eigenmodes and reduced basis, etc.
         load/store the data efficiently with LoadFromFile(...), SaveToFile(...)  if import functions are slow
         export to EXUDYN objects
\vspace{3pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1007}{\_\_init\_\_}{}}}\label{sec:FEM:FEMinterface:__init__}
({\it self})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: initalize all data of the FEMinterface by, e.g., \texttt{fem = FEMinterface()}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1028}{SaveToFile}{}}}\label{sec:FEM:FEMinterface:SaveToFile}
({\it self}, {\it fileName})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: save all data (nodes, elements, ...) to a data filename; this function is much faster than the text-based import functions  \item[--]  \textcolor{steelblue}{\bf input}: use filename without ending ==> ".npy" will be added\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1047}{LoadFromFile}{}}}\label{sec:FEM:FEMinterface:LoadFromFile}
({\it self}, {\it fileName})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] load all data (nodes, elements, ...) from a data filename previously stored with SaveToFile(...).
    \item[] this function is much faster than the text-based import functions
  \end{itemize}
  \item[--]  \textcolor{steelblue}{\bf input}: use filename without ending ==> ".npy" will be added\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1190}{ImportFromAbaqusInputFile}{}}}\label{sec:FEM:FEMinterface:ImportFromAbaqusInputFile}
({\it self}, {\it fileName}, {\it typeName}= 'Part', {\it name}= 'Part-1', {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] import nodes and elements from Abaqus input file and create surface elements
    \item[] node numbers in elements are converted from 1-based indices to python's 0-based indices
    \item[] only works for Hex8, Hex20, Tet4 and Tet10 (C3D4, C3D8, C3D10, C3D20) elements
    \item[] return node numbers as numpy array
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1340}{ReadMassMatrixFromAbaqus}{}}}\label{sec:FEM:FEMinterface:ReadMassMatrixFromAbaqus}
({\it self}, {\it fileName}, {\it type}= 'SparseRowColumnValue')
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it read mass matrix from compressed row text format (exported from Abaqus); in order to export system matrices, write the following lines in your Abaqus input file}:
    \item[] *STEP
    \item[] *MATRIX GENERATE, STIFFNESS, MASS
    \item[] *MATRIX OUTPUT, STIFFNESS, MASS, FORMAT=COORDINATE
    \item[] *End Step
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1346}{ReadStiffnessMatrixFromAbaqus}{}}}\label{sec:FEM:FEMinterface:ReadStiffnessMatrixFromAbaqus}
({\it self}, {\it fileName}, {\it type}= 'SparseRowColumnValue')
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read stiffness matrix from compressed row text format (exported from Abaqus)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1367}{ImportMeshFromNGsolve}{}}}\label{sec:FEM:FEMinterface:ImportMeshFromNGsolve}
({\it self}, {\it mesh}, {\it density}, {\it youngsModulus}, {\it poissonsRatio}, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: import mesh from NETGEN/NGsolve and setup mechanical problem  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mesh}: a previously created \texttt{ngs.mesh} (NGsolve mesh, see examples)
    \item[] {\it     youngsModulus}: Young's modulus used for mechanical model
    \item[] {\it     poissonsRatio}: Poisson's ratio used for mechanical model
    \item[] {\it     density}: density used for mechanical model
    \item[] {\it     verbose}: set True to print out some status information
  \end{itemize}
  \item[--]  \textcolor{steelblue}{\bf notes}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] The interface to NETGEN/NGsolve has been created together with Joachim Sch\"oberl, main developer
    \item[]   of NETGEN/NGsolve; Thank's a lot!
    \item[] {\it   download NGsolve at}: https://ngsolve.org/
    \item[]   NGsolve needs Python 3.7 (64bit) ==> use according EXUDYN version!
    \item[]   note that node/element indices in the NGsolve mesh are 1-based and need to be converted to 0-base!
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1477}{GetMassMatrix}{}}}\label{sec:FEM:FEMinterface:GetMassMatrix}
({\it self}, {\it sparse}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get sparse mass matrix in according format\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1484}{GetStiffnessMatrix}{}}}\label{sec:FEM:FEMinterface:GetStiffnessMatrix}
({\it self}, {\it sparse}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get sparse stiffness matrix in according format\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1491}{NumberOfNodes}{}}}\label{sec:FEM:FEMinterface:NumberOfNodes}
({\it self})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get total number of nodes\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1498}{GetNodePositionsAsArray}{}}}\label{sec:FEM:FEMinterface:GetNodePositionsAsArray}
({\it self})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get node points as array; only possible, if there exists only one type of Position nodes\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1506}{NumberOfCoordinates}{}}}\label{sec:FEM:FEMinterface:NumberOfCoordinates}
({\it self})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get number of total nodal coordinates\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1514}{GetNodeAtPoint}{}}}\label{sec:FEM:FEMinterface:GetNodeAtPoint}
({\it self}, {\it point}, {\it tolerance}= 1e-5, {\it raiseException}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] get node number for node at given point, e.g. p=[0.1,0.5,-0.2], using a tolerance (+/-) if coordinates are available only with reduced accuracy
    \item[] if not found, it returns an invalid index
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1528}{GetNodesInPlane}{}}}\label{sec:FEM:FEMinterface:GetNodesInPlane}
({\it self}, {\it point}, {\it normal}, {\it tolerance}= 1e-5)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] get node numbers in plane defined by point p and (normalized) normal vector n using a tolerance for the distance to the plane
    \item[] if not found, it returns an empty list
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1540}{GetNodesInCube}{}}}\label{sec:FEM:FEMinterface:GetNodesInCube}
({\it self}, {\it pMin}, {\it pMax})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] get node numbers in cube, given by pMin and pMax, containing the minimum and maximum x, y, and z coordinates
    \item[] if not found, it returns an empty list
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1554}{GetNodesOnCylinder}{}}}\label{sec:FEM:FEMinterface:GetNodesOnCylinder}
({\it self}, {\it p1}, {\it p2}, {\it radius}, {\it tolerance}= 1e-5)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] get node numbers on cylinder given by axes points p1 and p2, radius and tolerance
    \item[] if not found, it returns an empty list
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1579}{GetNodesOnCircle}{}}}\label{sec:FEM:FEMinterface:GetNodesOnCircle}
({\it self}, {\it point}, {\it normal}, {\it r}, {\it tolerance}= 1e-5)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] get node numbers on a circle, by point p, (normalized) normal vector n (which is the axis of the circle) and radius r
    \item[] using a tolerance for the distance to the plane
    \item[] if not found, it returns an empty list
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1591}{GetSurfaceTriangles}{}}}\label{sec:FEM:FEMinterface:GetSurfaceTriangles}
({\it self})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: return surface trigs as node number list (for drawing in EXUDYN)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1601}{VolumeToSurfaceElements}{}}}\label{sec:FEM:FEMinterface:VolumeToSurfaceElements}
({\it self}, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] generate surface elements from volume elements
    \item[] stores the surface in self.surface
    \item[] only works for one element list and one type ('Hex8') of elements
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1730}{GetGyroscopicMatrix}{}}}\label{sec:FEM:FEMinterface:GetGyroscopicMatrix}
({\it self}, {\it rotationAxis}= 2, {\it sparse}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get gyroscopic matrix in according format; rotationAxis=[0,1,2] = [x,y,z]\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1756}{ScaleMassMatrix}{}}}\label{sec:FEM:FEMinterface:ScaleMassMatrix}
({\it self}, {\it factor})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: scale (=multiply) mass matrix with factor\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1760}{ScaleStiffnessMatrix}{}}}\label{sec:FEM:FEMinterface:ScaleStiffnessMatrix}
({\it self}, {\it factor})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: scale (=multiply) stiffness matrix with factor\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1766}{AddElasticSupportAtNode}{}}}\label{sec:FEM:FEMinterface:AddElasticSupportAtNode}
({\it self}, {\it nodeNumber}, {\it springStiffness}= [1e8,1e8,1e8])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] modify stiffness matrix to add elastic support (joint, etc.) to a node; nodeNumber zero based (as everywhere in the code...)
    \item[] springStiffness must have length according to the node size
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1782}{AddNodeMass}{}}}\label{sec:FEM:FEMinterface:AddNodeMass}
({\it self}, {\it nodeNumber}, {\it addedMass})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: modify mass matrix by adding a mass to a certain node, modifying directly the mass matrix\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1800}{ComputeEigenmodes}{}}}\label{sec:FEM:FEMinterface:ComputeEigenmodes}
({\it self}, {\it nModes}, {\it excludeRigidBodyModes}= 0, {\it useSparseSolver}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute nModes smallest eigenvalues and eigenmodes from mass and stiffnessMatrix
    \item[] store mode vector in modeBasis, but exclude a number of 'excludeRigidBodyModes' rigid body modes from modeBasis
    \item[] if excludeRigidBodyModes > 0, then the computed modes is nModes + excludeRigidBodyModes, from which excludeRigidBodyModes smallest eigenvalues are excluded
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1838}{GetEigenFrequenciesHz}{}}}\label{sec:FEM:FEMinterface:GetEigenFrequenciesHz}
({\it self})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: return list of eigenvalues in Hz of previously computed eigenmodes\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1857}{ComputeCampbellDiagram}{}}}\label{sec:FEM:FEMinterface:ComputeCampbellDiagram}
({\it self}, {\it terminalFrequency}, {\it nEigenfrequencies}= 10, {\it frequencySteps}= 25, {\it rotationAxis}= 2, {\it plotDiagram}= False, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute Campbell diagram for given mechanical system
    \item[] create a first order system Axd + Bx = 0 with x= [q,qd]' and compute eigenvalues
    \item[] takes mass M, stiffness K and gyroscopic matrix G from FEMinterface
    \item[] currently only uses dense matrices, so it is limited to approx. 5000 unknowns!
  \end{itemize}
  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it terminalFrequency}: frequency in Hz, up to which the campbell diagram is computed
    \item[] {\it   nEigenfrequencies}: gives the number of computed eigenfrequencies(modes), in addition to the rigid body mode 0
    \item[] {\it   frequencySteps}: gives the number of increments (gives frequencySteps+1 total points in campbell diagram)
    \item[] {\it   rotationAxis}:[0,1,2] = [x,y,z] provides rotation axis
    \item[] {\it   plotDiagram}: if True, plots diagram for nEigenfrequencies befor terminating
    \item[] {\it   verbose}: if True, shows progress of computation
  \end{itemize}
  \item[--]  \textcolor{steelblue}{\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] [listFrequencies, campbellFrequencies]
    \item[] {\it   listFrequencies}: list of computed frequencies
    \item[] {\it   campbellFrequencies}: array of campbell frequencies per eigenfrequency of system
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1936}{CheckConsistency}{}}}\label{sec:FEM:FEMinterface:CheckConsistency}
({\it self})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: perform some consistency checks\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1960}{ReadMassMatrixFromAnsys}{}}}\label{sec:FEM:FEMinterface:ReadMassMatrixFromAnsys}
({\it self}, {\it fileName}, {\it dofMappingVectorFile}, {\it sparse}= True, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read mass matrix from CSV format (exported from Ansys)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1974}{ReadStiffnessMatrixFromAnsys}{}}}\label{sec:FEM:FEMinterface:ReadStiffnessMatrixFromAnsys}
({\it self}, {\it fileName}, {\it dofMappingVectorFile}, {\it sparse}= True, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read stiffness matrix from CSV format (exported from Ansys)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1988}{ReadNodalCoordinatesFromAnsys}{}}}\label{sec:FEM:FEMinterface:ReadNodalCoordinatesFromAnsys}
({\it self}, {\it fileName}, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read nodal coordinates (exported from Ansys as .txt-File)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/FEM.py\#L1993}{ReadElementsFromAnsys}{}}}\label{sec:FEM:FEMinterface:ReadElementsFromAnsys}
({\it self}, {\it fileName}, {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read elements (exported from Ansys as .txt-File)\vspace{12pt}\end{itemize}
%
\mysubsection{Module: graphicsDataUtilities}
\label{sec:module:graphicsDataUtilities}
 	Utility functions for visualization, which provides functions for basic shapes
			like cube, cylinder, sphere, solid of revolution. Functions generate dictionaries
			which contain line, text or triangle primitives for drawing in Exudyn using OpenGL.
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Johannes Gerstmayr
\item[]Date:      2020-07-26 (created)
\item[]Notes:
\vspace{-22pt}\begin{itemize}[leftmargin=0.5cm]
\setlength{\itemindent}{-0.5cm}
\item[] 	Some useful colors are defined, using RGBA (Red, Green, Blue and Alpha = opacity) channels			in the range [0,1], e.g., red = [1,0,0,1].
\item[]			Available colors are: color4red, color4green, color4blue, color4cyan, color4magenta, color4yellow, color4lightred, color4lightgreen, color4steelblue, color4grey, color4darkgrey, color4lightgrey, color4white
\item[]			Additionally, a list of colors 'color4list' is available, which is intended to be used, e.g., for creating n bodies with different colors
\ei
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L56}{GraphicsDataRectangle}{}}}\label{sec:graphicsDataUtilities:GraphicsDataRectangle}
({\it xMin}, {\it yMin}, {\it xMax}, {\it yMax}, {\it color}= [0.,0.,0.,1.])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for 2D rectangle  \item[--]  {\bf input}: minimal and maximal cartesian coordinates in (x/y) plane; color provided as list of 4 RGBA values  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L67}{GraphicsDataOrthoCubeLines}{}}}\label{sec:graphicsDataUtilities:GraphicsDataOrthoCubeLines}
({\it xMin}, {\it yMin}, {\it zMin}, {\it xMax}, {\it yMax}, {\it zMax}, {\it color}= [0.,0.,0.,1.])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for orthogonal cube drawn with lines  \item[--]  {\bf input}: minimal and maximal cartesian coordinates for orthogonal cube; color provided as list of 4 RGBA values  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L78}{GraphicsDataOrthoCube}{}}}\label{sec:graphicsDataUtilities:GraphicsDataOrthoCube}
({\it xMin}, {\it yMin}, {\it zMin}, {\it xMax}, {\it yMax}, {\it zMax}, {\it color}= [0.,0.,0.,1.])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for orthogonal 3D cube with min and max dimensions  \item[--]  {\bf input}: minimal and maximal cartesian coordinates for orthogonal cube; color provided as list of 4 RGBA values  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L87}{GraphicsDataOrthoCubePoint}{}}}\label{sec:graphicsDataUtilities:GraphicsDataOrthoCubePoint}
({\it centerPoint}, {\it size}, {\it color}= [0.,0.,0.,1.])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data forfor orthogonal 3D cube with center point and size  \item[--]  {\bf input}: center point and size of cube (as 3D list or np.array); color provided as list of 4 RGBA values  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L104}{GraphicsDataCube}{}}}\label{sec:graphicsDataUtilities:GraphicsDataCube}
({\it pList}, {\it color}= [0.,0.,0.,1.], {\it faces}= [1,1,1,1,1,1])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for general cube with endpoints, according to given vertex definition  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it pList}: is a list of points [[x0,y0,z0],[x1,y1,z1],...]
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   faces}: includes the list of six binary values (0/1), denoting active faces (value=1); set index to zero to hide face
  \end{itemize}
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L150}{SwitchTripletOrder}{}}}\label{sec:graphicsDataUtilities:SwitchTripletOrder}
({\it vector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: switch order of three items in a list; mostly used for reverting normals in triangles  \item[--]  {\bf input}: 3D vector as list or as np.array  \item[--]  {\bf output}: interchanged 2nd and 3rd component of list\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L164}{GraphicsDataSphere}{}}}\label{sec:graphicsDataUtilities:GraphicsDataSphere}
({\it point}, {\it radius}, {\it color}= [0.,0.,0.,1.], {\it nTiles}= 8)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for a sphere with point p and radius  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it point}: center of sphere (3D list or np.array)
    \item[] {\it   radius}: positive value
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   nTiles}: used to determine resolution of sphere >=3; use larger values for finer resolution
  \end{itemize}
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L225}{GraphicsDataCylinder}{}}}\label{sec:graphicsDataUtilities:GraphicsDataCylinder}
({\it pAxis}, {\it vAxis}, {\it radius}, {\it color}= [0.,0.,0.,1.], {\it nTiles}= 16, {\it angleRange}= [0,2*np.pi], {\it lastFace}= True, {\it cutPlain}= True, {\it **kwargs})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for a cylinder with given axis, radius and color; nFaces gives the number of tiles (minimum=3)  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it pAxis}: axis point of one face of cylinder (3D list or np.array)
    \item[] {\it   vAxis}: vector representing the cylinder's axis (3D list or np.array)
    \item[] {\it   radius}: positive value representing radius of cylinder
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   nTiles}: used to determine resolution of cylinder >=3; use larger values for finer resolution
    \item[] {\it   angleRange}: given in rad, to draw only part of cylinder (halfcylinder, etc.); for full range use [0..2 * pi]
    \item[] {\it   lastFace}: if angleRange != [0,2*pi], then the faces of the open cylinder are shown with lastFace = True
    \item[] {\it   cutPlain}: only used for angleRange != [0,2*pi]; if True, a plane is cut through the part of the cylinder; if False, the cylinder becomes a cake shape ...
    \item[] {\it   alternatingColor}: if given, optionally another color in order to see rotation of solid; only works, if angleRange=[0,2*pi]
  \end{itemize}
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L355}{GraphicsDataRigidLink}{}}}\label{sec:graphicsDataUtilities:GraphicsDataRigidLink}
({\it p0}, {\it p1}, {\it axis0}= [0,0,0], {\it axis1}= [0,0,0], {\it radius}= [0.1,0.1], {\it thickness}= 0.05, {\it width}= [0.05,0.05], {\it color}= [0.,0.,0.,1.], {\it nTiles}= 16)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for a planar Link between the two joint positions, having two axes  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it p0}: joint0 center position
    \item[] {\it   p1}: joint1 center position
    \item[] {\it   axis0}: direction of rotation axis at p0, if drawn as a cylinder; [0,0,0] otherwise
    \item[] {\it   axis1}: direction of rotation axis of p1, if drawn as a cylinder; [0,0,0] otherwise
    \item[] {\it   radius}: list of two radii [radius0, radius1], being the two radii of the joints drawn by a cylinder or sphere
    \item[] {\it   width}: list of two widths [width0, width1], being the two widths of the joints drawn by a cylinder; ignored for sphere
    \item[] {\it   thickness}: the thickness of the link (shaft) between the two joint positions; thickness in z-direction or diameter (cylinder)
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   nTiles}: used to determine resolution of cylinder >=3; use larger values for finer resolution
  \end{itemize}
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L408}{GraphicsDataFromSTLfileTxt}{}}}\label{sec:graphicsDataUtilities:GraphicsDataFromSTLfileTxt}
({\it fileName}, {\it color}= [0.,0.,0.,1.], {\it verbose}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data from STL file (text format!) and use color for visualization  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it fileName}: string containing directory and filename of STL-file (in text / SCII format) to load
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   verbose}: if True, useful information is provided during reading
  \end{itemize}
  \item[--]  {\bf output}: interchanged 2nd and 3rd component of list\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L515}{GraphicsDataSolidOfRevolution}{}}}\label{sec:graphicsDataUtilities:GraphicsDataSolidOfRevolution}
({\it pAxis}, {\it vAxis}, {\it contour}, {\it color}= [0.,0.,0.,1.], {\it nTiles}= 16, {\it smoothContour}= False, {\it **kwargs})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for a solid of revolution with given 3D point and axis, 2D point list for contour, (optional)2D normals and color;  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it pAxis}: axis point of one face of cylinder (3D list or np.array)
    \item[] {\it    vAxis}: vector representing the cylinder's axis (3D list or np.array)
    \item[] {\it    contour}: a list of 2D-points, specifying the contour (x=axis, y=radius), e.g.: [[0,0],[0,0.1],[1,0.1]]
    \item[] {\it    color}: provided as list of 4 RGBA values
    \item[] {\it    nTiles}: used to determine resolution of solid; use larger values for finer resolution
    \item[] {\it    smoothContour}: if True, the contour is made smooth by auto-computing normals to the contour
    \item[] {\it    alternatingColor}: add a second color, which enables to see the rotation of the solid
  \end{itemize}
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
#simple contour, using list of 2D points:
contour=[[0,0.2],[0.3,0.2],[0.5,0.3],[0.7,0.4],[1,0.4],[1,0.]]
rev1 = GraphicsDataSolidOfRevolution(pAxis=[0,0.5,0], vAxis=[1,0,0],
                                     contour=contour, color=color4red,
                                     alternatingColor=color4grey)
#draw torus:
contour=[]
r = 0.2 #small radius of torus
R = 0.5 #big radius of torus
for i in range(nc+3): #+3 in order to remove boundary effects
    contour+=[[r*cos(i/nc*pi*2),R+r*sin(i/nc*pi*2)]]
#use smoothContour to make torus looking smooth
rev2 = GraphicsDataSolidOfRevolution(pAxis=[0,0.5,0], vAxis=[1,0,0],
                                     contour=contour, color=color4red,
                                     nTiles = 32*2, smoothContour=True)\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/graphicsDataUtilities.py\#L623}{GraphicsDataQuad}{}}}\label{sec:graphicsDataUtilities:GraphicsDataQuad}
({\it pList}, {\it color}= [0.,0.,0.,1.], {\it **kwargs})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] generate graphics data for simple quad with option for checkerboard pattern;
    \item[] {\it   points are arranged counter-clock-wise, e.g.}: p0=[0,0,0], p1=[1,0,0], p2=[1,1,0], p3=[0,1,0]
  \end{itemize}
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it pList}: list of 4 quad points [[x0,y0,z0],[x1,y1,z1],...]
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   alternatingColor}: second color; if defined, a checkerboard pattern (default: 10x10) is drawn with color and alternatingColor
    \item[] {\it   nTiles}: number of tiles for checkerboard pattern (default: 10)
  \end{itemize}
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
plane = GraphicsDataQuad([[-8, 0, -8],[ 8, 0, -8,],[ 8, 0, 8],[-8, 0, 8]],
                         color4darkgrey, nTiles=8,
                         alternatingColor=color4lightgrey)
oGround=mbs.AddObject(ObjectGround(referencePosition=[0,0,0],
                      visualization=VObjectGround(graphicsData=[plane])))\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\mysubsection{Module: lieGroupBasics}
\label{sec:module:lieGroupBasics}
  Lie group methods and formulas for Lie group integration.
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Stefan Holzinger
\item[]Date:      2020-09-11
\item[]References:
\vspace{-22pt}\begin{itemize}[leftmargin=0.5cm]
\setlength{\itemindent}{-0.5cm}
\item[]   
\item[]				[Bruels2011]     Bruels, O., Cardona, A.: Two Lie Group Formulations for Dynamic Multibody Systems With Large Rotations, Proceedings of the ASME 2011 International Design Engineering Technical Conferences \& Computers and Information in Engineering Conference IDETC/CIE 2011, August 28-31, 2011, Washington, USA
\item[]               [Sonneville2014] Sonneville, V., Cardona A., Bruels, O.: Geometrically exact beam finite element formulated on the special Euclidean group SE(3)
\item[]               [Sonneville2017] Sonneville, Bruels, O., Bauchau, O.A.: Interpolation schemes for geometrically exact beams: A motion approach.  International Journal for Numerical Methods in Engineering 112, 1129-1153 (2017)
\item[]               [Terze2016]      Terze, Z., Mueller, A., Zlatar, D.: Singularity-free time integration of rotational quaternions using non-redundant ordinary differential equations. Multibody System Dynamics 38(3), 201-225 (2016)
\item[]               [Henderson1977]  Henderson, D.: Euler angles, quaternions, and transformation matrices for space shuttle analysis. Tech. rep., NASA (1977)
\item[]               [Holzinger2020]  Holzinger, S., Gerstmayr, J.: Explicit time integration of multibody systems modelled with three rotation parameters. In: Proceedings of the ASME 2020 International Design Engineering Technical Conferences and Computers and Information in Engineering Conference IDETC/CIE2020, August 17-19. Virtual, Online (2020)
\item[]               [Holzinger2021]  Holzinger, S., Gerstmayr, J.: Time integration of rigid bodies modelled with three rotation parameters, Multibody System Dynamics 2021
\item[]               [Simo1988]       Simo, J.C., Vu-Quoc, L.: On the dynamics in space of rods undergoing large motions-A geometrically exact approach. Computer methods in applied mechanics and engineering 66, 125-161 (1988)
\item[]               [Mueller2017]    Mueller, A.: Coordinate Mappings for Rigid Body Motions. Journal of Computational and Nonlinear Dynamics 12(2), 10 (2017)               
\ei
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L49}{Sinc}{}}}\label{sec:lieGroupBasics:Sinc}
({\it x})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the cardinal sine function in radians  \item[--]  {\bf input}: scalar float or int value  \item[--]  {\bf output}: float value in radians\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L61}{Cot}{}}}\label{sec:lieGroupBasics:Cot}
({\it x})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the cotangent function cot(x)=1/tan(x) in radians  \item[--]  {\bf input}: scalar float or int value  \item[--]  {\bf output}: float value in radians\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L69}{R3xSO3Matrix2RotationMatrix}{}}}\label{sec:lieGroupBasics:R3xSO3Matrix2RotationMatrix}
({\it G})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: computes 3x3 rotation matrix from 7x7 R3xSO(3) matrix, see \cite{Bruels2011}  \item[--]  {\bf input}: G: 7x7 matrix as np.array  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L77}{R3xSO3Matrix2Translation}{}}}\label{sec:lieGroupBasics:R3xSO3Matrix2Translation}
({\it G})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: computes translation part of R3xSO(3) matrix, see \cite{Bruels2011}  \item[--]  {\bf input}: G: 7x7 matrix as np.array  \item[--]  {\bf output}: 3D vector as np.array containg translational part of R3xSO(3)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L86}{R3xSO3Matrix}{}}}\label{sec:lieGroupBasics:R3xSO3Matrix}
({\it x}, {\it R})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: builds 7x7 matrix as element of the Lie group R3xSO(3), see \cite{Bruels2011}  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it x}: 3D vector as np.array representing the translation part corresponding to R3
    \item[] {\it    R}: 3x3 rotation matrix as np.array
  \end{itemize}
  \item[--]  {\bf output}: 7x7 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L108}{ExpSO3}{}}}\label{sec:lieGroupBasics:ExpSO3}
({\it Omega})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix exponential map on the Lie group SO(3), see \cite{Mueller2017}  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: 3x3 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L120}{ExpS3}{}}}\label{sec:lieGroupBasics:ExpS3}
({\it Omega})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the quaternion exponential map on the Lie group S(3), see \cite{Terze2016, Mueller2017}  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] 4D vector as np.array containing four Euler parameters
    \item[]           entry zero of output represent the scalar part of Euler parameters
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L130}{LogSO3}{}}}\label{sec:lieGroupBasics:LogSO3}
({\it R})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix logarithmic map on the Lie group SO(3), see \cite{Sonneville2014, Sonneville2017}  \item[--]  {\bf input}: 3x3 rotation matrix as np.array  \item[--]  {\bf output}: 3x3 skew symmetric matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L144}{TExpSO3}{}}}\label{sec:lieGroupBasics:TExpSO3}
({\it Omega})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the tangent operator corresponding to ExpSO3, see \cite{Bruels2011}  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: 3x3 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L164}{TExpSO3Inv}{}}}\label{sec:lieGroupBasics:TExpSO3Inv}
({\it Omega})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute the inverse of the tangent operator TExpSO3, see \cite{Sonneville2014}
    \item[]             this function was improved, see coordinateMaps.pdf by Stefan Holzinger
  \end{itemize}
  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: 3x3 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L186}{ExpSE3}{}}}\label{sec:lieGroupBasics:ExpSE3}
({\it x})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix exponential map on the Lie group SE(3), see \cite{Bruels2011}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 4x4 homogeneous transformation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L197}{LogSE3}{}}}\label{sec:lieGroupBasics:LogSE3}
({\it H})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix logarithm on the Lie group SE(3), see \cite{Sonneville2014}  \item[--]  {\bf input}: 4x4 homogeneous transformation matrix as np.array  \item[--]  {\bf output}: 4x4 skew symmetric matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L212}{TExpSE3}{}}}\label{sec:lieGroupBasics:TExpSE3}
({\it x})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the tangent operator corresponding to ExpSE3, see \cite{Bruels2011}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 6x6 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L238}{TExpSE3Inv}{}}}\label{sec:lieGroupBasics:TExpSE3Inv}
({\it x})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the inverse of tangent operator TExpSE3, see \cite{Sonneville2014}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 6x6 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L262}{ExpR3xSO3}{}}}\label{sec:lieGroupBasics:ExpR3xSO3}
({\it x})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix exponential map on the Lie group R3xSO(3), see \cite{Bruels2011}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 7x7 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L272}{TExpR3xSO3}{}}}\label{sec:lieGroupBasics:TExpR3xSO3}
({\it x})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the tangent operator corresponding to ExpR3xSO3, see \cite{Bruels2011}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 6x6 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L281}{TExpR3xSO3Inv}{}}}\label{sec:lieGroupBasics:TExpR3xSO3Inv}
({\it x})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the inverse of tangent operator TExpR3xSO3  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 6x6 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L304}{CompositionRuleDirectProductR3AndS3}{}}}\label{sec:lieGroupBasics:CompositionRuleDirectProductR3AndS3}
({\it q0}, {\it incrementalMotionVector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute composition operation for pairs in the Lie group R3xS3  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 7D vector as np.array containing position coordinates and Euler parameters
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \end{itemize}
  \item[--]  {\bf output}: 7D vector as np.array containing composed position coordinates and composed Euler parameters\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L326}{CompositionRuleSemiDirectProductR3AndS3}{}}}\label{sec:lieGroupBasics:CompositionRuleSemiDirectProductR3AndS3}
({\it q0}, {\it incrementalMotionVector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute composition operation for pairs in the Lie group R3 semiTimes S3 (corresponds to SE(3))  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 7D vector as np.array containing position coordinates and Euler parameters
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \end{itemize}
  \item[--]  {\bf output}: 7D vector as np.array containing composed position coordinates and composed Euler parameters\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L351}{CompositionRuleDirectProductR3AndR3RotVec}{}}}\label{sec:lieGroupBasics:CompositionRuleDirectProductR3AndR3RotVec}
({\it q0}, {\it incrementalMotionVector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for pairs in the group obtained from the direct product of R3 and R3, see \cite{HolzingerGerstmayr2020}
    \item[]             the rotation vector is used as rotation parametrizations
    \item[]             this composition operation can be used in formulations which represent the translational velocities in the global (inertial) frame
  \end{itemize}
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 6D vector as np.array containing position coordinates and rotation vector
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \end{itemize}
  \item[--]  {\bf output}: 7D vector as np.array containing composed position coordinates and composed rotation vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L375}{CompositionRuleSemiDirectProductR3AndR3RotVec}{}}}\label{sec:lieGroupBasics:CompositionRuleSemiDirectProductR3AndR3RotVec}
({\it q0}, {\it incrementalMotionVector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
    \item[]             the rotation vector is used as rotation parametrizations
    \item[]             this composition operation can be used in formulations which represent the translational velocities in the local (body-attached) frame
  \end{itemize}
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 6D vector as np.array containing position coordinates and rotation vector
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \end{itemize}
  \item[--]  {\bf output}: 6D vector as np.array containing composed position coordinates and composed rotation vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L400}{CompositionRuleDirectProductR3AndR3RotXYZAngles}{}}}\label{sec:lieGroupBasics:CompositionRuleDirectProductR3AndR3RotXYZAngles}
({\it q0}, {\it incrementalMotionVector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
    \item[]             Cardan-Tait/Bryan (CTB) angles are used as rotation parametrizations
    \item[]             this composition operation can be used in formulations which represent the translational velocities in the global (inertial) frame
  \end{itemize}
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 6D vector as np.array containing position coordinates and Cardan-Tait/Bryan angles
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \end{itemize}
  \item[--]  {\bf output}: 6D vector as np.array containing composed position coordinates and composed Cardan-Tait/Bryan angles\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L424}{CompositionRuleSemiDirectProductR3AndR3RotXYZAngles}{}}}\label{sec:lieGroupBasics:CompositionRuleSemiDirectProductR3AndR3RotXYZAngles}
({\it q0}, {\it incrementalMotionVector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
    \item[]             Cardan-Tait/Bryan (CTB) angles are used as rotation parametrizations
    \item[]             this composition operation can be used in formulations which represent the translational velocities in the local (body-attached) frame
  \end{itemize}
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 6D vector as np.array containing position coordinates and Cardan-Tait/Bryan angles
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \end{itemize}
  \item[--]  {\bf output}: 6D vector as np.array containing composed position coordinates and composed Cardan-Tait/Bryan angles\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L448}{CompositionRuleForEulerParameters}{}}}\label{sec:lieGroupBasics:CompositionRuleForEulerParameters}
({\it q}, {\it p})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for Euler parameters (unit quaternions)
    \item[]             this composition operation is quaternion multiplication, see \cite{Terze2016}
  \end{itemize}
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q}: 4D vector as np.array containing Euler parameters
    \item[] {\it   p}: 4D vector as np.array containing Euler parameters
  \end{itemize}
  \item[--]  {\bf output}: 4D vector as np.array containing composed (multiplied) Euler parameters\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L463}{CompositionRuleForRotationVectors}{}}}\label{sec:lieGroupBasics:CompositionRuleForRotationVectors}
({\it v0}, {\it Omega})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute composition operation for rotation vectors v0 and Omega, see \cite{Holzinger2021}  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it v0}: 3D rotation vector as np.array
    \item[] {\it   Omega}: 3D (incremental) rotation vector as np.array
  \end{itemize}
  \item[--]  {\bf output}: 3D vector as np.array containing composed rotation vector v\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/lieGroupBasics.py\#L485}{CompositionRuleRotXYZAnglesRotationVector}{}}}\label{sec:lieGroupBasics:CompositionRuleRotXYZAnglesRotationVector}
({\it alpha0}, {\it Omega})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute composition operation for RotXYZ angles, see \cite{Holzinger2021}  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it alpha0}: 3D vector as np.array containing RotXYZ angles
    \item[] {\it   Omega}:  3D vector as np.array containing the (incremental) rotation vector
  \end{itemize}
  \item[--]  {\bf output}: 3D vector as np.array containing composed RotXYZ angles\vspace{12pt}\end{itemize}
%
\mysubsection{Module: plot}
\label{sec:module:plot}
 	Plot utility functions based on matplotlib, including plotting of sensors and FFT.
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Johannes Gerstmayr
\item[]Date:      2020-09-16 (created)
\item[]Notes: 	For a list of plot colors useful for matplotlib, see also utilities.PlotLineCode(...)
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/plot.py\#L38}{PlotSensor}{}}}\label{sec:plot:PlotSensor}
({\it mbs}, {\it sensorNumbers}, {\it components}= 0, {\it **kwargs})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: helper for matplotlib in order to easily visualize sensor output  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mbs}: must be a valid MainSystem (mbs)
    \item[] {\it   sensorNumbers}: consists of one or a list of sensor numbers (type SensorIndex) as returned by the mbs function AddSensor(...)
    \item[] {\it   components}: consists of one or a list of components according to the component of the sensor to be plotted;
    \item[] {\it   *kwargs}: additional options, e.g.:
    \item[]         xLabel -> string for text at x-axis (otherwise time is used)
    \item[]         yLabel -> string for text at y-axis (otherwise outputvalues are used)
    \item[]         fontSize -> default = 16, which is a little bit larger than default (12)
  \end{itemize}
  \item[--]  {\bf output}: plots the sensor data  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
s0=mbs.AddSensor(SensorNode(nodeNumber=0))
  s1=mbs.AddSensor(SensorNode(nodeNumber=1))
  Plot(mbs, s0, 0)
  Plot(mbs, sensorNumbers=[s0,s1], components=[0,2], xlabel='time in seconds')\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/plot.py\#L154}{PlotFFT}{}}}\label{sec:plot:PlotFFT}
({\it frequency}, {\it data}, {\it xLabel}= 'frequency', {\it yLabel}= 'magnitude', {\it label}= '', {\it freqStart}= 0, {\it freqEnd}= -1, {\it logScaleX}= True, {\it logScaleY}= True, {\it majorGrid}= True, {\it minorGrid}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: plot fft spectrum of signal  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it frequency}:  frequency vector (Hz, if time is in SECONDS)
    \item[] {\it    data}:       magnitude or phase as returned by ComputeFFT() in exudyn.signal
    \item[] {\it    xLabel}:     label for x-axis, default=frequency
    \item[] {\it    yLabel}:     label for y-axis, default=magnitude
    \item[] {\it    label}:      either empty string ('') or name used in legend
    \item[] {\it    freqStart}:  starting range for frequency
    \item[] {\it    freqEnd}:    end of range for frequency; if freqEnd==-1 (default), the total range is plotted
    \item[] {\it    logScaleX}:  use log scale for x-axis
    \item[] {\it    logScaleY}:  use log scale for y-axis
    \item[] {\it    majorGrid}:  if True, plot major grid with solid line
    \item[] {\it    minorGrid}:  if True, plot minor grid with dotted line
  \end{itemize}
  \item[--]  {\bf output}: creates plot and returns plot (plt) handle\vspace{12pt}\end{itemize}
%
\mysubsection{Module: processing}
\label{sec:module:processing}
  The processing module supports multiple execution of EXUDYN models.
           It includes parameter variation and (genetic) optimization functionality.
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Johannes Gerstmayr 
\item[]Date:      2020-11-17
\item[]Notes:     Parallel processing, which requires multiprocessing library, can lead to considerable speedup (measured speedup factor > 50 on 80 core machine). The progess bar during multiprocessing requires the library tqdm.
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/processing.py\#L28}{ProcessParameterList}{}}}\label{sec:processing:ProcessParameterList}
({\it parameterFunction}, {\it parameterList}, {\it addComputationIndex}, {\it useMultiProcessing}, {\it **kwargs})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: processes parameterFunction for given parameters in parameterList, see ParameterVariation  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it parameterFunction}: function, which takes the form parameterFunction(parameterDict) and which returns any values that can be stored in a list (e.g., a floating point number)
    \item[] {\it     parameterList}: list of parameter sets (as dictionaries) which are fed into the parameter variation, e.g., [{'mass': 10}, {'mass':20}, ...]
    \item[] {\it     addComputationIndex}: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
    \item[] {\it     useMultiProcessing}: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
    \item[] {\it     numberOfThreads}: default: same as number of cpus (threads); used for multiprocessing lib;
  \end{itemize}
  \item[--]  {\bf output}: returns values containing the results according to parameterList  \item[--]  {\bf notes}: options are passed from Parametervariation\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/processing.py\#L93}{ParameterVariation}{}}}\label{sec:processing:ParameterVariation}
({\it parameterFunction}, {\it parameters}, {\it useLogSpace}= False, {\it debugMode}= False, {\it addComputationIndex}= False, {\it useMultiProcessing}= False, {\it showProgress}= True, {\it **kwargs})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] calls successively the function parameterFunction(parameterDict) with variation of parameters in given range; parameterDict is a dictionary, containing the current values of parameters,
    \item[] {\it   e.g., parameterDict=['mass'}:13, 'stiffness':12000] to be computed and returns a value or a list of values which is then stored for each parameter
  \end{itemize}
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it parameterFunction}: function, which takes the form parameterFunction(parameterDict) and which returns any values that can be stored in a list (e.g., a floating point number)
    \item[] {\it     parameters}: given as a dictionary, consist of name and triple of (begin, end and steps) same as in np.linspace(...), e.g. 'mass':(10,50,10) for a mass varied from 10 to 50, using 10 steps
    \item[] {\it     useLogSpace}: (optional) if True, the parameters are varied at a logarithmic scale, e.g., [1, 10, 100] instead linear [1, 50.5, 100]
    \item[] {\it     debugMode}: if True, additional print out is done
    \item[] {\it     addComputationIndex}: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
    \item[] {\it     useMultiProcessing}: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
    \item[] {\it     showProgress}: if True, shows for every iteration the progress bar (requires tqdm library)
    \item[] {\it     numberOfThreads}: default: same as number of cpus (threads); used for multiprocessing lib;
  \end{itemize}
  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it returns [parameterList, values], containing, e.g., parameterList={'mass'}:[1,1,1,2,2,2,3,3,3], 'stiffness':[4,5,6, 4,5,6, 4,5,6]} and the result values of the parameter variation accoring to the parameterList,
    \item[]            values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
  \end{itemize}
  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
ParameterVariation(parameters={'mass':(1,10,10), 'stiffness':(1000,10000,10)}, parameterFunction=Test, useMultiProcessing=True)\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/processing.py\#L227}{GeneticOptimization}{}}}\label{sec:processing:GeneticOptimization}
({\it objectiveFunction}, {\it parameters}, {\it populationSize}= 100, {\it numberOfGenerations}= 10, {\it elitistRatio}= 0.1, {\it crossoverProbability}= 0.25, {\it crossoverAmount}= 0.5, {\it rangeReductionFactor}= 0.7, {\it distanceFactor}= 0.1, {\it debugMode}= False, {\it addComputationIndex}= False, {\it useMultiProcessing}= False, {\it showProgress}= True, {\it **kwargs})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute minimum of given objectiveFunction  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it objectiveFunction}: function, which takes the form parameterFunction(parameterDict) and which returns a value or list (or numpy array) which reflects the size of the objective to be minimized
    \item[] {\it     parameters}: given as a dictionary, consist of name and tuple containing the search range for this parameter (begin, end), e.g. 'mass':(10,50)
    \item[] {\it     populationSize}: individuals in every generation
    \item[] {\it     initialPopulationSize}: number of random initial individuals; default: population size
    \item[] {\it     numberOfGenerations}: number of generations
    \item[] {\it     crossoverProbability}: if > 0: children are generated from two (randomly selected) parents by gene-crossover; if 0, no crossover is used
    \item[] {\it     crossoverAmount}: if crossoverProbability > 0, then this amount is the probability of genes to cross; 0.1: small amount of genes cross, 0.5: 50% of genes cross
    \item[] {\it     rangeReductionFactor}: reduction of mutation range (boundary) relative to range of last generation; helps algorithm to converge to more accurate values
    \item[] {\it     distanceFactor}: children only survive at a certain relative distance of the current range; must be small enough (< 0.5) to allow individuals to survive; ignored if distanceFactor=0; as a rule of thumb, the distanceFactor should be zero in case that there is only one significant minimum, but if there are many local minima, the distanceFactor should be used to search at several different local minima
    \item[] {\it     randomizerInitialization}: initialize randomizer at beginning of optimization in order to get reproducible results, provide any integer in the range between 0 and 2**32 - 1 (default: no initialization)
    \item[] {\it     debugMode}: if True, additional print out is done
    \item[] {\it     addComputationIndex}: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
    \item[] {\it     useMultiProcessing}: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
    \item[] {\it     showProgress}: if True, shows for every iteration the progress bar (requires tqdm library)
    \item[] {\it     numberOfThreads}: default: same as number of cpus (threads); used for multiprocessing lib;
    \item[] {\it     numberOfChildren}: (DEPRECATED, UNUSED) number childrens of surviving population
    \item[] {\it     survivingIndividuals}: (DEPRECATED) number of surviving individuals after children are born
  \end{itemize}
  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] returns [optimumParameter, optimumValue, parameterList, valueList], containing the optimum parameter set 'optimumParameter', optimum value 'optimumValue', the whole list of parameters parameterList with according objective values 'valueList'
    \item[]            values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
  \end{itemize}
  \item[--]  {\bf notes}: This function is still under development and shows an experimental state!  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
GeneticOptimization(objectiveFunction = fOpt, parameters={'mass':(1,10), 'stiffness':(1000,10000)})\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/processing.py\#L502}{PlotOptimizationResults2D}{}}}\label{sec:processing:PlotOptimizationResults2D}
({\it parameterList}, {\it valueList}, {\it xLogScale}= False, {\it yLogScale}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: visualize results of optimization for every parameter (2D plots)  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it parameterList}: taken from output parameterList of \texttt{GeneticOptimization}, containing a dictinary with lists of parameters
    \item[] {\it    valueList}: taken from output valueList of \texttt{GeneticOptimization}; containing a list of floats that result from the objective function
    \item[] {\it    xLogScale}: use log scale for x-axis
    \item[] {\it    yLogScale}: use log scale for y-axis
  \end{itemize}
  \item[--]  {\bf output}: return [figList, axList] containing the corresponding handles; creates a figure for every parameter in parameterList\vspace{12pt}\end{itemize}
%
\mysubsection{Module: rigidBodyUtilities}
\label{sec:module:rigidBodyUtilities}
 	Advanced utility/mathematical functions for reference frames, rigid body kinematics
			and dynamics. Useful Euler parameter and Tait-Bryan angle conversion functions
			are included. A class for rigid body inertia creating and transformation is available.
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Johannes Gerstmayr, Stefan Holzinger (rotation vector and Tait-Bryan angles)
\item[]Date:      2020-03-10 (created)
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L26}{ComputeOrthonormalBasis}{}}}\label{sec:rigidBodyUtilities:ComputeOrthonormalBasis}
({\it vector0})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute orthogonal basis vectors (normal1, normal2) for given vector0 (non-unique solution!); if vector0 == [0,0,0], then any normal basis is returned\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L50}{GramSchmidt}{}}}\label{sec:rigidBodyUtilities:GramSchmidt}
({\it vector0}, {\it vector1})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute Gram-Schmidt projection of given 3D vector 1 on vector 0 and return normalized triad (vector0, vector1, vector0 x vector1)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L70}{Skew}{}}}\label{sec:rigidBodyUtilities:Skew}
({\it vector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute skew symmetric 3x3-matrix from 3x1- or 1x3-vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L78}{Skew2Vec}{}}}\label{sec:rigidBodyUtilities:Skew2Vec}
({\it skew})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert skew symmetric matrix m to vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L98}{ComputeSkewMatrix}{}}}\label{sec:rigidBodyUtilities:ComputeSkewMatrix}
({\it v})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute (3 x 3*n) skew matrix from (3*n) vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L122}{EulerParameters2G}{}}}\label{sec:rigidBodyUtilities:EulerParameters2G}
({\it eulerParameters})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert Euler parameters (ep) to G-matrix (=$\partial \tomega  / \partial \pv_t$)  \item[--]  {\bf input}: vector of 4 eulerParameters as list or np.array  \item[--]  {\bf output}: 3x4 matrix G as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L131}{EulerParameters2GLocal}{}}}\label{sec:rigidBodyUtilities:EulerParameters2GLocal}
({\it eulerParameters})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert Euler parameters (ep) to local G-matrix (=$\partial \LU{b}{\tomega} / \partial \pv_t$)  \item[--]  {\bf input}: vector of 4 eulerParameters as list or np.array  \item[--]  {\bf output}: 3x4 matrix G as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L140}{EulerParameters2RotationMatrix}{}}}\label{sec:rigidBodyUtilities:EulerParameters2RotationMatrix}
({\it eulerParameters})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix from eulerParameters  \item[--]  {\bf input}: vector of 4 eulerParameters as list or np.array  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L150}{RotationMatrix2EulerParameters}{}}}\label{sec:rigidBodyUtilities:RotationMatrix2EulerParameters}
({\it rotationMatrix})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute Euler parameters from given rotation matrix  \item[--]  {\bf input}: 3x3 rotation matrix as list of lists or as np.array  \item[--]  {\bf output}: vector of 4 eulerParameters as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L190}{AngularVelocity2EulerParameters\_t}{}}}\label{sec:rigidBodyUtilities:AngularVelocity2EulerParameters_t}
({\it angularVelocity}, {\it eulerParameters})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute time derivative of Euler parameters from (global) angular velocity vector
    \item[] note that for Euler parameters $\pv$, we have $\tomega=\Gm \pv_t$ ==> $\Gm^T \tomega = \Gm^T\cdot \Gm\cdot \pv_t$ ==> $\Gm^T \Gm=4(\Im_{4x4} - \pv\cdot \pv^T)\pv_t = 4 (\Im_{4x4}) \pv_t$
  \end{itemize}
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it angularVelocity}: 3D vector of angular velocity in global frame, as lists or as np.array
    \item[] {\it   eulerParameters}: vector of 4 eulerParameters as np.array or list
  \end{itemize}
  \item[--]  {\bf output}: vector of time derivatives of 4 eulerParameters as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L202}{RotationVector2RotationMatrix}{}}}\label{sec:rigidBodyUtilities:RotationVector2RotationMatrix}
({\it rotationVector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: rotaton matrix from rotation vector, see appendix B in \cite{Simo1988}  \item[--]  {\bf input}: 3D rotation vector as list or np.array  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L219}{RotationMatrix2RotationVector}{}}}\label{sec:rigidBodyUtilities:RotationMatrix2RotationVector}
({\it rotationMatrix})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation vector from rotation matrix  \item[--]  {\bf input}: 3x3 rotation matrix as list of lists or as np.array  \item[--]  {\bf output}: vector of 3 components of rotation vector as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L234}{ComputeRotationAxisFromRotationVector}{}}}\label{sec:rigidBodyUtilities:ComputeRotationAxisFromRotationVector}
({\it rotationVector})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation axis from given rotation vector  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: 3D vector as np.array representing the rotation axis\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L259}{RotXYZ2RotationMatrix}{}}}\label{sec:rigidBodyUtilities:RotXYZ2RotationMatrix}
({\it rot})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix from consecutive xyz rotations (Tait-Bryan angles); A=Ax*Ay*Az; rot=[rotX, rotY, rotZ]  \item[--]  {\bf input}: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L274}{RotationMatrix2RotXYZ}{}}}\label{sec:rigidBodyUtilities:RotationMatrix2RotXYZ}
({\it rotationMatrix})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert rotation matrix to xyz Euler angles (Tait-Bryan angles);  A=Ax*Ay*Az;  \item[--]  {\bf input}: 3x3 rotation matrix as list of lists or np.array  \item[--]  {\bf output}: vector of Tait-Bryan rotation parameters [X,Y,Z] (in radiant) as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L289}{AngularVelocity2RotXYZ\_t}{}}}\label{sec:rigidBodyUtilities:AngularVelocity2RotXYZ_t}
({\it angularVelocity}, {\it rotation})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute time derivatives of angles RotXYZ from (global) angular velocity vector and given rotation  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it angularVelocity}: global angular velocity vector as list or np.array
    \item[] {\it   rotation}: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
  \end{itemize}
  \item[--]  {\bf output}: time derivative of vector of Tait-Bryan rotation parameters [X,Y,Z] (in radiant) as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L308}{RotXYZ2EulerParameters}{}}}\label{sec:rigidBodyUtilities:RotXYZ2EulerParameters}
({\it alpha})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute four Euler parameters from given RotXYZ angles, see \cite{Henderson1977}  \item[--]  {\bf input}: alpha: 3D vector as np.array containing RotXYZ angles  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] 4D vector as np.array containing four Euler parameters
    \item[]           entry zero of output represent the scalar part of Euler parameters
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L333}{RotationMatrixX}{}}}\label{sec:rigidBodyUtilities:RotationMatrixX}
({\it angleRad})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix w.r.t. X-axis (first axis)  \item[--]  {\bf input}: angle around X-axis in radiant  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L341}{RotationMatrixY}{}}}\label{sec:rigidBodyUtilities:RotationMatrixY}
({\it angleRad})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix w.r.t. Y-axis (second axis)  \item[--]  {\bf input}: angle around Y-axis in radiant  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L349}{RotationMatrixZ}{}}}\label{sec:rigidBodyUtilities:RotationMatrixZ}
({\it angleRad})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix w.r.t. Z-axis (third axis)  \item[--]  {\bf input}: angle around Z-axis in radiant  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L357}{HomogeneousTransformation}{}}}\label{sec:rigidBodyUtilities:HomogeneousTransformation}
({\it A}, {\it r})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute homogeneous transformation matrix from rotation matrix A and translation vector r\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L367}{HTtranslate}{}}}\label{sec:rigidBodyUtilities:HTtranslate}
({\it r})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: homogeneous transformation for translation with vector r\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L373}{HT0}{}}}\label{sec:rigidBodyUtilities:HT0}
({\it })
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: identity homogeneous transformation:\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L377}{HTrotateX}{}}}\label{sec:rigidBodyUtilities:HTrotateX}
({\it angle})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: homogeneous transformation for rotation around axis X (first axis)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L383}{HTrotateY}{}}}\label{sec:rigidBodyUtilities:HTrotateY}
({\it angle})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: homogeneous transformation for rotation around axis X (first axis)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L389}{HTrotateZ}{}}}\label{sec:rigidBodyUtilities:HTrotateZ}
({\it angle})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: homogeneous transformation for rotation around axis X (first axis)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L395}{HT2translation}{}}}\label{sec:rigidBodyUtilities:HT2translation}
({\it T})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: return translation part of homogeneous transformation\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L399}{HT2rotationMatrix}{}}}\label{sec:rigidBodyUtilities:HT2rotationMatrix}
({\it T})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: return rotation matrix of homogeneous transformation\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L404}{InverseHT}{}}}\label{sec:rigidBodyUtilities:InverseHT}
({\it T})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: return inverse homogeneous transformation such that inv(T)*T = np.eye(4)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L572}{AddRigidBody}{}}}\label{sec:rigidBodyUtilities:AddRigidBody}
({\it mainSys}, {\it inertia}, {\it nodeType}, {\it position}= [0,0,0], {\it velocity}= [0,0,0], {\it rotationMatrix}= [], {\it rotationParameters}= [], {\it angularVelocity}= [0,0,0], {\it gravity}= [0,0,0], {\it graphicsDataList}= [])
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: adds a node (with str(exu.NodeType. ...)) and body for a given rigid body; all quantities (esp. velocity and angular velocity) are given in global coordinates!  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it position}: reference position as list or numpy array with 3 components
    \item[] {\it    velocity}: initial translational velocity as list or numpy array with 3 components
    \item[] {\it    rotationMatrix}: 3x3 list or numpy matrix to define reference rotation; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[])
    \item[] {\it    rotationParameters}: reference rotation parameters; use EITHER rotationMatrix=[[...],[...],[...]] (while rotationParameters=[]) or rotationParameters=[...] (while rotationMatrix=[])
    \item[] {\it    angularVelocity}: initial angular velocity as list or numpy array with 3 components
    \item[] {\it    gravity}: if provided as list or numpy array with 3 components, it adds gravity force to the body at the COM, i.e., fAdd = m*gravity
    \item[] {\it    graphicsDataList}: list of graphicsData objects to define appearance of body
  \end{itemize}
  \item[--]  {\bf output}: returns list containing node number and body number: [nodeNumber, bodyNumber]\vspace{12pt}\end{itemize}
%
\mysubsubsection{CLASS RigidBodyInertia (in module rigidBodyUtilities)}
\noindent\textcolor{steelblue}{{\bf class description}}:  helper class for rigid body inertia (see also derived classes Inertia...).
Provides a structure to define mass, inertia and center of mass (com) of a rigid body.
The inertia tensor and center of mass must correspond when initializing the body!
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf notes}: It is recommended to start with com=[0,0,0] and then to use Translated(...) and Rotated(...) to get transformed inertia parameters.  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
i0 = RigidBodyInertia(10,np.diag([1,2,3]))
i1 = i0.Rotated(RotationMatrixX(np.pi/2))
i2 = i1.Translated([1,0,0])\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{24pt}\end{itemize}
%
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L434}{\_\_init\_\_}{}}}\label{sec:rigidBodyUtilities:RigidBodyInertia:__init__}
({\it self}, {\it mass}= 0, {\it inertiaTensor}= np.zeros([3,3]), {\it com}= np.zeros(3))
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: initialize RigidBodyInertia with scalar mass, 3x3 inertiaTensor and center of mass com\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L446}{\_\_add\_\_}{}}}\label{sec:rigidBodyUtilities:RigidBodyInertia:__add__}
({\it self}, {\it otherBodyInertia})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] add (+) operator allows adding another inertia information with SAME local coordinate system
    \item[] only inertias with same center of rotation can be added!
  \end{itemize}
  \item[--]  \textcolor{steelblue}{\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
J = InertiaSphere(2,0.1) + InertiaRodX(1,2)\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L453}{Translated}{}}}\label{sec:rigidBodyUtilities:RigidBodyInertia:Translated}
({\it self}, {\it vec})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: returns a RigidBodyInertia with center of mass com shifted by vec; $\ra$ transforms the returned inertiaTensor to the new center of rotation\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L467}{Rotated}{}}}\label{sec:rigidBodyUtilities:RigidBodyInertia:Rotated}
({\it self}, {\it rot})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: returns a RigidBodyInertia rotated by 3x3 rotation matrix rot, such that for a given J, the new inertia tensor reads Jnew = rot*J*rot.T  \item[--]  \textcolor{steelblue}{\bf notes}: only allowed if COM=0 !\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent \textcolor{steelblue}{def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/rigidBodyUtilities.py\#L480}{GetInertia6D}{}}}\label{sec:rigidBodyUtilities:RigidBodyInertia:GetInertia6D}
({\it self})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get vector with 6 inertia components (Jxx, Jyy, Jzz, Jyz, Jxz, Jxy) as needed in ObjectRigidBody\vspace{12pt}\end{itemize}
%
\mysubsubsection{CLASS InertiaCuboid(RigidBodyInertia) (in module rigidBodyUtilities)}
\noindent\textcolor{steelblue}{{\bf class description}}:  create RigidBodyInertia with moment of inertia and mass of a cuboid with density and side lengths sideLengths along local axes 1, 2, 3; inertia w.r.t. center of mass, com=[0,0,0]
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
InertiaCuboid(density=1000,sideLengths=[1,0.1,0.1])\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{24pt}\end{itemize}
%
\mysubsubsection{CLASS InertiaRodX(RigidBodyInertia) (in module rigidBodyUtilities)}
\noindent\textcolor{steelblue}{{\bf class description}}:  create RigidBodyInertia with moment of inertia and mass of a rod with mass m and length L in local 1-direction (x-direction); inertia w.r.t. center of mass, com=[0,0,0]
\vspace{3pt} \\ 
\mysubsubsection{CLASS InertiaMassPoint(RigidBodyInertia) (in module rigidBodyUtilities)}
\noindent\textcolor{steelblue}{{\bf class description}}:  create RigidBodyInertia with moment of inertia and mass of mass point with 'mass'; inertia w.r.t. center of mass, com=[0,0,0]
\vspace{3pt} \\ 
\mysubsubsection{CLASS InertiaSphere(RigidBodyInertia) (in module rigidBodyUtilities)}
\noindent\textcolor{steelblue}{{\bf class description}}:  create RigidBodyInertia with moment of inertia and mass of sphere with mass and radius; inertia w.r.t. center of mass, com=[0,0,0]
\vspace{3pt} \\ 
\mysubsubsection{CLASS InertiaHollowSphere(RigidBodyInertia) (in module rigidBodyUtilities)}
\noindent\textcolor{steelblue}{{\bf class description}}:  create RigidBodyInertia with moment of inertia and mass of hollow sphere with mass (concentrated at circumference) and radius; inertia w.r.t. center of mass, com=0
\vspace{3pt} \\ 
\mysubsubsection{CLASS InertiaCylinder(RigidBodyInertia) (in module rigidBodyUtilities)}
\noindent\textcolor{steelblue}{{\bf class description}}:  create RigidBodyInertia with moment of inertia and mass of cylinder with density, length and outerRadius; axis defines the orientation of the cylinder axis (0=x-axis, 1=y-axis, 2=z-axis); for hollow cylinder use innerRadius != 0; inertia w.r.t. center of mass, com=[0,0,0]
\vspace{3pt} \\ 
\mysubsection{Module: robotics}
\label{sec:module:robotics}
  A library which includes support functions for robotics. 
			The library is built on standard Denavit-Hartenberg Parameters and
			Homogeneous Transformations (HT) to describe transformations and coordinate systems
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Johannes Gerstmayr
\item[]Date:      2020-04-14
\item[]Example: 	see ComputeJointHT for the definition of the 'robot' dictionary.
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/robotics.py\#L69}{DH2HT}{}}}\label{sec:robotics:DH2HT}
({\it DHparameters})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute homogeneous transformation HT from standard DH-parameters\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/robotics.py\#L109}{ComputeJointHT}{}}}\label{sec:robotics:ComputeJointHT}
({\it robot}, {\it configuration})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute list of  homogeneous transformations HT from base to every joint for given configuration  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
link0={'stdDH':[0,0,0,np.pi/2],
         'mass':20,  #not needed!
         'inertia':np.diag([1e-8,0.35,1e-8]), #w.r.t. COM!
         'COM':[0,0,0]}
link1={'stdDH':[0,0,0.4318,0],
         'mass':17.4,
         'inertia':np.diag([0.13,0.524,0.539]), #w.r.t. COM!
         'COM':[-0.3638, 0.006, 0.2275]}
robot={'links':[link0, link1],
         'jointType':[1,1], #1=revolute, 0=prismatic
         'base':{'HT':HT0()},
         'tool':{'HT':HTtranslate([0,0,0.1])},
         'gravity':[0,0,9.81],
         'referenceConfiguration':[0]*2 #reference configuration for bodies; at which the robot is built
         }
HTlist = ComputeJointHT(robot, [np.pi/8]*2)\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/robotics.py\#L130}{ComputeCOMHT}{}}}\label{sec:robotics:ComputeCOMHT}
({\it robot}, {\it HT})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute list of  homogeneous transformations HT from base to every COM using HT list from ComputeJointHT\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/robotics.py\#L142}{ComputeStaticTorques}{}}}\label{sec:robotics:ComputeStaticTorques}
({\it robot}, {\it HT})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute list joint torques for serial robot under gravity (gravity and mass as given in robot)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/robotics.py\#L165}{Jacobian}{}}}\label{sec:robotics:Jacobian}
({\it robot}, {\it HT}, {\it toolPosition}= [], {\it mode}= 'all')
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute jacobian for translation and rotation at toolPosition using joint HT\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/robotics.py\#L295}{SerialRobot2MBS}{}}}\label{sec:robotics:SerialRobot2MBS}
({\it mbs}, {\it robot}, {\it jointLoadUserFunctionList}, {\it baseMarker}, {\it *args}, {\it **kwargs})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] add items to existing mbs from the robot structure, a baseMarker (can be ground object or body)
    \item[]             and the user function list for the joints; there are options that can be passed as args / kwargs, which can contains options as described below. For details, see the python file and \texttt{serialRobotTest.py} in TestModels
  \end{itemize}
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mbs}: the multibody system, which will be extended
    \item[] {\it    robot}: the robot model as dictionary, described in function ComputeJointHT
    \item[] {\it    jointLoadUserFunctionList}: a list of user functions for actuation of joints according to a LoadTorqueVector userFunction, see serialRobotTest.py as an example; can be empty list
    \item[] {\it    baseMarker}: a rigid body marker, at which the robot will be placed (usually ground); note that the local coordinate system of the base must be in accordance with the DH-parameters, i.e., the z-axis must be the first rotation axis. For correction of the base coordinate system, use rotationMarkerBase
    \item[] {\it    rotationMarkerBase}: used in Generic joint between first joint and base; note, that for moving base, the static compensation does not work (base rotation must be updated)
    \item[] {\it    showCOM}: a list of 3 floats [a,b,c], indicates to show center of mass as rectangular block with size [a,b,c]
    \item[] {\it    bodyAlpha}: a float value in range [0..1], adds transparency to links if value < 1
    \item[] {\it    toolGraphicsSize}: list of 3 floats [sx,sy,sz], giving the size of the tool for graphics representation; set sx=0 to disable tool drawing or do not provide this optional variable
    \item[] {\it    drawLinkSize}: draw parameters for links as list of 3 floats [r,w,0], r=radius of joint, w=radius of link, set r=0 to disable link drawing
    \item[] {\it    rotationMarkerBase}: add a numpy 3x3 matrix for rotation of the base, in order that the robot can be attached to any rotated base marker; the rotationMarkerBase is according to the definition in GenericJoint
  \end{itemize}
  \item[--]  {\bf output}: the function returns a dictionary containing information on nodes, bodies, joints, markers, torques, for every joint\vspace{12pt}\end{itemize}
%
\mysubsection{Module: roboticsSpecial}
\label{sec:module:roboticsSpecial}
  Library for additional support functions for robotics; 
			The library is built on standard Denavit-Hartenberg Parameters and
			Homogeneous Transformations (HT) to describe transformations and coordinate systems
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Martin Sereinig
\item[]Date:      2020-12-08
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/roboticsSpecial.py\#L29}{VelocityManipulability}{}}}\label{sec:roboticsSpecial:VelocityManipulability}
({\it robot}, {\it HT}, {\it mode})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute velocity manipulability measure for given pose (homogenious transformation)  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it robot}: robot structure
    \item[] {\it   HT}: actual pose as hoogenious transformaton matrix
    \item[] {\it   mode}: rotational or translational part of the movement
  \end{itemize}
  \item[--]  {\bf output}: velocity manipulability measure as scalar value, defined as $\sqrt(det(JJ^T))$  \item[--]  {\bf notes}: compute velocity dependent manipulability definded by Yoshikawa, see \cite{Yoshikawa1985}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/roboticsSpecial.py\#L57}{ForceManipulability}{}}}\label{sec:roboticsSpecial:ForceManipulability}
({\it robot}, {\it HT}, {\it mode})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute force manipulability measure for given pose (homogenious transformation)  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it robot}: robot structure
    \item[] {\it   HT}: actual pose as hoogenious transformaton matrix
    \item[] {\it   mode}: rotational or translational part of the movement
  \end{itemize}
  \item[--]  {\bf output}: force manipulability measure as scalar value, defined as $\sqrt((det(JJ^T))^{-1})$  \item[--]  {\bf notes}: compute force dependent manipulability definded by Yoshikawa, see \cite{Yoshikawa1985}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/roboticsSpecial.py\#L89}{StiffnessManipulability}{}}}\label{sec:roboticsSpecial:StiffnessManipulability}
({\it robot}, {\it JointStiffness}, {\it HT}, {\it mode})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute cartesian stiffness measure for given pose (homogenious transformation)  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it robot}: robot structure
    \item[] {\it   JointStiffness}: joint stiffness matrix
    \item[] {\it   HT}: actual pose as hoogenious transformaton matrix
    \item[] {\it   mode}: rotational or translational part of the movement
  \end{itemize}
  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] stiffness manipulability measure as scalar value, defined as minimum Eigenvalaue of the Cartesian stiffness matrix
    \item[]   Cartesian stiffness matrix
  \end{itemize}
  \item[--]  {\bf notes}:   \item[--]  {\bf status}: this function is {\bf currently under development} and under testing!\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/roboticsSpecial.py\#L118}{JointJacobian}{}}}\label{sec:roboticsSpecial:JointJacobian}
({\it robot}, {\it HT})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute joint jacobian for each frame for given pose (homogenious transformation)  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it robot}: robot structure
    \item[] {\it   HT}: actual pose as hoogenious transformaton matrix
  \end{itemize}
  \item[--]  {\bf output}: Link(body)-Jacobi matrix JJ: $\LU{i}{JJ_i}=[\LU{i}{J_{Ri}},\; \LU{i}{J_{Ti}}]$ for each link i, seperated in rotational ($J_R$) and translational ($J_T$) part of Jacobian matrix located in the $i^{th}$ coordiante system, see \cite{woernle2016}  \item[--]  {\bf notes}: runs over number of HTs given in HT (may be less than number of links), caclulations in link coordinate system located at the end of each link regarding Standard  Denavid-Hartenberg parameters, see \cite{Corke2013}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/roboticsSpecial.py\#L168}{MassMatrix}{}}}\label{sec:roboticsSpecial:MassMatrix}
({\it robot}, {\it HT}, {\it jointJacobian})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute mass matrix from jointJacobian  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it robot}: robot structure
    \item[] {\it   HT}: actual pose as hoogenious transformaton matrix
    \item[] {\it   jointJacobian}: provide list of jacobians as provided by function JointJacobian(...)
  \end{itemize}
  \item[--]  {\bf output}: MM: Mass matrix  \item[--]  {\bf notes}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it Mass Matrix calculation calculated in joint coordinates regarding (std) DH parameter}:
    \item[] **       Dynamic equations in minimal coordinates as described in Mehrkoerpersysteme by Woernle, \cite{woernle2016}, p206, eq6.90.
    \item[] **       Caclulations in link coordinate system at the end of each link
  \end{itemize}
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/roboticsSpecial.py\#L195}{DynamicManipulability}{}}}\label{sec:roboticsSpecial:DynamicManipulability}
({\it robot}, {\it HT}, {\it MassMatrix}, {\it Tmax}, {\it mode})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute dynamic manipulability measure for given pose (homogenious transformation)  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it robot}: robot structure
    \item[] {\it   HT}: actual pose as hoogenious transformaton matrix
    \item[] {\it   Tmax}: maximum joint torques
    \item[] {\it   mode}: rotational or translational part of the movement
    \item[] {\it   MassMatrix}: Mass (inertia) Maxtrix provided by the function MassMatrix
  \end{itemize}
  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] dynamic manipulability measure as scalar value, defined as minimum Eigenvalaue of the dynamic manipulability matrix N
    \item[]   dynamic manipulability matrix
  \end{itemize}
  \item[--]  {\bf notes}: acceleration dependent manipulability definded by Chiacchio, see \cite{Chiacchio1998}, eq.32. The eigenvectors and eigenvalues of N ([eigenvec eigenval]=eig(N))gives the direction and value of minimal and maximal accaleration )  \item[--]  {\bf status}: this function is {\bf currently under development} and under testing!\vspace{12pt}\end{itemize}
%
\mysubsection{Module: signal}
\label{sec:module:signal}
  The signal library supports processing of signals for import (e.g. measurement data)
           and for filtering result data.
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Date:      2020-12-10
\item[]Notes:     This module is still under construction and should be used with care!
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/signal.py\#L25}{FilterSensorOutput}{}}}\label{sec:signal:FilterSensorOutput}
({\it signal}, {\it filterWindow}= 5, {\it polyOrder}= 3, {\it derivative}= 0, {\it centralDifferentiate}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: filter output of sensors (using numpy savgol filter) as well as numerical differentiation to compute derivative of signal  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it signal}: numpy array (2D array with column-wise storage of signals, as exported by EXUDYN position, displacement, etc. sensors); first column = time, other columns = signals to operate on; note that it is assumed, that time devided in almost constant steps!
    \item[] {\it    derivative}: 0=no derivative, 1=first derivative, 2=second derivative, etc. (>2 only possible with filter)
    \item[] {\it    polyOrder}: order of polynomial for interpolation filtering
    \item[] {\it    filterWindow}: if zero: produces unfiltered derivative; if positive, must be ODD integer {1,3,5,...} and > polyOrder; filterWindow determines the length of the filter window (e.g., to get rid of noise)
    \item[] {\it    centralDifferentiate}: if True, it uses a central differentiation for first order, unfiltered derivatives; leads to less phase shift of signal!
  \end{itemize}
  \item[--]  {\bf output}: numpy array containing same columns, but with filtered signal and according derivatives\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/signal.py\#L81}{FilterSignal}{}}}\label{sec:signal:FilterSignal}
({\it signal}, {\it samplingRate}= -1, {\it filterWindow}= 5, {\it polyOrder}= 3, {\it derivative}= 0, {\it centralDifferentiate}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: filter 1D signal (using numpy savgol filter) as well as numerical differentiation to compute derivative of signal  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it signal}: 1D numpy array
    \item[] {\it    samplingRate}: (time increment) of signal values, needed for derivatives
    \item[] {\it    derivative}: 0=no derivative, 1=first derivative, 2=second derivative, etc. (>2 only possible with filter)
    \item[] {\it    polyOrder}: order of polynomial for interpolation filtering
    \item[] {\it    filterWindow}: if zero: produces unfiltered derivative; if positive, must be ODD integer {1,3,5,...} and > polyOrder; filterWindow determines the length of the filter window (e.g., to get rid of noise)
    \item[] {\it    centralDifferentiate}: if True, it uses a central differentiation for first order, unfiltered derivatives; leads to less phase shift of signal!
  \end{itemize}
  \item[--]  {\bf output}: numpy array containing same columns, but with filtered signal and according derivatives\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/signal.py\#L126}{ComputeFFT}{}}}\label{sec:signal:ComputeFFT}
({\it time}, {\it data})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: computes fast-fourier-transform (FFT) resulting in frequency, magnitude and phase of signal data using numpy.fft of numpy  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] time ... time vector in SECONDS in numpy format, having constant sampling rate (not checked!)
    \item[]    data ... data vector in numpy format
  \end{itemize}
  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] frequency ... frequency vector (Hz, if time is in SECONDS)
    \item[]    magnitude ... magnitude vector
    \item[]    phase     ... phase vector (in radiant)
  \end{itemize}
  \item[--]  {\bf author}: Stefan Holzinger  \item[--]  {\bf date}: 02.04.2020\vspace{12pt}\end{itemize}
%
\mysubsection{Module: solver}
\label{sec:module:solver}
  The solver module provides interfaces to static, dynamic and eigenvalue solvers.
           Most of the solvers are implemented inside the C++ core.
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Johannes Gerstmayr 
\item[]Date:      2020-12-02
\item[]Notes:     Solver functions are included directly in exudyn and can be used with exu.SolveStatic(...)
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/solver.py\#L46}{SolveStatic}{}}}\label{sec:solver:SolveStatic}
({\it mbs}, {\it simulationSettings}= exudyn.SimulationSettings(), {\it updateInitialValues}= False, {\it storeSolver}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: solves the static mbs problem using simulationSettings; check theDoc.pdf for MainSolverStatic for further details of the static solver  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mbs}: the MainSystem containing the assembled system; note that mbs may be changed upon several runs of this function
    \item[] {\it    simulationSettings}: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
    \item[] {\it    updateInitialValues}: if True, the results are written to initial values, such at a consecutive simulation uses the results of this simulation as the initial values of the next simulation
    \item[] {\it    storeSolver}: if True, the staticSolver object is stored in the mbs.sys dictionary as mbs.sys['staticSolver']
  \end{itemize}
  \item[--]  {\bf output}: returns True, if successful, False if fails; if storeSolver = True, mbs.sys contains staticSolver, which allows to investigate solver problems (check theDoc.pdf section \refSection{sec:solverSubstructures} and the items described in \refSection{sec:MainSolverStatic})  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
import exudyn as exu
 from exudyn.itemInterface import *
 SC = exu.SystemContainer()
 mbs = SC.AddSystem()
 #create simple system:
 ground = mbs.AddObject(ObjectGround())
 mbs.AddNode(NodePoint())
 body = mbs.AddObject(MassPoint(physicsMass=1, nodeNumber=0))
 m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=ground))
 m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=body))
 mbs.AddObject(CartesianSpringDamper(markerNumbers=[m0,m1], stiffness=[100,100,100]))
 mbs.AddLoad(LoadForceVector(markerNumber=m1, loadVector=[10,10,10]))
 mbs.Assemble()
 sims = exu.SimulationSettings()
 sims.timeIntegration.endTime = 10
 success = exu.SolveStatic(mbs, sims, storeSolver = True)
 print("success =", success)
 print("iterations = ", mbs.sys['staticSolver'].it)
 print("pos=", mbs.GetObjectOutputBody(body,localPosition=[0,0,0],
       variableType=exu.OutputVariableType.Position))\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/solver.py\#L91}{SolveDynamic}{}}}\label{sec:solver:SolveDynamic}
({\it mbs}, {\it simulationSettings}= exudyn.SimulationSettings(), {\it solverType}= exudyn.DynamicSolverType.GeneralizedAlpha, {\it updateInitialValues}= False, {\it storeSolver}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: solves the dynamic mbs problem using simulationSettings and solver type; check theDoc.pdf for MainSolverImplicitSecondOrder for further details of the dynamic solver  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mbs}: the MainSystem containing the assembled system; note that mbs may be changed upon several runs of this function
    \item[] {\it    simulationSettings}: specific simulation settings
    \item[] {\it    solverType}: use exudyn.DynamicSolverType to set specific solver (default=generalized alpha)
    \item[] {\it    updateInitialValues}: if True, the results are written to initial values, such at a consecutive simulation uses the results of this simulation as the initial values of the next simulation
    \item[] {\it    storeSolver}: if True, the staticSolver object is stored in the mbs.sys dictionary as mbs.sys['staticSolver']
  \end{itemize}
  \item[--]  {\bf output}: returns True, if successful, False if fails; if storeSolver = True, mbs.sys contains staticSolver, which allows to investigate solver problems (check theDoc.pdf section \refSection{sec:solverSubstructures} and the items described in \refSection{sec:MainSolverStatic})  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
import exudyn as exu
 from exudyn.itemInterface import *
 SC = exu.SystemContainer()
 mbs = SC.AddSystem()
 #create simple system:
 ground = mbs.AddObject(ObjectGround())
 mbs.AddNode(NodePoint())
 body = mbs.AddObject(MassPoint(physicsMass=1, nodeNumber=0))
 m0 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=ground))
 m1 = mbs.AddMarker(MarkerBodyPosition(bodyNumber=body))
 mbs.AddObject(CartesianSpringDamper(markerNumbers=[m0,m1], stiffness=[100,100,100]))
 mbs.AddLoad(LoadForceVector(markerNumber=m1, loadVector=[10,10,10]))
 mbs.Assemble()
 sims = exu.SimulationSettings()
 sims.timeIntegration.endTime = 10
 success = exu.SolveDynamic(mbs, sims, storeSolver = True)
 print("success =", success)
 print("iterations = ", mbs.sys['dynamicSolver'].it)
 print("pos=", mbs.GetObjectOutputBody(body,localPosition=[0,0,0],
       variableType=exu.OutputVariableType.Position))\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/solver.py\#L141}{ComputeODE2Eigenvalues}{}}}\label{sec:solver:ComputeODE2Eigenvalues}
({\it mbs}, {\it simulationSettings}= exudyn.SimulationSettings(), {\it useSparseSolver}= False, {\it numberOfEigenvalues}= 0, {\it setInitialValues}= True, {\it convert2Frequencies}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute eigenvalues for unconstrained ODE2 part of mbs, not considering the effects of algebraic constraints; the computation is done for the initial values of the mbs, independently of previous computations. If you would like to use the current state for the eigenvalue computation, you need to copy the current state to the initial state (using GetSystemState,SetSystemState, see \refSection{sec:mbs:systemData}).  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mbs}: the MainSystem containing the assembled system
    \item[] {\it    simulationSettings}: specific simulation settings used for computation of jacobian (e.g., sparse mode in static solver enables sparse computation)
    \item[] {\it    useSparseSolver}: if False (only for small systems), all eigenvalues are computed in dense mode (slow for large systems!); if True, only the numberOfEigenvalues are computed (numberOfEigenvalues must be set!); Currently, the matrices are exported only in DENSE MODE from mbs! NOTE that the sparsesolver accuracy is much less than the dense solver
    \item[] {\it    numberOfEigenvalues}: number of eigenvalues and eivenvectors to be computed; if numberOfEigenvalues==0, all eigenvalues will be computed (may be impossible for larger problems!)
    \item[] {\it    convert2Frequencies}: if True, the eigen values are converted into frequencies (Hz) and the output is [eigenFrequencies, eigenVectors]
  \end{itemize}
  \item[--]  {\bf output}: [eigenValues, eigenVectors]; eigenValues being a numpy array of eigen values ($\omega_i^2$, being the squared eigen frequencies in ($\omega_i$ in rad/s)!), eigenVectors a numpy array containing the eigenvectors in every column  \item[--]  {\bf example}: \vspace{-12pt}\ei\begin{lstlisting}[language=Python, xleftmargin=36pt]
#take any example from the Examples or TestModels folder, e.g., 'cartesianSpringDamper.py' and run it
  #then execute the following commands in the console (or add it to the file):
  [values, vectors] = exu.ComputeODE2Eigenvalues(mbs)
  print("eigenvalues=", values)
  #==>values contains the eigenvalues of the ODE2 part of the system in the current configuration\end{lstlisting}\vspace{-24pt}\bi\item[]\vspace{-24pt}\vspace{12pt}\end{itemize}
%
\mysubsection{Module: utilities}
\label{sec:module:utilities}
  Basic support functions for simpler creation of Exudyn models.
			Advanced functions for loading and animating solutions and for drawing a graph of the mbs system.
           This library requires numpy (as well as time and copy)
\begin{itemize}[leftmargin=1.4cm]
\setlength{\itemindent}{-1.4cm}
\item[]Author:    Johannes Gerstmayr
\item[]Date:      2019-07-26 (created)
\ei
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L30}{PlotLineCode}{}}}\label{sec:utilities:PlotLineCode}
({\it index})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: helper functions for matplotlib, returns a list of 28 line codes to be used in plot, e.g. 'r-' for red solid line  \item[--]  {\bf input}: index in range(0:28)  \item[--]  {\bf output}: a color and line style code for matplotlib plot\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L49}{FillInSubMatrix}{}}}\label{sec:utilities:FillInSubMatrix}
({\it subMatrix}, {\it destinationMatrix}, {\it destRow}, {\it destColumn})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: fill submatrix into given destinationMatrix; all matrices must be numpy arrays  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it subMatrix}: input matrix, which is filled into destinationMatrix
    \item[] {\it   destinationMatrix}: the subMatrix is entered here
    \item[] {\it   destRow}: row destination of subMatrix
    \item[] {\it   destColumn}: column destination of subMatrix
  \end{itemize}
  \item[--]  {\bf output}: destinationMatrix is changed after function call  \item[--]  {\bf notes}: may be erased in future!\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L68}{SweepSin}{}}}\label{sec:utilities:SweepSin}
({\it t}, {\it t1}, {\it f0}, {\it f1})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute sin sweep at given time t  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it t}: evaluate of sweep at time t
    \item[] {\it   t1}: end time of sweep frequency range
    \item[] {\it   f0}: start of frequency interval [f0,f1] in Hz
    \item[] {\it   f1}: end of frequency interval [f0,f1] in Hz
  \end{itemize}
  \item[--]  {\bf output}: evaluation of sin sweep (in range -1..+1)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L79}{SweepCos}{}}}\label{sec:utilities:SweepCos}
({\it t}, {\it t1}, {\it f0}, {\it f1})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute cos sweep at given time t  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it t}: evaluate of sweep at time t
    \item[] {\it   t1}: end time of sweep frequency range
    \item[] {\it   f0}: start of frequency interval [f0,f1] in Hz
    \item[] {\it   f1}: end of frequency interval [f0,f1] in Hz
  \end{itemize}
  \item[--]  {\bf output}: evaluation of cos sweep (in range -1..+1)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L90}{FrequencySweep}{}}}\label{sec:utilities:FrequencySweep}
({\it t}, {\it t1}, {\it f0}, {\it f1})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: frequency according to given sweep functions SweepSin, SweepCos  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it t}: evaluate of frequency at time t
    \item[] {\it   t1}: end time of sweep frequency range
    \item[] {\it   f0}: start of frequency interval [f0,f1] in Hz
    \item[] {\it   f1}: end of frequency interval [f0,f1] in Hz
  \end{itemize}
  \item[--]  {\bf output}: frequency in Hz\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L99}{IndexFromValue}{}}}\label{sec:utilities:IndexFromValue}
({\it data}, {\it value}, {\it tolerance}= 1e-7)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: get index from value in given data vector (numpy array); usually used to get specific index of time vector  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it data}: containing (almost) equidistant values of time
    \item[] {\it   value}: e.g., time to be found in data
    \item[] {\it   tolerance}: tolerance, which is accepted (default: tolerance=1e-7)
  \end{itemize}
  \item[--]  {\bf output}: index\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L116}{RoundMatrix}{}}}\label{sec:utilities:RoundMatrix}
({\it matrix}, {\it treshold}= 1e-14)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: set all entries in matrix to zero which are smaller than given treshold; operates directly on matrix  \item[--]  {\bf input}: matrix as np.array, treshold as positive value  \item[--]  {\bf output}: changes matrix\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L127}{ComputeSkewMatrix}{}}}\label{sec:utilities:ComputeSkewMatrix}
({\it v})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute (3 x 3*n) skew matrix from (3*n) vector; used for ObjectFFRF and CMS implementation  \item[--]  {\bf input}: a vector v in np.array format, containing 3*n components  \item[--]  {\bf output}: (3 x 3*n) skew matrix in np.array format\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L170}{CheckInputVector}{}}}\label{sec:utilities:CheckInputVector}
({\it vector}, {\it length}= -1)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: check if input is list or array with according length; if length==-1, the length is not checked; raises Exception if the check fails  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it vector}: a vector in np.array or list format
    \item[] {\it   length}: desired length of vector; if length=-1, it is ignored
  \end{itemize}
  \item[--]  {\bf output}: None\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L188}{CheckInputIndexArray}{}}}\label{sec:utilities:CheckInputIndexArray}
({\it indexArray}, {\it length}= -1)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: check if input is list or array with according length and positive indices; if length==-1, the length is not checked; raises Exception if the check fails  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it indexArray}: a vector in np.array or list format
    \item[] {\it   length}: desired length of vector; if length=-1, it is ignored
  \end{itemize}
  \item[--]  {\bf output}: None\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L220}{LoadSolutionFile}{}}}\label{sec:utilities:LoadSolutionFile}
({\it fileName})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: read coordinates solution file (exported during static or dynamic simulation with option exu.SimulationSettings().solutionSettings.coordinatesSolutionFileName='...') into dictionary:  \item[--]  {\bf input}: fileName: string containing directory and filename of stored coordinatesSolutionFile  \item[--]  {\bf output}: dictionary with 'data': the matrix of stored solution vectors, 'columnsExported': a list with binary values showing the exported columns [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData],'nColumns': the number of data columns and 'nRows': the number of data rows\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L244}{SetSolutionState}{}}}\label{sec:utilities:SetSolutionState}
({\it exu}, {\it mbs}, {\it solution}, {\it row}, {\it configuration})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: load selected row of solution dictionary (previously loaded with LoadSolutionFile) into specific state\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L270}{SetVisualizationState}{}}}\label{sec:utilities:SetVisualizationState}
({\it exu}, {\it mbs}, {\it solution}, {\it row})
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: load selected row of solution dictionary into visualization state and redraw  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it exu}: the exudyn library
    \item[] {\it   mbs}: the system, where the state is applied to
    \item[] {\it   solution}: solution dictionary previously loaded with LoadSolutionFile
    \item[] {\it   row}: the according row of the solution file which is visualized
  \end{itemize}
  \item[--]  {\bf output}: renders the scene in mbs and changes the visualization state in mbs\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L285}{AnimateSolution}{}}}\label{sec:utilities:AnimateSolution}
({\it exu}, {\it SC}, {\it mbs}, {\it solution}, {\it rowIncrement}= 1, {\it timeout}= 0.04, {\it createImages}= False, {\it runLoop}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: consecutively load the rows of a solution file and visualize the result  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it exu}: the exudyn library
    \item[] {\it   SC}: the system container, where the mbs lives in
    \item[] {\it   mbs}: the system used for animation
    \item[] {\it   solution}: solution dictionary previously loaded with LoadSolutionFile; will be played from first to last row
    \item[] {\it   rowIncrement}: can be set larger than 1 in order to skip solution frames: e.g. rowIncrement=10 visualizes every 10th row (frame)
    \item[] {\it   timeout}: in seconds is used between frames in order to limit the speed of animation; e.g. use timeout=0.04 to achieve approximately 25 frames per second
    \item[] {\it   createImages}: creates consecutively images from the animation, which can be converted into an animation
    \item[] {\it   runLoop}: if True, the animation is played in a loop until 'q' is pressed in render window
  \end{itemize}
  \item[--]  {\bf output}: renders the scene in mbs and changes the visualization state in mbs continuously\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L312}{DrawSystemGraph}{}}}\label{sec:utilities:DrawSystemGraph}
({\it mbs}, {\it showLoads}= True, {\it showSensors}= True, {\it useItemNames}= False, {\it useItemTypes}= False)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: helper function which draws system graph of a MainSystem (mbs); several options let adjust the appearance of the graph  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it showLoads}: toggle appearance of loads in mbs
    \item[] {\it    showSensors}: toggle appearance of sensors in mbs
    \item[] {\it    useItemNames}: if True, object names are shown instead of basic object types (Node, Load, ...)
    \item[] {\it    useItemTypes}: if True, object type names (ObjectMassPoint, ...) are shown instead of basic object types (Node, Load, ...)
  \end{itemize}
  \item[--]  {\bf output}: nothing\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L594}{GenerateStraightLineANCFCable2D}{}}}\label{sec:utilities:GenerateStraightLineANCFCable2D}
({\it mbs}, {\it positionOfNode0}, {\it positionOfNode1}, {\it numberOfElements}, {\it cableTemplate}, {\it massProportionalLoad}= [0,0,0], {\it fixedConstraintsNode0}= [0,0,0,0], {\it fixedConstraintsNode1}= [0,0,0,0], {\it vALE}= 0, {\it ConstrainAleCoordinate}= True)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate cable elements along straight line with certain discretization  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mbs}: the system where ANCF cables are added
    \item[] {\it   positionOfNode0}: 3D position (list or np.array) for starting point of line
    \item[] {\it   positionOfNode1}: 3D position (list or np.array) for end point of line
    \item[] {\it   numberOfElements}: for discretization of line
    \item[] {\it   cableTemplate}: a ObjectANCFCable2D object, containing the desired cable properties; cable length and node numbers are set automatically
    \item[] {\it   massProportionalLoad}: a 3D list or np.array, containing the gravity vector or zero
    \item[] {\it   fixedConstraintsNode0}: a list of 4 binary values, indicating the coordinate contraints on the first node (x,y-position and x,y-slope)
    \item[] {\it   fixedConstraintsNode1}: a list of 4 binary values, indicating the coordinate contraints on the last node (x,y-position and x,y-slope)
    \item[] {\it   vALE}: used for ObjectALEANCFCable2D objects
  \end{itemize}
  \item[--]  {\bf output}: returns a list [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L675}{GenerateSlidingJoint}{}}}\label{sec:utilities:GenerateSlidingJoint}
({\it mbs}, {\it cableObjectList}, {\it markerBodyPositionOfSlidingBody}, {\it localMarkerIndexOfStartCable}= 0, {\it slidingCoordinateStartPosition}= 0)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate a sliding joint from a list of cables, marker to a sliding body, etc.\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\begin{flushleft}
\noindent {def {\bf \exuUrl{https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/exudyn/utilities.py\#L701}{GenerateAleSlidingJoint}{}}}\label{sec:utilities:GenerateAleSlidingJoint}
({\it mbs}, {\it cableObjectList}, {\it markerBodyPositionOfSlidingBody}, {\it AleNode}, {\it localMarkerIndexOfStartCable}= 0, {\it AleSlidingOffset}= 0, {\it activeConnector}= True, {\it penaltyStiffness}= 0)
\end{flushleft}
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate an ALE sliding joint from a list of cables, marker to a sliding body, etc.\vspace{12pt}\end{itemize}
%
