% ++++++++++++++++++++++% description of manual pybind interfaces; generated by Johannes Gerstmayr% ++++++++++++++++++++++
%++++++++++++++++++++
\mysubsection{\codeName}
These are the access functions to the \codeName\ module.

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  GetVersionString() & Get EXUDYN module version as string\\ \hline 
  RequireVersion(requiredVersionString) & Checks if the installed version is according to the required version. Major, micro and minor version must agree the required level. Example: RequireVersion("1.0.31")\\ \hline 
  StartRenderer(verbose = false) & Start OpenGL rendering engine (in separate thread); use verbose=True to output information during OpenGL window creation\\ \hline 
  StopRenderer() & Stop OpenGL rendering engine\\ \hline 
  SolveStatic(mbs, simulationSettings = exudyn.SimulationSettings(), updateInitialValues = False, storeSolver = True) & Static solver function, mapped from module \texttt{solver}; for details on the python interface see \refSection{sec:solver:SolveStatic}; for background on solvers, see \refSection{sec:solver:equations}\\ \hline 
  SolveDynamic(mbs, simulationSettings = exudyn.SimulationSettings(), solverType = exudyn.DynamicSolverType.GeneralizedAlpha, updateInitialValues = False, storeSolver = True) & Dynamic solver function, mapped from module \texttt{solver}; for details on the python interface see \refSection{sec:solver:SolveDynamic}; for background on solvers, see \refSection{sec:solver:equations}\\ \hline 
  ComputeODE2Eigenvalues(mbs, simulationSettings = exudyn.SimulationSettings(), useSparseSolver = False, numberOfEigenvalues = -1, setInitialValues = True, convert2Frequencies = False) & Simple interface to scipy eigenvalue solver for eigenvalue analysis of the second order differential equations part in mbs, mapped from module \texttt{solver}; for details on the python interface see \refSection{sec:solver:ComputeODE2Eigenvalues}\\ \hline 
  SetOutputPrecision(numberOfDigits) & Set the precision (integer) for floating point numbers written to console (reset when simulation is started!)\\ \hline 
  SetLinalgOutputFormatPython(flagPythonFormat) & true: use python format for output of vectors and matrices; false: use matlab format\\ \hline 
  SetWriteToConsole(flag) & set flag to write (true) or not write to console; default = true\\ \hline 
  SetWriteToFile(filename, flagWriteToFile = true, flagAppend = false) & set flag to write (true) or not write to console; default value of flagWriteToFile = false; flagAppend appends output to file, if set true; in order to finalize the file, write exu.SetWriteToFile('', False) to close the output file\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{exu.SetWriteToConsole(False) \#no output to console\tabnewline
    exu.SetWriteToFile(filename='testOutput.log', flagWriteToFile=True, flagAppend=False)\tabnewline
    exu.Print('print this to file')\tabnewline
    exu.SetWriteToFile('', False) \#terminate writing to file which closes the file}}\\ \hline 
  SetPrintDelayMilliSeconds(delayMilliSeconds) & add some delay (in milliSeconds) to printing to console, in order to let Spyder process the output; default = 0\\ \hline 
  Print() & this allows printing via exudyn with similar syntax as in python print(args) except for keyword arguments: print('test=',42); allows to redirect all output to file given by SetWriteToFile(...); does not output in case that SetWriteToConsole is set to false\\ \hline 
  InfoStat() & Print some global (debug) information: linear algebra, memory allocation, threads, computational efficiency, etc.\\ \hline 
  Go() & Creates a SystemContainer SC and a main system mbs\\ \hline 
  InvalidIndex() & This function provides the invalid index, which depends on the kind of 32-bit, 64-bit signed or unsigned integer; e.g. node index or item index in list; in future, the invalid index may be changed to -1, therefore you should use this variable\\ \hline 
  variables & this dictionary may be used by the user to store exudyn-wide data in order to avoid global python variables; usage: exu.variables["myvar"] = 42 \\ \hline  
  sys & this dictionary is used and reserved by the system, e.g. for testsuite, graphics or system function to store module-wide data in order to avoid global python variables; the variable exu.sys['renderState'] contains the last render state after exu.StopRenderer() and can be used for subsequent simulations \\ \hline  
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsection{SystemContainer}
The SystemContainer is the top level of structures in \codeName. The container holds all systems, solvers and all other data structures for computation. Currently, only one container shall be used. In future, multiple containers might be usable at the same time. \\ Example: \\ \texttt{import exudyn as exu \\ SC = exu.SystemContainer() \\ mbs = SC.AddSystem()}

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  AddSystem() & add a new computational system\\ \hline 
  visualizationSettings & this structure is read/writeable and contains visualization settings, which are immediately applied to the rendering window. \tabnewline
    EXAMPLE:\tabnewline
    SC = exu.SystemContainer()\tabnewline
    SC.visualizationSettings.autoFitScene=False  \\ \hline  
  TimeIntegrationSolve(mainSystem, solverName, simulationSettings) & DEPRECATED, use exu.SolveDynamic(...) instead, see efSection{sec:solver:SolveDynamic}! Call time integration solver for given system with solverName ('RungeKutta1'...explicit solver, 'GeneralizedAlpha'...implicit solver); use simulationSettings to individually configure the solver\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{simSettings = exu.SimulationSettings()\tabnewline
    simSettings.timeIntegration.numberOfSteps = 1000\tabnewline
    simSettings.timeIntegration.endTime = 2\tabnewline
    simSettings.timeIntegration.verboseMode = 1\tabnewline
    SC.TimeIntegrationSolve(mbs, 'GeneralizedAlpha', simSettings)}}\\ \hline 
  StaticSolve(mainSystem, simulationSettings) & DEPRECATED, use exu.SolveStatic(...) insteadefSection{sec:solver:SolveStatic}! Call solver to compute a static solution of the system, considering acceleration and velocity coordinates to be zero (initial velocities may be considered by certain objects)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{simSettings = exu.SimulationSettings()\tabnewline
    simSettings.staticSolver.newton.relativeTolerance = 1e-6\tabnewline
    SC.StaticSolve(mbs, simSettings)}}\\ \hline 
  GetRenderState() & Get dictionary with current render state (openGL zoom, modelview, etc.)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{SC = exu.SystemContainer()\tabnewline
    renderState = SC.GetRenderState() \tabnewline
    print(renderState['zoom'])}}\\ \hline 
  SetRenderState(renderState) & Set current render state (openGL zoom, modelview, etc.) with given dictionary; usually, this dictionary has been obtained with GetRenderState\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{SC = exu.SystemContainer()\tabnewline
    SC.SetRenderState(renderState)}}\\ \hline 
  WaitForRenderEngineStopFlag() & Wait for user to stop render engine (Press 'Q' or Escape-key)\\ \hline 
  RenderEngineZoomAll() & Send zoom all signal, which will perform zoom all at next redraw request\\ \hline 
  RedrawAndSaveImage() & Redraw openGL scene and save image (command waits until process is finished)\\ \hline 
  GetCurrentMouseCoordinates(useOpenGLcoordinates = False) & Get current mouse coordinates as list [x, y]; x and y being floats, as returned by GLFW, measured from top left corner of window; use GetCurrentMouseCoordinates(useOpenGLcoordinates=True) to obtain OpenGLcoordinates of projected plane\\ \hline 
  Reset() & delete all systems and reset SystemContainer (including graphics)\\ \hline 
  NumberOfSystems() & obtain number of systems available in system container\\ \hline 
  GetSystem(systemNumber) & obtain systems with index from system container\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsection{MainSystem}
This is the structure which defines a (multibody) system. In C++, there is a MainSystem (links to python) and a System (computational part). For that reason, the name is MainSystem on the python side, but it is often just called 'system'. It can be created, visualized and computed. Use the following functions for system manipulation. \\ \\ Usage: \\ \\ \texttt{import exudyn as exu \\ SC = exu.SystemContainer() \\ mbs = SC.AddSystem()}

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  Assemble() & assemble items (nodes, bodies, markers, loads, ...); Calls CheckSystemIntegrity(...), AssembleCoordinates(), AssembleLTGLists(), and AssembleInitializeSystemCoordinates()\\ \hline 
  AssembleCoordinates() & assemble coordinates: assign computational coordinates to nodes and constraints (algebraic variables)\\ \hline 
  AssembleLTGLists() & build local-to-global (ltg) coordinate lists for objects (used to build global ODE2RHS, MassMatrix, etc. vectors and matrices)\\ \hline 
  AssembleInitializeSystemCoordinates() & initialize all system-wide coordinates based on initial values given in nodes\\ \hline 
  Reset() & reset all lists of items (nodes, bodies, markers, loads, ...) and temporary vectors; deallocate memory\\ \hline 
  WaitForUserToContinue() & interrupt further computation until user input --> 'pause' function\\ \hline 
  SendRedrawSignal() & this function is used to send a signal to the renderer that the scene shall be redrawn because the visualization state has been updated\\ \hline 
  GetRenderEngineStopFlag() & get the current stop simulation flag; true=user wants to stop simulation\\ \hline 
  SetRenderEngineStopFlag() & set the current stop simulation flag; set to false, in order to continue a previously user-interrupted simulation\\ \hline 
  SetPreStepUserFunction() & Sets a user function PreStepUserFunction(mbs, t) executed at beginning of every computation step; in normal case return True; return False to stop simulation after current step\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{def PreStepUserFunction(mbs, t):\tabnewline
     \phantom{XXXX} print(mbs.systemData.NumberOfNodes())\tabnewline
     \phantom{XXXX} if(t>1): \tabnewline
     \phantom{XXXX} \phantom{XXXX} return False \tabnewline
     \phantom{XXXX} return True \tabnewline
     mbs.SetPreStepUserFunction(PreStepUserFunction)}}\\ \hline 
  \_\_repr\_\_() & return the representation of the system, which can be, e.g., printed\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{print(mbs)}}\\ \hline 
  systemIsConsistent & this flag is used by solvers to decide, whether the system is in a solvable state; this flag is set to false as long as Assemble() has not been called; any modification to the system, such as Add...(), Modify...(), etc. will set the flag to false again; this flag can be modified (set to true), if a change of e.g.~an object (change of stiffness) or load (change of force) keeps the system consistent, but would normally lead to systemIsConsistent=False  \\ \hline  
  interactiveMode & set this flag to true in order to invoke a Assemble() command in every system modification, e.g. AddNode, AddObject, ModifyNode, ...; this helps that the system can be visualized in interactive mode. \\ \hline  
  variables & this dictionary may be used by the user to store model-specific data, in order to avoid global python variables in complex models; mbs.variables["myvar"] = 42 \\ \hline  
  sys & this dictionary is used by exudyn python libraries, e.g., solvers, to avoid global python variables \\ \hline 
  solverSignalJacobianUpdate & this flag is used by solvers to decide, whether the jacobian should be updated; at beginning of simulation and after jacobian computation, this flag is set automatically to False; use this flag to indicate system changes, e.g. during time integration  \\ \hline  
  systemData & Access to SystemData structure; enables access to number of nodes, objects, ... and to (current, initial, reference, ...) state variables (ODE2, AE, Data,...)\\ \hline  
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{MainSystem: Node}
\label{sec:mainsystem:node}
 This section provides functions for adding, reading and modifying nodes. Nodes are used to define coordinates (unknowns to the static system and degrees of freedom if constraints are not present). Nodes can provide various types of coordinates for second/first order differential equations (ODE2/ODE1), algebraic equations (AE) and for data (history) variables -- which are not providing unknowns in the nonlinear solver but will be solved in an additional nonlinear iteration for e.g. contact, friction or plasticity.

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  AddNode(pyObject) & add a node with nodeDefinition from Python node class; returns (global) node index (type NodeIndex) of newly added node; use int(nodeIndex) to convert to int, if needed (but not recommended in order not to mix up index types of nodes, objects, markers, ...)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{item = Rigid2D( referenceCoordinates= [1,0.5,0], initialVelocities= [10,0,0]) \tabnewline
    mbs.AddNode(item) \tabnewline
    nodeDict = \{'nodeType': 'Point', \tabnewline
    'referenceCoordinates': [1.0, 0.0, 0.0], \tabnewline
    'initialCoordinates': [0.0, 2.0, 0.0], \tabnewline
    'name': 'example node'\} \tabnewline
     mbs.AddNode(nodeDict)}}\\ \hline 
  GetNodeNumber(nodeName) & get node's number by name (string)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{n = mbs.GetNodeNumber('example node')}}\\ \hline 
  GetNode(nodeNumber) & get node's dictionary by node number (type NodeIndex)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{nodeDict = mbs.GetNode(0)}}\\ \hline 
  ModifyNode(nodeNumber, nodeDict) & modify node's dictionary by node number (type NodeIndex)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.ModifyNode(nodeNumber, nodeDict)}}\\ \hline 
  GetNodeDefaults(typeName) & get node's default values for a certain nodeType as (dictionary)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{nodeType = 'Point'\tabnewline
    nodeDict = mbs.GetNodeDefaults(nodeType)}}\\ \hline 
  GetNodeOutput(nodeNumber, variableType, configuration = ConfigurationType.Current) & get the ouput of the node specified with the OutputVariableType; default configuration = 'current'; output may be scalar or array (e.g. displacement vector)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.GetNodeOutput(nodeNumber=0, variableType='exu.OutputVariable.Displacement')}}\\ \hline 
  GetNodeODE2Index(nodeNumber) & get index in the global ODE2 coordinate vector for the first node coordinate of the specified node\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.GetNodeODE2Index(nodeNumber=0)}}\\ \hline 
  GetNodeParameter(nodeNumber, parameterName) & get nodes's parameter from node number (type NodeIndex) and parameterName; parameter names can be found for the specific items in the reference manual\\ \hline 
  SetNodeParameter(nodeNumber, parameterName, value) & set parameter 'parameterName' of node with node number (type NodeIndex) to value; parameter names can be found for the specific items in the reference manual\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{MainSystem: Object}
\label{sec:mainsystem:object}
 This section provides functions for adding, reading and modifying objects, which can be bodies (mass point, rigid body, finite element, ...), connectors (spring-damper or joint) or general objects. Objects provided terms to the residual of equations resulting from every coordinate given by the nodes. Single-noded objects (e.g.~mass point) provides exactly residual terms for its nodal coordinates. Connectors constrain or penalize two markers, which can be, e.g., position, rigid or coordinate markers. Thus, the dependence of objects is either on the coordinates of the marker-objects/nodes or on nodes which the objects possess themselves.

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  AddObject(pyObject) & add an object with objectDefinition from Python object class; returns (global) object number (type ObjectIndex) of newly added object\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{item = MassPoint(name='heavy object', nodeNumber=0, physicsMass=100) \tabnewline
    mbs.AddObject(item) \tabnewline
    objectDict = \{'objectType': 'MassPoint', \tabnewline
    'physicsMass': 10, \tabnewline
    'nodeNumber': 0, \tabnewline
    'name': 'example object'\} \tabnewline
     mbs.AddObject(objectDict)}}\\ \hline 
  GetObjectNumber(objectName) & get object's number by name (string)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{n = mbs.GetObjectNumber('heavy object')}}\\ \hline 
  GetObject(objectNumber) & get object's dictionary by object number (type ObjectIndex)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{objectDict = mbs.GetObject(0)}}\\ \hline 
  ModifyObject(objectNumber, objectDict) & modify object's dictionary by object number (type ObjectIndex)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.ModifyObject(objectNumber, objectDict)}}\\ \hline 
  GetObjectDefaults(typeName) & get object's default values for a certain objectType as (dictionary)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{objectType = 'MassPoint'\tabnewline
    objectDict = mbs.GetObjectDefaults(objectType)}}\\ \hline 
  GetObjectOutput(objectNumber, variableType) & get object's current output variable from object number (type ObjectIndex) and OutputVariableType; can only be computed for exu.ConfigurationType.Current configuration!\\ \hline 
  GetObjectOutputBody(objectNumber, variableType, localPosition, configuration = ConfigurationType.Current) & get body's output variable from object number (type ObjectIndex) and OutputVariableType\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{u = mbs.GetObjectOutputBody(objectNumber = 1, variableType = exu.OutputVariableType.Position, localPosition=[1,0,0], configuration = exu.ConfigurationType.Initial)}}\\ \hline 
  GetObjectOutputSuperElement(objectNumber, variableType, meshNodeNumber, configuration = ConfigurationType.Current) & get output variable from mesh node number of object with type SuperElement (GenericODE2, FFRF, FFRFreduced - CMS) with specific OutputVariableType; the meshNodeNumber is the object's local node number, not the global node number!\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{u = mbs.GetObjectOutputSuperElement(objectNumber = 1, variableType = exu.OutputVariableType.Position, meshNodeNumber = 12, configuration = exu.ConfigurationType.Initial)}}\\ \hline 
  GetObjectParameter(objectNumber, parameterName) & get objects's parameter from object number (type ObjectIndex) and parameterName; parameter names can be found for the specific items in the reference manual\\ \hline 
  SetObjectParameter(objectNumber, parameterName, value) & set parameter 'parameterName' of object with object number (type ObjectIndex) to value; parameter names can be found for the specific items in the reference manual\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{MainSystem: Marker}
\label{sec:mainsystem:marker}
 This section provides functions for adding, reading and modifying markers. Markers define how to measure primal kinematical quantities on objects or nodes (e.g., position, orientation or coordinates themselves), and how to act on the quantities which are dual to the kinematical quantities (e.g., force, torque and generalized forces). Markers provide unique interfaces for loads, sensors and constraints in order to address these quantities independently of the structure of the object or node (e.g., rigid or flexible body).

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  AddMarker(pyObject) & add a marker with markerDefinition from Python marker class; returns (global) marker number (type MarkerIndex) of newly added marker\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{item = MarkerNodePosition(name='my marker',nodeNumber=1) \tabnewline
    mbs.AddMarker(item)\tabnewline
    markerDict = \{'markerType': 'NodePosition', \tabnewline
     'nodeNumber': 0, \tabnewline
     'name': 'position0'\}\tabnewline
     mbs.AddMarker(markerDict)}}\\ \hline 
  GetMarkerNumber(markerName) & get marker's number by name (string)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{n = mbs.GetMarkerNumber('my marker')}}\\ \hline 
  GetMarker(markerNumber) & get marker's dictionary by index\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{markerDict = mbs.GetMarker(0)}}\\ \hline 
  ModifyMarker(markerNumber, markerDict) & modify marker's dictionary by index\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.ModifyMarker(markerNumber, markerDict)}}\\ \hline 
  GetMarkerDefaults(typeName) & get marker's default values for a certain markerType as (dictionary)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{markerType = 'NodePosition'\tabnewline
    markerDict = mbs.GetMarkerDefaults(markerType)}}\\ \hline 
  GetMarkerParameter(markerNumber, parameterName) & get markers's parameter from markerNumber and parameterName; parameter names can be found for the specific items in the reference manual\\ \hline 
  SetMarkerParameter(markerNumber, parameterName, value) & set parameter 'parameterName' of marker with markerNumber to value; parameter names can be found for the specific items in the reference manual\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{MainSystem: Load}
\label{sec:mainsystem:load}
 This section provides functions for adding, reading and modifying operating loads. Loads are used to act on the quantities which are dual to the primal kinematic quantities, such as displacement and rotation. Loads represent, e.g., forces, torques or generalized forces.

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  AddLoad(pyObject) & add a load with loadDefinition from Python load class; returns (global) load number (type LoadIndex) of newly added load\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{item = mbs.AddLoad(LoadForceVector(loadVector=[1,0,0], markerNumber=0, name='heavy load')) \tabnewline
    mbs.AddLoad(item)\tabnewline
    loadDict = \{'loadType': 'ForceVector',\tabnewline
     'markerNumber': 0,\tabnewline
     'loadVector': [1.0, 0.0, 0.0],\tabnewline
     'name': 'heavy load'\} \tabnewline
     mbs.AddLoad(loadDict)}}\\ \hline 
  GetLoadNumber(loadName) & get load's number by name (string)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{n = mbs.GetLoadNumber('heavy load')}}\\ \hline 
  GetLoad(loadNumber) & get load's dictionary by index\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{loadDict = mbs.GetLoad(0)}}\\ \hline 
  ModifyLoad(loadNumber, loadDict) & modify load's dictionary by index\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.ModifyLoad(loadNumber, loadDict)}}\\ \hline 
  GetLoadDefaults(typeName) & get load's default values for a certain loadType as (dictionary)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{loadType = 'ForceVector'\tabnewline
    loadDict = mbs.GetLoadDefaults(loadType)}}\\ \hline 
  GetLoadValues(loadNumber) & Get current load values, specifically if user-defined loads are used; can be scalar or vector-valued return value\\ \hline 
  GetLoadParameter(loadNumber, parameterName) & get loads's parameter from loadNumber and parameterName; parameter names can be found for the specific items in the reference manual\\ \hline 
  SetLoadParameter(loadNumber, parameterName, value) & set parameter 'parameterName' of load with loadNumber to value; parameter names can be found for the specific items in the reference manual\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{MainSystem: Sensor}
\label{sec:mainsystem:sensor}
 This section provides functions for adding, reading and modifying operating sensors. Sensors are used to measure information in nodes, objects, markers, and loads for output in a file.

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  AddSensor(pyObject) & add a sensor with sensor definition from Python sensor class; returns (global) sensor number (type SensorIndex) of newly added sensor\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{item = mbs.AddSensor(SensorNode(sensorType= exu.SensorType.Node, nodeNumber=0, name='test sensor')) \tabnewline
    mbs.AddSensor(item)\tabnewline
    sensorDict = \{'sensorType': 'Node',\tabnewline
     'nodeNumber': 0,\tabnewline
     'fileName': 'sensor.txt',\tabnewline
     'name': 'test sensor'\} \tabnewline
     mbs.AddSensor(sensorDict)}}\\ \hline 
  GetSensorNumber(sensorName) & get sensor's number by name (string)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{n = mbs.GetSensorNumber('test sensor')}}\\ \hline 
  GetSensor(sensorNumber) & get sensor's dictionary by index\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{sensorDict = mbs.GetSensor(0)}}\\ \hline 
  ModifySensor(sensorNumber, sensorDict) & modify sensor's dictionary by index\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.ModifySensor(sensorNumber, sensorDict)}}\\ \hline 
  GetSensorDefaults(typeName) & get sensor's default values for a certain sensorType as (dictionary)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{sensorType = 'Node'\tabnewline
    sensorDict = mbs.GetSensorDefaults(sensorType)}}\\ \hline 
  GetSensorValues(sensorNumber, configuration = ConfigurationType.Current) & get sensors's values for configuration; can be a scalar or vector-valued return value!\\ \hline 
  GetSensorParameter(sensorNumber, parameterName) & get sensors's parameter from sensorNumber and parameterName; parameter names can be found for the specific items in the reference manual\\ \hline 
  SetSensorParameter(sensorNumber, parameterName, value) & set parameter 'parameterName' of sensor with sensorNumber to value; parameter names can be found for the specific items in the reference manual\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsection{SystemData}
This is the data structure of a system which contains Objects (bodies/constraints/...), Nodes, Markers and Loads. The SystemData structure allows advanced access to this data, which HAS TO BE USED WITH CARE, as unexpected results and system crash might happen. \\ 
 Usage: \\ \small 
\texttt{\#obtain current ODE2 system vector (e.g. after static simulation finished): \\ u = mbs.systemData.GetODE2Coordinates() \\ \#set initial ODE2 vector for next simulation:\\ 
mbs.systemData.SetODE2Coordinates(coordinates=u,configurationType=exu.ConfigurationType.Initial)}


\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  NumberOfLoads() & return number of loads in system\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{print(mbs.systemData.NumberOfLoads())}}\\ \hline 
  NumberOfMarkers() & return number of markers in system\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{print(mbs.systemData.NumberOfMarkers())}}\\ \hline 
  NumberOfNodes() & return number of nodes in system\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{print(mbs.systemData.NumberOfNodes())}}\\ \hline 
  NumberOfObjects() & return number of objects in system\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{print(mbs.systemData.NumberOfObjects())}}\\ \hline 
  NumberOfSensors() & return number of sensors in system\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{print(mbs.systemData.NumberOfSensors())}}\\ \hline 
  GetTime(configurationType = exu.ConfigurationType.Current) & get configuration dependent time.\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.GetTime(exu.ConfigurationType.Initial)}}\\ \hline 
  SetTime(newTime, configurationType = exu.ConfigurationType.Current) & set configuration dependent time; use this access with care, e.g. in user-defined solvers.\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.SetTime(10., exu.ConfigurationType.Initial)}}\\ \hline 
  GetCurrentTime() & DEPRICATED; get current (simulation) time; time is updated in time integration solvers and in static solver; use this function e.g. during simulation to define time-dependent loads\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.GetCurrentTime()}}\\ \hline 
  SetVisualizationTime() & DEPRICATED; set time for render window (visualization)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.SetVisualizationTime(1.3)}}\\ \hline 
  Info() & print detailed system information for every item; for short information use print(mbs)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.Info()}}\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{SystemData: Access coordinates}
\label{sec:mbs:systemData}This section provides access functions to global coordinate vectors. Assigning invalid values or using wrong vector size might lead to system crash and unexpected results.

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  GetODE2Coordinates(configuration = exu.ConfigurationType.Current) & get ODE2 system coordinates (displacements) for given configuration (default: exu.Configuration.Current)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{uCurrent = mbs.systemData.GetODE2Coordinates()}}\\ \hline 
  SetODE2Coordinates(coordinates, configuration = exu.ConfigurationType.Current) & set ODE2 system coordinates (displacements) for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.SetODE2Coordinates(uCurrent)}}\\ \hline 
  GetODE2Coordinates\_t(configuration = exu.ConfigurationType.Current) & get ODE2 system coordinates (velocities) for given configuration (default: exu.Configuration.Current)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{vCurrent = mbs.systemData.GetODE2Coordinates\_t()}}\\ \hline 
  SetODE2Coordinates\_t(coordinates, configuration = exu.ConfigurationType.Current) & set ODE2 system coordinates (velocities) for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.SetODE2Coordinates\_t(vCurrent)}}\\ \hline 
  GetODE2Coordinates\_tt(configuration = exu.ConfigurationType.Current) & get ODE2 system coordinates (accelerations) for given configuration (default: exu.Configuration.Current)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{vCurrent = mbs.systemData.GetODE2Coordinates\_tt()}}\\ \hline 
  SetODE2Coordinates\_tt(coordinates, configuration = exu.ConfigurationType.Current) & set ODE2 system coordinates (accelerations) for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.SetODE2Coordinates\_tt(aCurrent)}}\\ \hline 
  GetODE1Coordinates(configuration = exu.ConfigurationType.Current) & get ODE1 system coordinates (displacements) for given configuration (default: exu.Configuration.Current)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{qCurrent = mbs.systemData.GetODE1Coordinates()}}\\ \hline 
  SetODE1Coordinates(coordinates, configuration = exu.ConfigurationType.Current) & set ODE1 system coordinates (displacements) for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.SetODE1Coordinates(qCurrent)}}\\ \hline 
  GetAECoordinates(configuration = exu.ConfigurationType.Current) & get algebraic equations (AE) system coordinates for given configuration (default: exu.Configuration.Current)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{lambdaCurrent = mbs.systemData.GetAECoordinates()}}\\ \hline 
  SetAECoordinates(coordinates, configuration = exu.ConfigurationType.Current) & set algebraic equations (AE) system coordinates for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.SetAECoordinates(lambdaCurrent)}}\\ \hline 
  GetDataCoordinates(configuration = exu.ConfigurationType.Current) & get system data coordinates for given configuration (default: exu.Configuration.Current)\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{dataCurrent = mbs.systemData.GetDataCoordinates()}}\\ \hline 
  SetDataCoordinates(coordinates, configuration = exu.ConfigurationType.Current) & set system data coordinates for given configuration (default: exu.Configuration.Current); invalid vector size may lead to system crash!\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.SetDataCoordinates(dataCurrent)}}\\ \hline 
  GetSystemState(configuration = exu.ConfigurationType.Current) & get system state for given configuration (default: exu.Configuration.Current); state vectors do not include the non-state derivatives ODE1\_t and ODE2\_tt and the time; function is copying data - not highly efficient; format of pyList: [ODE2Coords, ODE2Coords\_t, ODE1Coords, AEcoords, dataCoords]\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{sysStateList = mbs.systemData.GetSystemState()}}\\ \hline 
  SetSystemState(systemStateList, configuration = exu.ConfigurationType.Current) & set system data coordinates for given configuration (default: exu.Configuration.Current); invalid list of vectors / vector size may lead to system crash; write access to state vectors (but not the non-state derivatives ODE1\_t and ODE2\_tt and the time); function is copying data - not highly efficient; format of pyList: [ODE2Coords, ODE2Coords\_t, ODE1Coords, AEcoords, dataCoords]\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{mbs.systemData.SetSystemState(sysStateList, configuration = exu.ConfigurationType.Initial)}}\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{SystemData: Get object local-to-global (LTG) coordinate mappings}
This section provides access functions the LTG-lists for every object (body, constraint, ...) in the system.

\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  GetObjectLTGODE2(objectNumber) & get local-to-global coordinate mapping (list of global coordinate indices) for ODE2 coordinates; only available after Assemble()\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{ltgObject4 = mbs.systemData.GetObjectLTGODE2(4)}}\\ \hline 
  GetObjectLTGODE1(objectNumber) & get local-to-global coordinate mapping (list of global coordinate indices) for ODE1 coordinates; only available after Assemble()\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{ltgObject4 = mbs.systemData.GetObjectLTGODE1(4)}}\\ \hline 
  GetObjectLTGAE(objectNumber) & get local-to-global coordinate mapping (list of global coordinate indices) for algebraic equations (AE) coordinates; only available after Assemble()\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{ltgObject4 = mbs.systemData.GetObjectLTGODE2(4)}}\\ \hline 
  GetObjectLTGData(objectNumber) & get local-to-global coordinate mapping (list of global coordinate indices) for data coordinates; only available after Assemble()\tabnewline 
    \textcolor{steelblue}{{\bf EXAMPLE}: \tabnewline 
    \texttt{ltgObject4 = mbs.systemData.GetObjectLTGData(4)}}\\ \hline 
\end{longtable}
\end{center}
\section{Type definitions}
This section defines a couple of structures, which are used to select, e.g., a configuration type or a variable type. In the background, these types are integer numbers, but for safety, the types should be used as type variables. 

Conversion to integer is possible: 
 \bi 
 \item[] \texttt{x = int(exu.OutputVariableType.Displacement)} 
\ei and also conversion from integer: 
 \bi 
 \item[] \texttt{varType = exu.OutputVariableType(8)}
 \ei

%++++++++++++++++++++
\mysubsubsection{OutputVariableType}
This section shows the OutputVariableType structure, which is used for selecting output values, e.g. for GetObjectOutput(...) or for selecting variables for contour plot.

Available output variables and the interpreation of the output variable can be found at the object definitions. 
 The OutputVariableType does not provide information about the size of the output variable, which can be either scalar or a list (vector). For vector output quantities, the contour plot option offers an additional parameter for selection of the component of the OutputVariableType.


\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  \_None & no value; used, e.g., to select no output variable in contour plot\\ \hline 
  Distance & e.g., measure distance in spring damper connector\\ \hline 
  Position & measure 3D position, e.g., of node or body\\ \hline 
  Displacement & measure displacement; usually difference between current position and reference position\\ \hline 
  Velocity & measure (translational) velocity of node or object\\ \hline 
  Acceleration & measure (translational) acceleration of node or object\\ \hline 
  RotationMatrix & measure rotation matrix of rigid body node or object\\ \hline 
  AngularVelocity & measure angular velocity of node or object\\ \hline 
  AngularVelocityLocal & measure local (body-fixed) angular velocity of node or object\\ \hline 
  AngularAcceleration & measure angular acceleration of node or object\\ \hline 
  Rotation & measure, e.g., scalar rotation of 2D body, Euler angles of a 3D object or rotation within a joint\\ \hline 
  Coordinates & measure the coordinates of a node or object; coordinates usually just contain displacements, but not the position values\\ \hline 
  Coordinates\_t & measure the time derivative of coordinates (= velocity coordinates) of a node or object\\ \hline 
  Coordinates\_tt & measure the second time derivative of coordinates (= acceleration coordinates) of a node or object\\ \hline 
  SlidingCoordinate & measure sliding coordinate in sliding joint\\ \hline 
  Director1 & measure a director (e.g. of a rigid body frame), or a slope vector in local 1 or x-direction\\ \hline 
  Director2 & measure a director (e.g. of a rigid body frame), or a slope vector in local 2 or y-direction\\ \hline 
  Director3 & measure a director (e.g. of a rigid body frame), or a slope vector in local 3 or z-direction\\ \hline 
  Force & measure force, e.g., in joint or beam (resultant force)\\ \hline 
  Torque & measure torque, e.g., in joint or beam (resultant couple/moment)\\ \hline 
  Strain & measure strain, e.g., axial strain in beam\\ \hline 
  Stress & measure stress, e.g., axial stress in beam\\ \hline 
  Curvature & measure curvature; may be scalar or vectorial: twist and curvature\\ \hline 
  DisplacementLocal & measure local displacement, e.g. in local joint coordinates\\ \hline 
  VelocityLocal & measure local (translational) velocity, , e.g. in local joint coordinates\\ \hline 
  ForceLocal & measure local force, e.g., in joint or beam (resultant force)\\ \hline 
  TorqueLocal & measure local torque, e.g., in joint or beam (resultant couple/moment)\\ \hline 
  ConstraintEquation & evaluates constraint equation (=current deviation or drift of constraint equation)\\ \hline 
  EndOfEnumList & this marks the end of the list, usually not important to the user\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{ConfigurationType}
This section shows the ConfigurationType structure, which is used for selecting a configuration for reading or writing information to the module. Specifically, the ConfigurationType.Current configuration is usually used at the end of a solution process, to obtain result values, or the ConfigurationType.Initial is used to set initial values for a solution process.



\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  \_None & no configuration; usually not valid, but may be used, e.g., if no configurationType is required\\ \hline 
  Initial & initial configuration prior to static or dynamic solver; is computed during mbs.Assemble() or AssembleInitializeSystemCoordinates()\\ \hline 
  Current & current configuration during and at the end of the computation of a step (static or dynamic)\\ \hline 
  Reference & configuration used to define deformable bodies (reference configuration for finite elements) or joints (configuration for which some joints are defined)\\ \hline 
  StartOfStep & during computation, this refers to the solution at the start of the step = end of last step, to which the solver falls back if convergence fails\\ \hline 
  Visualization & this is a state completely de-coupled from computation, used for visualization\\ \hline 
  EndOfEnumList & this marks the end of the list, usually not important to the user\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{DynamicSolverType}
This section shows the DynamicSolverType structure, which is used for selecting dynamic solvers for simulation.



\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  GeneralizedAlpha & an implicit solver for index 3 problems; allows to set variables also for Newmark and trapezoidal implicit index 2 solvers\\ \hline 
  TrapezoidalIndex2 & an implicit solver for index 3 problems with index2 reduction; uses generalized alpha solver with settings for Newmark with index2 reduction\\ \hline 
  ExplicitEuler & [NOT IMPLEMENTED YET] an explicit first order solver for systems without constraints\\ \hline 
  RK45 & [NOT IMPLEMENTED YET] an explicit Runge Kutta solver of 4th order for systems without constraints; includes adaptive step selection\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{KeyCode}
This section shows the KeyCode structure, which is used for special key codes in keyPressUserFunction.



\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  SPACE & space key\\ \hline 
  ENTER & enter (return) key\\ \hline 
  TAB & \\ \hline 
  BACKSPACE & \\ \hline 
  RIGHT & cursor right\\ \hline 
  LEFT & cursor left\\ \hline 
  DOWN & cursor down\\ \hline 
  UP & cursor up\\ \hline 
  F1 & function key F1\\ \hline 
  F2 & function key F2\\ \hline 
  F3 & function key F3\\ \hline 
  F4 & function key F4\\ \hline 
  F5 & function key F5\\ \hline 
  F6 & function key F6\\ \hline 
  F7 & function key F7\\ \hline 
  F8 & function key F8\\ \hline 
  F9 & function key F9\\ \hline 
  F10 & function key F10\\ \hline 
\end{longtable}
\end{center}

%++++++++++++++++++++
\mysubsubsection{LinearSolverType}
This section shows the LinearSolverType structure, which is used for selecting linear solver types, which are dense or sparse solvers.



\begin{center}
\footnotesize
\begin{longtable}{| p{8cm} | p{8cm} |} 
\hline
{\bf function/structure name} & {\bf description}\\ \hline
  \_None & no value; used, e.g., if no solver is selected\\ \hline 
  EXUdense & use dense matrices and according solvers for densly populated matrices (usually the CPU time grows cubically with the number of unknowns)\\ \hline 
  EigenSparse & use sparse matrices and according solvers; additional overhead for very small systems; specifically, memory allocation is performed during a factorization process\\ \hline 
\end{longtable}
\end{center}
