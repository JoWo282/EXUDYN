/** ***********************************************************************************************
* @class        GlfwClientText
* @brief        Link to 2D Text drawing library
*
* @author       Gerstmayr Johannes
* @date         2019-05-24 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */
#ifndef GLFWCLIENTTEXT__H
#define GLFWCLIENTTEXT__H

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"

#ifdef USE_GLFW_GRAPHICS

#include <ostream>

#include <GLFW/glfw3.h>
//#include <stdlib.h> //only works in MSVC for initialization with std::vector
#include <array>
#include <vector>
#include <stdio.h>
#include <thread>

#include "Graphics/GraphicsData.h"
//#include "Graphics/GlfwClient.h"

#include "Autogenerated/VisualizationSettings.h"
#include "Graphics/VisualizationSystemContainerBase.h" //common interface to visualization system

#define OPENGLTEXT_EXISTS

namespace OpenGLText
{
	static const Index maxTextPoints = 12; //fixed maximum number of points for drawing text with lines

	typedef ConstSizeVector<2 * maxTextPoints> Vec;

	//get lines for character (0-9NOML) inside a 2 x 4 matrix (x/y) of 'lines' and the number of lines 'nLines'
	//(0,0) is located left bottom
	//broken signals, that lines are built out of pairwise vertices (broken lines possible)
	inline void GetCharacterLines(char c, ConstSizeVector<2 * maxTextPoints>& lines, bool& broken)
	{
		broken = false; //default
		if (c >= 'a' && c <= 'z') { c -= (char)32; }
		switch (c)
		{
		case '0': lines = Vec({ 0,0, 2,0, 2,4, 0,4, 0,0 }); break;
		case '1': lines = Vec({ 1.5,0, 1.5,4, 0.5,3 }); break;
		case '2': lines = Vec({ 0,4, 2,4, 2,2, 0,2, 0,0, 2,0 }); break;
		case '3': lines = Vec({ 0,4, 2,4, 2,2, 0,2, 2,2, 2,0, 0,0 }); break;
		case '4': lines = Vec({ 0,4, 0,2, 2,2, 2,4, 2,0 }); break;
		case '5': lines = Vec({ 2,4, 0,4, 0,2, 2,2, 2,1, 1,0, 0,0 }); break;
		case '6': lines = Vec({ 2,4, 0,4, 0,0, 2,0, 2,2, 0,2 }); break;
		case '7': lines = Vec({ 0,4, 2,4, 1,0 }); break;
		case '8': lines = Vec({ 0,2, 0,0, 2,0, 2,2, 0,2, 0,4, 2,4, 2,2 }); break;
		case '9': lines = Vec({ 2,2, 0,2, 0,4, 2,4, 2,0, 0,0 }); break;
		case 'A': lines = Vec({ 0,0, 1,4, 2,0, 1.5,2, 0.5,2 }); break;
		case 'B': lines = Vec({ 0,0, 0,4, 1.5,4, 2,3, 1.5,2, 0,2, 1.5,2, 2,1, 1.5,0, 0,0 }); break;
		case 'C': lines = Vec({ 2,4, 0.5,4, 0,3.5, 0,0.5, 0.5,0, 2,0 }); break;
		case 'D': lines = Vec({ 0,0, 0,4, 1.5,4, 2,3.5, 2,0.5, 1.5,0, 0,0 }); break;
		case 'E': lines = Vec({ 2,4, 0,4, 0,2, 2,2, 0,2, 0,0, 2,0 }); break;
		case 'F': lines = Vec({ 2,4, 0,4, 0,2, 1.5,2, 0,2, 0,0 }); break;
		case 'G': lines = Vec({ 2,4, 0.5,4, 0,3.5, 0,0.5, 0.5,0, 1.5,0, 2,0.5, 2,2, 1,2 }); break;
		case 'H': lines = Vec({ 0,0, 0,4, 0,2, 2,2, 2,4, 2,0 }); break;
		case 'I': lines = Vec({ 2,4, 0,4, 1,4, 1,0, 0,0, 2,0 }); break;
		case 'J': lines = Vec({ 0,4, 1,4, 1,0, 0.5,0, 0,0.5 }); break;
		case 'K': lines = Vec({ 0,0, 0,4, 0,2, 2,4, 0,2, 2,0 }); break;
		case 'L': lines = Vec({ 0,4, 0,0, 2,0 }); break;
		case 'M': lines = Vec({ 0,0, 0,4, 1,2, 2,4, 2,0 }); break;
		case 'N': lines = Vec({ 0,0, 0,4, 2,0, 2,4 }); break;
		case 'O': lines = Vec({ 0,3.5, 0,0.5, 0.5,0, 1.5,0, 2,0.5, 2,3.5, 1.5,4, 0.5,4, 0,3.5 }); break;
		case 'P': lines = Vec({ 0,0, 0,4, 1.5,4, 2,3.5, 2,2.5, 1.5,2, 0,2 }); break;
		case 'Q': lines = Vec({ 0,3.5, 0,0.5, 1.5,0, 1.75,0.25, 1.5,0.5, 2,0, 1.75,0.25, 2,0.5, 2,3.5, 1.5,4, 0.5,4, 0,3.5 }); break;
		case 'R': lines = Vec({ 0,0, 0,4, 1.5,4, 2,3.5, 2,2.5, 1.5,2, 0,2, 2,0 }); break;
		case 'S': lines = Vec({ 2,4, 1,4, 0,3, 2,1, 1,0, 0,0 }); break;
		case 'T': lines = Vec({ 0,4, 2,4, 1,4, 1,0 }); break;
		case 'U': lines = Vec({ 0,4, 0,0.5, 0.5,0, 1.5,0, 2,0.5, 2,4 }); break;
		case 'V': lines = Vec({ 0,4, 1,0, 2,4 }); break;
		case 'W': lines = Vec({ 0,4, 0,0, 1,2, 2,0, 2,4 }); break;
		case 'X': lines = Vec({ 0,4, 2,0, 1,2, 2,4, 0,0 }); break;
		case 'Y': lines = Vec({ 0,4, 1,2, 2,4, 1,2, 1,0 }); break;
		case 'Z': lines = Vec({ 0,4, 2,4, 0,0, 2,0 }); break;
		case '\'':lines = Vec({ 1,4, 1,3 }); break;
		case '/': lines = Vec({ 0.5,0, 1.5,4 }); break;
		case '*': lines = Vec({ 0.,1., 2,3, 1,2, 0.,3, 2,1, 1,2, 1,3, 1,1 }); break;
		case '+': lines = Vec({ 1,1., 1,3, 1,2, 0.,2, 2,2 }); break;
		case '-': lines = Vec({ 0,2, 2,2 }); break;
		case ',': lines = Vec({ 1,1, 1,0.5, 0.5,0 }); break;
		case '.': lines = Vec({ 0.9,0, 1.1,0, 1.1,0.2, 0.9,0.2, 0.9,0 }); break;
		case '(': lines = Vec({ 1.5,4, 1,3.5, 1,0.5, 1.5,0 }); break;
		case ')': lines = Vec({ 1,4, 1.5,3.5, 1.5,0.5, 1,0 }); break;
		case ' ': lines = Vec(0); break;
		case '=': lines = Vec({ 0,2.5, 2,2.5,  0,1.5, 2,1.5, }); broken = true;  break;
		case ':': lines = Vec({ 0.8,0, 1.2,0,  0.8,3, 1.2,3 }); broken = true; break;
		case '!': lines = Vec({ 1,0, 1,0.4,  1,0.8, 1,4 }); broken = true; break;
		default:
			lines = Vec({ 0,0, 2,0, 2,4, 0,4, 0,0, 2,4, 0,4, 2,0 }); //default crossed 'XO' character
		}
	}

	//! draw a 0-terminated text string with scaling (size=1: height=1; width=0.5 for one character; distance = 0.2)
	inline void DrawString(const char* text, float scale, const Float3& p, const Float4& color)
	{
		ConstSizeVector<2 * maxTextPoints> lines;

		Index i = 0;
		float x, y;
		Index lineNumber = 0; //for several lines of text
		Index columnNumber = 0;
		bool broken = false;
		while (text[i] != (char)0)
		{
			if (text[i] != '\n') 
			{
				GetCharacterLines(text[i], lines, broken); //broken flag shows, that lines are single pairwise lines

				if (!broken) { 
					glBegin(GL_LINE_STRIP); 				
					glColor4f(color[0], color[1], color[2], color[3]);
				}
				//glLineWidth(1.f);

				//std::cout << "  lines=" << lines << "\n";
				for (Index j = 0; j < lines.NumberOfItems() / 2; j++)
				{
					if (broken && j % 2 == 0) { glBegin(GL_LINE_STRIP); glColor4f(color[0], color[1], color[2], color[3]); }
					x = scale * 0.25f*(float)lines[j * 2] + (float)columnNumber*0.7f*scale; //line points are scaled by 1/4 in order to get nominal height = 1
					y = scale * 0.25f*(float)lines[j * 2 + 1] - (float)lineNumber*1.4f*scale;
					glVertex3f(p[0] + x, p[1] + y, p[2]);
					if (broken && j % 2 == 1) { glEnd(); } //only works if even number of vertices
				}
				if (!broken) { glEnd(); } //GL_LINE_STRIP
				columnNumber++;
			}
			else { lineNumber++; columnNumber = 0; }

			i++;
		}

	}


}

#endif //USE_GLFW_GRAPHICS
#endif //include once
