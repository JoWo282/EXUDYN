/** ***********************************************************************************************
* @class        GlfwClient
* @brief        Hub to glfw class for 3D visualization using OpenGL
*
* @author       Gerstmayr Johannes
* @date         2019-05-24 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */
#ifndef GLFWCLIENT__H
#define GLFWCLIENT__H

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"

#include <ostream>
//#include <stdlib.h> //only works in MSVC for initialization with std::vector
#include <array>
#include <vector>
#include <stdio.h>
#include <thread>

#include "Graphics/GraphicsData.h"
#include "Autogenerated/VisualizationSettings.h"
#include "Graphics/VisualizationSystemContainerBase.h" //common interface to visualization system


#ifdef USE_GLFW_GRAPHICS

//#define GLFW_INCLUDE_ES3 //open gl ES version
#define GLFW_INCLUDE_GLEXT
//#define GL_GLEXT_PROTOTYPES OpenGL3.2
#include <GLFW/glfw3.h>

#define USE_TEXTURED_BITMAP_FONTS //!< activate this flag for faster textured based fonts with glLists

#include "Graphics/GlfwClientText.h" //link to external library; include only if copyright is appropriate
#include "Graphics/GlfwClientBitmapText.h"


enum class RendererMode {
	_None, Move, Rotate, ZoomView, Select
};

//! size for bitmap fonts
enum class FontSizeType {
	small = 1,		//small text, e.g., for contour numbers
	normal = 2,		//regular text
	large = 4,		//large text
	userText = 8,	//size of user texts
};



//! variables that describe the renderer's state machine ==> zoom, move, etc. with mouse
class RenderStateMachine
{
public:
	bool leftMousePressed;
	bool rightMousePressed;
	bool shiftPressed;
	bool ctrlPressed;
	RendererMode mode;			//!< determines the state of any action

	double mousePositionX;		//!< currently recorded mouse position; use double for GLFW compatibility
	double mousePositionY;		//!< currently recorded mouse position; use double for GLFW compatibility
	double lastMousePressedX;	//!< last mouse button position pressed
	double lastMousePressedY;	//!< last mouse button position pressed

	float storedCenterPointX;	//!< stored centerpoint position during mouse-move
	float storedCenterPointY;	//!< stored centerpoint position during mouse-move

	Float16 storedModelRotation;//!< stored rotation matrix before right mouse button pressed
};


//! this is the rendering module for displaying 3D model data
class GlfwRenderer
{
private:
	//static RenderState state;
	static bool rendererActive;			//!< signal that shows that renderer is active
	static bool stopRenderer;			//!< signal that shows that renderer should quit
	static GLFWwindow* window;
	static RenderState* state;		//!< this represents the current OpenGL parameters
	static RenderStateMachine stateMachine; //!< all variables (mouse, keyboard, ...) used for state machine (zoom, zoom-view, move, ...)
	static std::thread rendererThread;	//!< std::thread variable for rendererThread
	static Index rendererError;			//!< 0 ... no error, 1 ... glfwInit() failed, 2 ... glfwCreateWindow failed, 3 ... other error
	static Index firstRun; //zoom all in first run
	static std::atomic_flag renderFunctionRunning;  //!< semaphore to check if Render(...)  function is currently running (prevent from calling twice)

	//+++++++++++++++++++++++++++++++++++++++++
	static BitmapFont bitmapFont;				//!< bitmap font for regular texts and for textured fonts, initialized upon start of renderer
	static float fontScale;						//!< monitor scaling factor from windows, to scale fonts
	static constexpr float fontSmallFactor = 0.7500001f; //!< factor for small fonts
	static constexpr float fontLargeFactor = 1.400001f;  //!< factor for large fonts
	static constexpr float fontHugeFactor = 2.500001f;  //!< factor for large fonts
#ifndef USE_TEXTURED_BITMAP_FONTS
	static BitmapFont bitmapFontSmall;			//!< bitmap font for small texts, initialized upon start of renderer
	static BitmapFont bitmapFontLarge;			//!< bitmap font for large texts, initialized upon start of renderer
	static BitmapFont bitmapFontHuge;			//!< bitmap font for huge texts, initialized upon start of renderer
#else
	//+++ for textures with glLists +++:
	static GLuint textureNumberRGBbitmap[256];	//!< store texture numbers for every character of bitmap font
	static GLuint bitmapFontListBase;			//!< starting index for GLlists for font bitmap textured quads
	static ResizableArray<GLubyte> charBuffer;	//!< buffer for converstion of UTF8 into internal unicode-like format
#endif
	//+++++++++++++++++++++++++++++++++++++++++
	//link to GraphicsData and Settings:
	static ResizableArray<GraphicsData*>* graphicsDataList;					//!< link to graphics data; only works for one MainSystem, but could also be realized for several systems
	static VisualizationSettings* visSettings;  //!< link to visualization settings
	static VisualizationSystemContainerBase* basicVisualizationSystemContainer;
	//+++++++++++++++++++++++++++++++++++++++++

public:
	GlfwRenderer();
	~GlfwRenderer() 
	{	
		//glfwTerminate(); //move to destructor
	};

	//! Initializes and starts the Renderer in a separate thread;
	//  Returns false, if problems with glfw library or windows creation, otherwise true; 
	//  @todo test with apple and linux
	static bool SetupRenderer(bool verbose = false);

	//! stop the renderer engine and its thread; @todo StopRenderer currently also stops also main thread (python)
	static void StopRenderer();

	//! return renderState object
	static RenderState GetRenderState() { return *state; }

	static bool WindowIsInitialized()
	{
		if (window && rendererActive) { return true; }
		else { return false; }
	}

	//! Links the Renderer to a specific GraphicsData/settings; 
	//! Only one data linked at one time
	//! Returns true on success and false, if data is already linked (==> call DetachVisualizationSystem first)
	static bool LinkVisualizationSystem(ResizableArray<GraphicsData*>* graphicsDataListInit, VisualizationSettings* settingsInit,
										VisualizationSystemContainerBase* basicVisualizationSystemContainerInit, RenderState* renderStateInit)
	{
		if (graphicsDataList == nullptr)
		{
			graphicsDataList = graphicsDataListInit;
			visSettings = settingsInit;
			basicVisualizationSystemContainer = basicVisualizationSystemContainerInit;
			state = renderStateInit;
			//now state can be initialized:
			state->mouseCoordinates = Vector2D({ 0.,0. });
			state->openGLcoordinates = Vector2D({ 0.,0. });
			state->mouseLeftPressed = false;
			state->mouseRightPressed = false;
			state->mouseMiddlePressed = false;

			return true;
		}
		else { return false; }
	}

	//! Detach the GraphicsData/settings; enables the visualization of different MainSystems; return true on success
	static bool DetachVisualizationSystem()
	{
		StopRenderer();

		if (graphicsDataList == nullptr) { return false; }//this just shows that no system was linked yet
		else 
		{ 
			graphicsDataList = nullptr;
			visSettings = nullptr;

			window = nullptr; //is set in StopRenderer anyway
			state = nullptr;
			basicVisualizationSystemContainer = nullptr;

			return true;
		}
	}

	static void UpdateGraphicsDataNow()
	{
		if (basicVisualizationSystemContainer)
		{
			basicVisualizationSystemContainer->UpdateGraphicsDataNow();
		}
	}

private: //to be called internally only!
	static void error_callback(int error, const char* description)
	{
		std::cout << description << "\n";
	}

	//static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
	static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods);
	static void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);
	static void mouse_button_callback(GLFWwindow* window, int button, int action, int mods);
	static void cursor_position_callback(GLFWwindow* window, double xpos, double ypos);
	static void window_close_callback(GLFWwindow* window)
	{
		//StopRenderer();
		//rendererActive = false;
		//basicVisualizationSystemContainer->StopSimulation(); //if user waits for termination of render engine, it tells that window is closed
		//stopRenderer = false;	//if stopped by user

		glfwSetWindowShouldClose(window, GLFW_FALSE); //do not close ....
		pout << "\n+++++++++++++++++++++\npress ESC or Q to close window!\n+++++++++++++++++++++\n";

	}

	//! GlfwInit and glfw->CreateWindow() calls; returns false, if functions fail
	static void InitCreateWindow();

	//! loop which checks for keyboard/mouse input; check for visualization updates (new data, window size changed, zoom, mouse move, etc.) and calls Render()
	static void RunLoop();

	//! Render function called for every update of OpenGl window
	static void Render(GLFWwindow* window); //GLFWwindow* needed in argument, because of glfwSetWindowRefreshCallback

	//! check if frame shall be grabed and saved to file using visualization options
	static void SaveImage();

	//! save scene to a file with filename
	static void SaveSceneToFile(const STDstring& filename);
	
	//! Render particulalry the graphics data of multibody system
	static void RenderGraphicsData(float fontScale);

	//! Zoom all graphics objects (for current configuration)
	static void ZoomAll();

	//! Set all light functions for openGL
	static void SetGLLights();

	//!transform pixel coordinates (from bottom/left) into vertex coordinates
	//!works if model view is initialized with 	glMatrixMode(GL_MODELVIEW);glLoadIdentity();
	static Float2 PixelToVertexCoordinates(float x, float y);

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//FONTS
	//! initialize bitmap for bitmap font (loaded from characterBitmap.h
	static void InitFontBitmap(guint fontSize);// , guint fontSizeSmall, guint fontSizeLarge, guint fontSizeHuge);

	//! draw a 0-terminated text string with fontSize, including monitor scaling factor; (for line-characters: size=1: height=1; width=0.5 for one character; distance = 0.25)
	//! switches to strings drawn by textures (default) or lines
	static void DrawString(const char* text, float fontSizeScaled, const Float3& p, const Float4& color);

	//! draw string with scalable bitmap fonts, using textures
	static void DrawStringWithTextures(const char* text, float fontSizeScaled, const Float3& p, const Float4& color,
		BitmapFont& font, ResizableArray<GLubyte>& charBuffer, GLuint listBase);

	//! create glTexImage2D objects for font characters, stored in textureNumberRGBbitmap
	static void CreateFontTextures();

	//! create glLists for texture with textureNumber
	static void CreateTexturedQuadsLists(GLuint& listBase, GLuint* textureNumber,
		guint nCharacters, guint wCharacter8, guint wCharacter, guint hCharacter, bool itemTags = false);

	//draw string with GLlists, previously created by CreateTexturedQuadsLists
	static void DrawStringWithGLlistTextures(const Float3& p, float fontSizeScaled, GLuint listBase, GLubyte *string, guint stringLen);

	//! OpenGL testing functions for destructor
	static void DeleteFonts();
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

};

extern GlfwRenderer glfwRenderer; //this is the (static) location of the renderer class; could also be made dynamic



#endif //USE_GLFW_GRAPHICS
#endif //include once
