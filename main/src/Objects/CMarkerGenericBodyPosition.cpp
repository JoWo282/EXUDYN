/** ***********************************************************************************************
* @brief        implementation for MarkerGenericBodyPosition
*
* @author       Gerstmayr Johannes
* @date         2019-05-02 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Utilities/RigidBodyMath.h"

#include <pybind11/pybind11.h>      //! AUTO: include pybind for dictionary access
#include <pybind11/stl.h>           //! AUTO: needed for stl-casts; otherwise py::cast with std::vector<Real> crashes!!!
namespace py = pybind11;            //! AUTO: "py" used throughout in code
#include "Autogenerated/CMarkerGenericBodyPosition.h"
#include "Autogenerated/CObjectGenericODE2.h"

//for consistency checks:
#include "Main/MainSystem.h"
#include "Pymodules/PybindUtilities.h"
#include "Autogenerated/MainMarkerGenericBodyPosition.h"

bool MainMarkerGenericBodyPosition::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	const CMarkerGenericBodyPosition* cMarker = GetCMarkerGenericBodyPosition();
	const ArrayIndex& nodeNumbers = cMarker->GetParameters().nodeNumbers;

	//valid object number has been already checked in CSystem::CheckSystemIntegrity
	Index bodyNumber = cMarker->GetObjectNumber();
	const CObject* cObject = mainSystem.GetMainSystemData().GetMainObjects()[bodyNumber]->GetCObject();

	if (((Index)cObject->GetType() & (Index)CObjectType::Body) == 0)
	{
		errorString = "MarkerGenericBodyPosition: can only be applied to an object of type body";
		return false;
	}

	const CObjectBody* cBody = (CObjectBody*)cObject;

	//there must be at least one node
	if (nodeNumbers.NumberOfItems() == 0)
	{
		errorString = "MarkerGenericBodyPosition: number of nodes must be larger than zero";
		return false;
	}

	//weighting factors and number of nodes must be equal
	if (cMarker->GetParameters().weightingFactors.NumberOfItems() != nodeNumbers.NumberOfItems())
	{
		errorString = "MarkerGenericBodyPosition: number of nodes (" + EXUstd::ToString(nodeNumbers.NumberOfItems()) 
			+ ") and number of weighting factors (" + EXUstd::ToString(cMarker->GetParameters().weightingFactors.NumberOfItems()) + ") must be same";
		return false;
	}

	Index nn = cBody->GetNumberOfNodes();
	for (Index i : nodeNumbers)
	{
		if (i >= nn)
		{
			errorString = "MarkerGenericBodyPosition: local node index " + EXUstd::ToString(i) + 
				" is larger than the number of nodes in the generic body " + mainSystem.GetMainSystemData().GetMainObjects()[bodyNumber]->GetName() +
				" (number of nodes = " + EXUstd::ToString(nn) + ")";
			return false;
		}

		CNode* cNode = mainSystem.GetMainSystemData().GetMainNode(cBody->GetNodeNumber(i)).GetCNode();
		if ((cNode->GetType() & Node::Position) == 0)
		{
			errorString = "MarkerGenericBodyPosition: local node index " + EXUstd::ToString(i) + " must be of node type 'Position'";
			return false;

		}

	}

	//in case of reference frame, the first node of the body must contain rigid body orientation
	if (cMarker->GetParameters().useFirstNodeAsReferenceFrame)
	{
		////Jacobian for useFirstNodeAsReferenceFrame not implemented!
		//errorString = "MarkerGenericBodyPosition: Case useFirstNodeAsReferenceFrame = True not implemented yet!";
		//return false;

		CNode* cNode = mainSystem.GetMainSystemData().GetMainNode(cBody->GetNodeNumber(CObjectGenericODE2::ffrfNodeNumber)).GetCNode();
		if ((cNode->GetType() & (Node::RigidBody)) == 0)
		{
			errorString = "MarkerGenericBodyPosition: because of the flag 'useFirstNodeAsReferenceFrame=True', node number 0 in generic body " + 
				mainSystem.GetMainSystemData().GetMainObjects()[bodyNumber]->GetName() + " must be of node type 'RigidBody'";
			return false;

		}
	}
	return true;
}

void CMarkerGenericBodyPosition::GetPosition(const CSystemData& cSystemData, Vector3D& position, ConfigurationType configuration) const
{
	const ArrayIndex& nodeNumbers = parameters.nodeNumbers;
	const CObject& cObject = cSystemData.GetCObjectBody(GetObjectNumber());

	position.SetAll(0);
	for (Index i = 0; i < nodeNumbers.NumberOfItems(); i++)
	{
		position += parameters.weightingFactors[i] * ((const CNodeODE2&)cSystemData.GetCNode(cObject.GetNodeNumber(nodeNumbers[i]))).GetPosition(configuration);
	}
	if (parameters.useFirstNodeAsReferenceFrame)
	{
		//transform position from local into global coordinates:
		// pGlobal = pRef + A * pLoc
		position = ((const CNodeRigidBody&)cSystemData.GetCNode(cObject.GetNodeNumber(CObjectGenericODE2::ffrfNodeNumber))).GetRotationMatrix(configuration) * position;
		position += ((const CNodeRigidBody&)cSystemData.GetCNode(cObject.GetNodeNumber(CObjectGenericODE2::ffrfNodeNumber))).GetPosition(configuration);
	}
}

void CMarkerGenericBodyPosition::GetVelocity(const CSystemData& cSystemData, Vector3D& velocity, ConfigurationType configuration) const
{
	const ArrayIndex& nodeNumbers = parameters.nodeNumbers;
	const CObject& cObject = cSystemData.GetCObjectBody(GetObjectNumber());

	velocity.SetAll(0);
	for (Index i = 0; i < nodeNumbers.NumberOfItems(); i++)
	{
		velocity += parameters.weightingFactors[i] * ((const CNodeODE2&)cSystemData.GetCNode(cObject.GetNodeNumber(nodeNumbers[i]))).GetVelocity(configuration);
	}

	if (parameters.useFirstNodeAsReferenceFrame)
	{
		Vector3D position;
		GetPosition(cSystemData, position, configuration);

		const CNodeODE2& cNode = (const CNodeODE2&)cSystemData.GetCNode(cObject.GetNodeNumber(CObjectGenericODE2::ffrfNodeNumber));
		//transform position from local into global coordinates:
		// vGlobal = vRef + A * (vLoc + \localOmega x pLoc)
		velocity = cNode.GetRotationMatrix(configuration) * (velocity + cNode.GetAngularVelocityLocal(configuration).CrossProduct(position));
		velocity += cNode.GetVelocity(configuration);
		
	}
}

void CMarkerGenericBodyPosition::ComputeMarkerData(const CSystemData& cSystemData, bool computeJacobian, MarkerData& markerData) const
{
	GetPosition(cSystemData, markerData.position, ConfigurationType::Current);
	GetVelocity(cSystemData, markerData.velocity, ConfigurationType::Current);
	markerData.velocityAvailable = true;

	if (computeJacobian)
	{
		const ArrayIndex& nodeNumbers = parameters.nodeNumbers;
		const CObjectBody& cObject = cSystemData.GetCObjectBody(GetObjectNumber());

		//if (((Index)cObject.GetType() & (Index)CObjectType::MultiNoded) == 0)
		//{
		//	CHECKandTHROWstring("CMarkerGenericBodyPosition::ComputeMarkerData: only available for MultiNoded objects");
		//}
		//const CObjectGenericODE2& cGenericODE2 = (const CObjectGenericODE2&)cObject; //may fail, better implement GetCoordinateIndexPerNode for NodeODE2

		markerData.positionJacobian.SetNumberOfRowsAndColumns(3, cObject.GetODE2Size());
		markerData.positionJacobian.SetAll(0.);

		Matrix3D A;
		if (parameters.useFirstNodeAsReferenceFrame)
		{
			const CNodeRigidBody& cNode = (const CNodeRigidBody&)cSystemData.GetCNode(cObject.GetNodeNumber(CObjectGenericODE2::ffrfNodeNumber));
			A = cNode.GetRotationMatrix();
		}

		//Index cOffset = 0; //coordinates offset
		for (Index i = 0; i < nodeNumbers.NumberOfItems(); i++)
		{
			Index iNode = nodeNumbers[i];
			//use temporary jacobian structure, to get node jacobian
			((const CNodeODE2*)cObject.GetCNode(iNode))->GetPositionJacobian(markerData.jacobian);
			markerData.jacobian *= parameters.weightingFactors[i];

			if (parameters.useFirstNodeAsReferenceFrame)
			{
				//apply rotation matrix columnwise:
				EXUmath::ApplyTransformation<3>(A, markerData.jacobian); //size=3: always 3D
			}

			Index offset = cObject.GetLocalODE2CoordinateIndexPerNode(iNode);
			//pout << "offset" << i << "=" << offset << "\n";
			markerData.positionJacobian.SetSubmatrix(markerData.jacobian, 0, offset);

			//for (Index j = 0; j < 3; j++) //position jacobian has always 3 rows
			//{
			//	for (Index k = 0; k < markerData.jacobian.NumberOfColumns(); k++)
			//	{
			//		markerData.positionJacobian(j, k + offset) = markerData.jacobian(j, k);
			//	}
			//}
		}
		//pout << "posJac=" << markerData.positionJacobian << "\n";

		if (parameters.useFirstNodeAsReferenceFrame)
		{
			//\partial vMarker / \partial q_t = [I, -A * pLocalTilde * Glocal, A*(w0*nodeJac0, w1*nodeJac1, ...)]

			Vector3D localPosition({ 0,0,0 });
			for (Index i = 0; i < nodeNumbers.NumberOfItems(); i++)
			{
				localPosition += parameters.weightingFactors[i] * ((const CNodeODE2&)cSystemData.GetCNode(cObject.GetNodeNumber(nodeNumbers[i]))).GetPosition();
			}

			const CNodeRigidBody& cNode = (const CNodeRigidBody&)cSystemData.GetCNode(cObject.GetNodeNumber(CObjectGenericODE2::ffrfNodeNumber));
			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::nDim3D> Glocal;
			
			//compute: -A*pLocalTilde*GLocal
			cNode.GetGlocal(Glocal);
			EXUmath::ApplyTransformation<3>(RigidBodyMath::Vector2SkewMatrixTemplate(-localPosition), Glocal);
			EXUmath::ApplyTransformation<3>(A, Glocal);

			//now compute remaining jacobian terms for reference frame motion:
			ConstSizeMatrix<CNodeRigidBody::nDim3D * (CNodeRigidBody::maxDisplacementCoordinates + CNodeRigidBody::maxRotationCoordinates)> posJac0;
			((const CNodeODE2*)cObject.GetCNode(CObjectGenericODE2::ffrfNodeNumber))->GetPositionJacobian(posJac0);
			//markerData.positionJacobian.SetSubmatrix(EXUmath::unitMatrix3D, 0, 0); //would be faster, but less general
			markerData.positionJacobian.SetSubmatrix(posJac0, 0, 0);

			markerData.positionJacobian.SetSubmatrix(Glocal, 0, CNodeRigidBody::maxDisplacementCoordinates);
		}
	}
}

