/** ***********************************************************************************************
* @brief        CObjectRotationalMass1D implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectRotationalMass1D.h"
#include "Utilities/RigidBodyMath.h"


//! Computational function: compute mass matrix
void CObjectRotationalMass1D::ComputeMassMatrix(Matrix& massMatrix) const
{
	massMatrix.SetScalarMatrix(1, parameters.physicsInertia);
}

//! Computational function: compute right-hand-side (RHS) of second order ordinary differential equations (ODE) to "ode2rhs"
void CObjectRotationalMass1D::ComputeODE2RHS(Vector& ode2Rhs) const
{
	ode2Rhs.SetNumberOfItems(1);
	ode2Rhs.SetAll(0.);
}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectRotationalMass1D::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::AngularVelocity_qt);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectRotationalMass1D::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt:
	{
		value.SetMatrix(3, 1, { 0.,0.,0. }); //a ForceVector has no action on RotationalMass1D
		break;
	}
	case AccessFunctionType::AngularVelocity_qt:
	{
		//this function relates a 3D angular velocity to the time derivative of all coordinates: omega = Jac*q_dot
		Vector3D v = parameters.referenceRotation * Vector3D({ 0.,0.,1. }); //local angular velocity is around z-axis!
		value.SetMatrix(3, 1, {v[0], v[1], v[2]}); //the 3D torque vector (only z-component) acts on the 3rd coordinate phi_t
		break;
	}
	//case AccessFunctionType::DisplacementMassIntegral_q:
	//{
	//	value.SetMatrix(3, 1, { 0.,0.,0. }); //no action of gravity!
	//	break;
	//}
	default:
		SysError("CObjectRotationalMass1D:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectRotationalMass1D::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(localPosition, configuration)); break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	case OutputVariableType::Rotation: value.CopyFrom(Vector1D( GetRotationAngle(configuration))); break;
	case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	case OutputVariableType::RotationMatrix: {
		Matrix3D rot = GetRotationMatrix(localPosition, configuration);
		value.SetVector(rot.NumberOfColumns()*rot.NumberOfRows(), rot.GetDataPointer()); 
		break;
	}
	default:
		SysError("CObjectRotationalMass1D::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//! return the rotation angle (reference+current) according to configuration type
Real CObjectRotationalMass1D::GetRotationAngle(ConfigurationType configuration) const
{
	Real phiRef = ((CNodeODE2*)GetCNode(0))->GetReferenceCoordinateVector()[0];
	if (configuration == ConfigurationType::Reference) { return phiRef; }
	return phiRef + ((CNodeODE2*)GetCNode(0))->GetCoordinateVector(configuration)[0];
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRotationalMass1D::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return GetRotationMatrix(localPosition, configuration) * localPosition + parameters.referencePosition;
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRotationalMass1D::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return GetRotationMatrix(localPosition, configuration) * GetAngularVelocityLocal(localPosition, configuration).CrossProduct(localPosition); //add omega x r
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRotationalMass1D::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return GetPosition(localPosition,configuration) - GetPosition(localPosition, ConfigurationType::Reference); //this also works for NodePointGround
}

Matrix3D CObjectRotationalMass1D::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real phi = GetRotationAngle(configuration);
	return parameters.referenceRotation * RigidBodyMath::RotationMatrix3(phi); //rotation around local z-axis
}

//! return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CObjectRotationalMass1D::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real omega = ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration)[0];
	return parameters.referenceRotation * Vector3D({ 0.,0.,omega }); //rotation around local z-axis
}

//! return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CObjectRotationalMass1D::GetAngularVelocityLocal(const Vector3D& localPosition, ConfigurationType configuration) const
{
	Real omega = ((CNodeODE2*)GetCNode(0))->GetCoordinateVector_t(configuration)[0];
	return Vector3D({ 0.,0.,omega });//rotation around local z-axis
}

