/** ***********************************************************************************************
* @brief        Implementation for VisualizationNodePoint
*
* @author       Gerstmayr Johannes
* @date         2018-04-18 (generated)
* @date         2019-05-27 (last modfied)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */
#pragma once

#include <ostream>
//#include <array>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h" //includes stdoutput.h
#include "Utilities/BasicFunctions.h"	//includes stdoutput.h


#include "Linalg/BasicLinalg.h"		//includes Vector.h

//#include "Main/MainSystem.h"

#include "Graphics/VisualizationSystemContainer.h"
#include "Graphics/VisualizationPrimitives.h"
//#include "Pymodules/PybindUtilities.h"


#include "Autogenerated/VisuNodePoint.h"
#include "Autogenerated/VisuNodePointGround.h"
#include "Autogenerated/VisuNodePoint2D.h"
#include "Autogenerated/VisuNodeRigidBodyEP.h"
#include "Autogenerated/VisuNodeRigidBodyRxyz.h"
#include "Autogenerated/VisuNodeRigidBodyRotVecLG.h"
#include "Autogenerated/VisuNodeRigidBody2D.h"
#include "Autogenerated/VisuNodePoint2DSlope1.h"

#include "Autogenerated/VisuObjectMassPoint.h"
#include "Autogenerated/VisuObjectMassPoint2D.h"
#include "Autogenerated/VisuObjectMass1D.h"
#include "Autogenerated/VisuObjectRotationalMass1D.h"
#include "Autogenerated/VisuObjectRigidBody.h"
#include "Autogenerated/VisuObjectRigidBody2D.h"
#include "Autogenerated/VisuObjectGenericODE2.h"
#include "Autogenerated/VisuObjectFFRF.h"
#include "Autogenerated/VisuObjectGround.h"

#include "Autogenerated/VisuObjectANCFCable2D.h"
#include "Autogenerated/VisuObjectALEANCFCable2D.h"

#include "Autogenerated/VisuObjectConnectorSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorRigidBodySpringDamper.h"
#include "Autogenerated/VisuObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorDistance.h"
#include "Autogenerated/VisuObjectConnectorCoordinate.h"
#include "Autogenerated/VisuObjectConnectorRollingDiscPenalty.h"
#include "Autogenerated/VisuObjectContactCoordinate.h"
#include "Autogenerated/VisuObjectContactCircleCable2D.h"
#include "Autogenerated/VisuObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/VisuObjectJointGeneric.h"
#include "Autogenerated/VisuObjectJointSpherical.h"
#include "Autogenerated/VisuObjectJointRollingDisc.h"
#include "Autogenerated/VisuObjectJointRevolute2D.h"
#include "Autogenerated/VisuObjectJointPrismatic2D.h"
#include "Autogenerated/VisuObjectJointSliding2D.h"
#include "Autogenerated/VisuObjectJointALEMoving2D.h"

#include "Autogenerated/VisuMarkerBodyPosition.h"
#include "Autogenerated/VisuMarkerBodyRigid.h"
#include "Autogenerated/VisuMarkerBodyMass.h"
#include "Autogenerated/VisuMarkerNodePosition.h"
#include "Autogenerated/VisuMarkerNodeRigid.h"
//delete: #include "Autogenerated/VisuMarkerGenericBodyPosition.h"
#include "Autogenerated/VisuMarkerSuperElementPosition.h"
#include "Autogenerated/VisuMarkerSuperElementRigid.h"
#include "Autogenerated/VisuMarkerBodyCable2DShape.h"
#include "Autogenerated/VisuMarkerBodyCable2DCoordinates.h"

#include "Autogenerated/VisuLoadForceVector.h"
#include "Autogenerated/VisuLoadTorqueVector.h"
#include "Autogenerated/VisuLoadMassProportional.h"

#include "Autogenerated/VisuSensorNode.h"
#include "Autogenerated/VisuSensorObject.h"
#include "Autogenerated/VisuSensorBody.h"
#include "Autogenerated/VisuSensorSuperElement.h"

//++++++++++++++++++++++++++
//should not be needed, appropriate functions added to visualization objects
#include "Autogenerated/CNodePoint.h"
#include "Autogenerated/CNodePointGround.h"
#include "Autogenerated/CNodePoint2D.h"
#include "Autogenerated/CNodeRigidBodyEP.h"
#include "Autogenerated/CNodeRigidBodyRxyz.h"
#include "Autogenerated/CNodeRigidBodyRotVecLG.h"
#include "Autogenerated/CNodeRigidBody2D.h"
#include "Autogenerated/CNodePoint2DSlope1.h"

#include "Autogenerated/CObjectMassPoint.h"
#include "Autogenerated/CObjectMassPoint2D.h"
#include "Autogenerated/CObjectMass1D.h"
#include "Autogenerated/CObjectRotationalMass1D.h"
#include "Autogenerated/CObjectRigidBody.h"
#include "Autogenerated/CObjectRigidBody2D.h"
#include "Autogenerated/CObjectGenericODE2.h"
#include "Autogenerated/CObjectFFRF.h"
#include "Autogenerated/CObjectGround.h"

#include "Autogenerated/CObjectANCFCable2D.h"
#include "Autogenerated/CObjectALEANCFCable2D.h"

#include "Autogenerated/CObjectConnectorSpringDamper.h"
#include "Autogenerated/CObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/CObjectConnectorRigidBodySpringDamper.h"
#include "Autogenerated/CObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/CObjectConnectorDistance.h"
#include "Autogenerated/CObjectConnectorCoordinate.h"
#include "Autogenerated/CObjectConnectorRollingDiscPenalty.h"
#include "Autogenerated/CObjectContactCoordinate.h"
#include "Autogenerated/CObjectContactCircleCable2D.h"
#include "Autogenerated/CObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/CObjectJointGeneric.h"
#include "Autogenerated/CObjectJointSpherical.h"
#include "Autogenerated/CObjectJointRollingDisc.h"
#include "Autogenerated/CObjectJointRevolute2D.h"
#include "Autogenerated/CObjectJointPrismatic2D.h"
#include "Autogenerated/CObjectJointSliding2D.h"
#include "Autogenerated/CObjectJointALEMoving2D.h"

#include "Autogenerated/CMarkerBodyPosition.h"
#include "Autogenerated/CMarkerBodyRigid.h"
#include "Autogenerated/CMarkerBodyMass.h"
#include "Autogenerated/CMarkerNodePosition.h"
#include "Autogenerated/CMarkerNodeRigid.h"
#include "Autogenerated/CMarkerSuperElementPosition.h"
#include "Autogenerated/CMarkerSuperElementRigid.h"
#include "Autogenerated/CMarkerBodyCable2DShape.h"
#include "Autogenerated/CMarkerBodyCable2DCoordinates.h"

#include "Autogenerated/CLoadForceVector.h"
#include "Autogenerated/CLoadTorqueVector.h"
#include "Autogenerated/CLoadMassProportional.h"

//#include "Autogenerated/CSensorNode.h" //unused
#include "Autogenerated/CSensorObject.h"
#include "Autogenerated/CSensorBody.h"
#include "Autogenerated/CSensorSuperElement.h"

#include <pybind11/stl.h> 
#include <pybind11/stl_bind.h>
#include <pybind11/numpy.h> //accept numpy arrays: numpy array automatically converted to std::vector<Real,...> ==> accepts np.array([1,0,0]) and [1,0,0] as return value!

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint* cNode = (CNodePoint*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }


	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 3 coordinates per node ...
		ConstSizeVector<maxSize> value; //cable elements have no more than 9 cooordinates ...
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	//Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.general.sphereTiling : visualizationSettings.general.circleTiling;
	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 4 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", visualizationSettings.nodes.defaultColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePointGround::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePointGround* cNode = (CNodePointGround*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 3 coordinates per node ...
		ConstSizeVector<maxSize> value; //cable elements have no more than 9 cooordinates ...
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 4 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", visualizationSettings.nodes.defaultColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint2D* cNode = (CNodePoint2D*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 3 coordinates per node ... (3D-displacement vector!)
		ConstSizeVector<maxSize> value; 
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	if (visualizationSettings.nodes.drawNodesAsPoint) { vSystem->graphicsData.AddPoint(pos, currentColor); }
	else { vSystem->graphicsData.AddCircleXY(pos, radius, currentColor, 4 * visualizationSettings.nodes.tiling); }

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", visualizationSettings.nodes.defaultColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyEP::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyEP* cNode = (CNodeRigidBodyEP*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 8; //max. 7+1 coordinates per node ...
		ConstSizeVector<maxSize> value; 
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}


	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 4 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showBasis) {
		Index nn = EXUstd::InvalidIndex;
		if (visualizationSettings.nodes.showNumbers) { nn = itemNumber; }
		EXUvis::DrawOrthonormalBasis(pos, A, visualizationSettings.nodes.basisSize, 0.025*visualizationSettings.nodes.basisSize,
			vSystem->graphicsData, 1.f, visualizationSettings.openGL.showFaces && visualizationSettings.nodes.drawNodesAsPoint, 
			visualizationSettings.general.axesTiling, 2.5, nn);
	}
	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", visualizationSettings.nodes.defaultColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyRxyz::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyRxyz* cNode = (CNodeRigidBodyRxyz*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 8; //max. 7+1 coordinates per node ...
		ConstSizeVector<maxSize> value;
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 4 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showBasis) {
		Index nn = EXUstd::InvalidIndex;
		if (visualizationSettings.nodes.showNumbers) { nn = itemNumber; }
		EXUvis::DrawOrthonormalBasis(pos, A, visualizationSettings.nodes.basisSize, 0.025*visualizationSettings.nodes.basisSize,
			vSystem->graphicsData, 1.f, visualizationSettings.openGL.showFaces && visualizationSettings.nodes.drawNodesAsPoint,
			visualizationSettings.general.axesTiling, 2.5, nn);
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", visualizationSettings.nodes.defaultColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyRotVecLG::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyRotVecLG* cNode = (CNodeRigidBodyRotVecLG*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 8; //max. 7+1 coordinates per node ...
		ConstSizeVector<maxSize> value;
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 4 * visualizationSettings.nodes.tiling;
	if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
	EXUvis::DrawNode(pos, radius, currentColor, vSystem->graphicsData, visualizationSettings.openGL.showFaces, tiling);

	if (visualizationSettings.nodes.showBasis) {
		Index nn = EXUstd::InvalidIndex;
		if (visualizationSettings.nodes.showNumbers) { nn = itemNumber; }
		EXUvis::DrawOrthonormalBasis(pos, A, visualizationSettings.nodes.basisSize, 0.025*visualizationSettings.nodes.basisSize,
			vSystem->graphicsData, 1.f, visualizationSettings.openGL.showFaces && visualizationSettings.nodes.drawNodesAsPoint,
			visualizationSettings.general.axesTiling, 2.5, nn);
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", visualizationSettings.nodes.defaultColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBody2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBody2D* cNode = (CNodeRigidBody2D*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 2+1 coordinates or 3 components per node ...
		ConstSizeVector<maxSize> value; 
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor, 4 * visualizationSettings.nodes.tiling);
	Vector3D vec;
	//EXUmath::MultMatrixVector(A, Vector3D({ radius, 0., 0. }), vec);
	vec = A * Vector3D({ radius, 0., 0. }); //this vector is to show the orientation of the node
	vSystem->graphicsData.AddLine(pos - vec, pos + vec, currentColor, currentColor);

	//EXUmath::MultMatrixVector(A, Vector3D({ 0., radius, 0. }), vec);
	vec = A * Vector3D({ 0., radius, 0. }); //this vector is to show the orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor);

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", visualizationSettings.nodes.defaultColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint2DSlope1::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint2DSlope1* cNode = (CNodePoint2DSlope1*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor, 4 * visualizationSettings.nodes.tiling);

	if (visualizationSettings.nodes.showNodalSlopes)
	{
		Vector3D vec;
		//EXUmath::MultMatrixVector(A, Vector3D({ radius, 0., 0. }), vec);
		vec = A * Vector3D({ 8 * radius, 0., 0. }); //this vector is to show the orientation of the node
		vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor);
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", visualizationSettings.nodes.defaultColor); }
}






//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//BODIES


//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectMassPoint::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMassPoint* cObject = (CObjectMassPoint*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	//Float3 pos({ (float)pos3D[0], (float)pos3D[1], (float)pos3D[2] });

	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }

}

void VisualizationObjectMassPoint2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMassPoint2D* cObject = (CObjectMassPoint2D*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectMass1D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMass1D* cObject = (CObjectMass1D*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectRotationalMass1D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRotationalMass1D* cObject = (CObjectRotationalMass1D*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);
	Matrix3DF A; A.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, A);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectRigidBody::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRigidBody* cObject = (CObjectRigidBody*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);
	Matrix3DF A; A.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, A);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectRigidBody2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRigidBody2D* cObject = (CObjectRigidBody2D*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF;
	refPos3DF.CopyFrom(refPos3D);

	Matrix3DF A;
	A.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, A);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }

}

////! Update visualizationSystem -> graphicsData for item
//void VisualizationObjectGenericODE2::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
//{
//	Float4 currentColor = visualizationSettings.bodies.defaultColor;
//	if (color[0] != -1.f) { currentColor = color; }
//
//	CObjectGenericODE2* cObject = (CObjectGenericODE2*)vSystem->systemData->GetCObjects()[itemNumber];
//
//	Vector3D refPos(0);
//	Matrix3D refRot(3, 3, 0.);
//
//	if (cObject->GetParameters().useFirstNodeAsReferenceFrame) //show nodes with correct reference frame
//	{
//		refRot = ((const CNodeRigidBody*)cObject->GetCNode(CObjectGenericODE2::rigidBodyNodeNumber))->GetRotationMatrix(ConfigurationType::Visualization);
//		refPos = ((const CNodeRigidBody*)cObject->GetCNode(CObjectGenericODE2::rigidBodyNodeNumber))->GetPosition(ConfigurationType::Visualization);
//	}
//
//	if (showNodes && visualizationSettings.nodes.show) //show nodes with correct reference frame
//	{
//		//node size only defined globally
//		float radius = 0.5f*visualizationSettings.nodes.defaultSize;
//		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }
//
//		Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 4 * visualizationSettings.nodes.tiling;
//		Vector3D nodePos;
//		for (Index i = 0; i < cObject->GetNumberOfNodes(); i++)
//		{
//			nodePos = ((CNodeODE2*)(cObject->GetCNode(i)))->GetPosition(ConfigurationType::Visualization);
//			if (cObject->GetParameters().useFirstNodeAsReferenceFrame) //show nodes with correct reference frame
//			{
//				nodePos = refPos + refRot * nodePos;
//			}
//			Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 4 * visualizationSettings.nodes.tiling;
//			if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
//			EXUvis::DrawNode(nodePos, radius, currentColor, vSystem->graphicsData, visualizationSettings.openGL.showFaces, tiling);
//
//			if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(nodePos, vSystem, i, "NF", EXUvis::grey1); }
//		}
//	}
//
//	if (triangleMesh.NumberOfRows() != 0)
//	{
//		CHECKandTHROW(triangleMesh.NumberOfColumns() == 3, "number of columns in GenericODE2::triangleMesh must be 3");
//		//process triangles of mesh to draw
//		std::array<Float4, 3> colors;
//		colors[0] = currentColor;
//		colors[1] = currentColor;
//		colors[2] = currentColor;
//		Vector contourValue; //memory allocation only in case of contour plot!
//
//		std::array<Vector3D, 3> nodes;
//		std::array<Vector3D, 3> normals;
//		//V, V, useFirstNodeAsReferenceFrame, , , bool, "false", , IO, "set true, if first node ($n_0$) is used as floating reference frame; all other nodes are interpreted relative to the reference frame; used to implement FFRF (floating frame of reference formulation); NOTE that in this case, nodes $[n_1,\,\ldots,\,n_n]\tp$ are still drawn without the reference frame"
//		//	V, V, showNodes, , , bool, "false", , IO, "set true, nodes are drawn uniquely via the mesh, eventually using the floating reference frame, even in the visualization of the node is show=False"
//
//		for (Index i = 0; i < triangleMesh.NumberOfRows(); i++)
//		{
//			for (Index j = 0; j < 3; j++)
//			{
//				Index nodeIndex = (Index)triangleMesh(i, j);
//				CNode* cNode = cObject->GetCNode(nodeIndex);
//				CHECKandTHROW(nodeIndex < cObject->GetNumberOfNodes(), "GenericODE2::triangleMesh: contains invalid node number; node numbers must be in range [0, .., numberOfNodes]");
//				nodes[j] = ((CNodeODE2*)cNode)->GetPosition(ConfigurationType::Visualization);
//				if (cObject->GetParameters().useFirstNodeAsReferenceFrame) //show nodes with correct reference frame
//				{
//					nodes[j] = refPos + refRot * nodes[j];
//				}
//				//add contour plot values to color:
//				if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
//				{
//					//Vector value;
//					cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, contourValue); //memory allocation!
//					if (visualizationSettings.contour.outputVariableComponent < contourValue.NumberOfItems())
//					{
//						float contourValueF = (float)contourValue[visualizationSettings.contour.outputVariableComponent];
//						colors[j] = Float4({ contourValueF, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
//					}
//				}
//
//			}
//			//compute normals:
//			Vector3D v0 = nodes[1] - nodes[0];
//			Vector3D v1 = nodes[2] - nodes[0];
//			Vector3D n = v0.CrossProduct(v1);
//			Real len = n.GetL2Norm();
//			if (len != 0) { n *= 1. / len; }
//			normals[0] = n;
//			normals[1] = n;
//			normals[2] = n;
//
//			vSystem->graphicsData.AddTriangle(nodes, normals, colors);
//		}
//	}
//
//
//	//draw body number at average node position
//	if (visualizationSettings.bodies.showNumbers)
//	{
//		Vector3D refPos3D({ 0,0,0 });
//		Index cnt = 0;
//		for (Index i = 0; i < cObject->GetNumberOfNodes(); i++)
//		{
//			CNode* node = cObject->GetCNode(i);
//
//			if (node->GetNodeGroup() == CNodeGroup::ODE2variables &&
//				((node->GetType() & ((Index)Node::Position2D + (Index)Node::Position)) != 0))
//			{
//				refPos3D += ((CNodeODE2*)node)->GetPosition(ConfigurationType::Visualization);
//				cnt++;
//			}
//		}
//		if (cnt) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }
//	}
//
//}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectSuperElement::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;
	if (GetColor()[0] != -1.f) { currentColor = GetColor(); }

	CObjectSuperElement* cObject = (CObjectSuperElement*)vSystem->systemData->GetCObjects()[itemNumber];

	Index localRigidBodyNodeNumber; //local number in body!
	bool hasReferenceFrame = cObject->HasReferenceFrame(localRigidBodyNodeNumber);

	Matrix3D refRot = EXUmath::unitMatrix3D;
	Vector3D refPos({ 0,0,0 });

	if (hasReferenceFrame)
	{
		refRot = ((const CNodeRigidBody*)cObject->GetCNode(localRigidBodyNodeNumber))->GetRotationMatrix(ConfigurationType::Visualization); //cObject->GetCNode(...) takes local number
		refPos = ((const CNodeRigidBody*)cObject->GetCNode(localRigidBodyNodeNumber))->GetPosition(ConfigurationType::Visualization);
	}

	Real scaleFactor = visualizationSettings.bodies.deformationScaleFactor;

	if (GetShowNodes() && visualizationSettings.nodes.show) //show nodes with correct reference frame
	{
		//node size only defined globally
		float radius = 0.5f*visualizationSettings.nodes.defaultSize;
		if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

		Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 4 * visualizationSettings.nodes.tiling;
		Vector3D nodePos;
		for (Index i = 0; i < cObject->GetNumberOfMeshNodes(); i++)
		{
			if (scaleFactor == 1.)
			{
				nodePos = cObject->GetMeshNodePosition(i, ConfigurationType::Visualization);
			}
			else
			{
				nodePos = cObject->GetMeshNodeLocalPosition(i, ConfigurationType::Visualization);
				Vector3D nodeRefPos = cObject->GetMeshNodeLocalPosition(i, ConfigurationType::Reference);
				nodePos = scaleFactor * (nodePos - nodeRefPos) + nodeRefPos;
				nodePos = refPos + refRot * nodePos;
			}

			Index tiling = visualizationSettings.openGL.showFaces ? visualizationSettings.nodes.tiling : 4 * visualizationSettings.nodes.tiling;
			if (visualizationSettings.nodes.drawNodesAsPoint) { tiling = 0; } //draw as point
			EXUvis::DrawNode(nodePos, radius, currentColor, vSystem->graphicsData, visualizationSettings.openGL.showFaces, tiling);

			if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(nodePos, vSystem, i, "NF", EXUvis::grey1); }
		}
	}

	if (GetTriangleMesh().NumberOfRows() != 0)
	{

		//process triangles of mesh to draw
		std::array<Float4, 3> colors;
		colors[0] = currentColor;
		colors[1] = currentColor;
		colors[2] = currentColor;
		Vector contourValue; //memory allocation only in case of contour plot!

		std::array<Vector3D, 3> nodes;
		std::array<Vector3D, 3> normals;
		//V, V, useFirstNodeAsReferenceFrame, , , bool, "false", , IO, "set true, if first node ($n_0$) is used as floating reference frame; all other nodes are interpreted relative to the reference frame; used to implement FFRF (floating frame of reference formulation); NOTE that in this case, nodes $[n_1,\,\ldots,\,n_n]\tp$ are still drawn without the reference frame"
		//	V, V, showNodes, , , bool, "false", , IO, "set true, nodes are drawn uniquely via the mesh, eventually using the floating reference frame, even in the visualization of the node is show=False"

		for (Index i = 0; i < GetTriangleMesh().NumberOfRows(); i++)
		{
			for (Index j = 0; j < 3; j++)
			{
				colors[j] = currentColor; //set back to default if some values are invalid
				Index meshNodeIndex = (Index)GetTriangleMesh()(i, j);
				if (scaleFactor == 1.)
				{
					nodes[j] = cObject->GetMeshNodePosition(meshNodeIndex, ConfigurationType::Visualization);
				}
				else
				{
					nodes[j] = cObject->GetMeshNodeLocalPosition(meshNodeIndex, ConfigurationType::Visualization);
					Vector3D nodeRefPos = cObject->GetMeshNodeLocalPosition(meshNodeIndex, ConfigurationType::Reference);
					nodes[j] = scaleFactor * (nodes[j] - nodeRefPos) + nodeRefPos;
					nodes[j] = refPos + refRot * nodes[j];
				}

				//add contour plot values to color:
				if ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypesSuperElement(meshNodeIndex))
				{
					//Vector value;
					//cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, contourValue); 
					cObject->GetOutputVariableSuperElement(visualizationSettings.contour.outputVariable, meshNodeIndex, ConfigurationType::Visualization, contourValue); //memory allocation!
					if (visualizationSettings.contour.outputVariableComponent < contourValue.NumberOfItems())
					{
						float contourValueF = (float)contourValue[visualizationSettings.contour.outputVariableComponent];
						colors[j] = Float4({ contourValueF, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
					}
				}

			}
			//compute normals:
			Vector3D v0 = nodes[1] - nodes[0];
			Vector3D v1 = nodes[2] - nodes[0];
			Vector3D n = v0.CrossProduct(v1);
			Real len = n.GetL2Norm();
			if (len != 0) { n *= 1. / len; }
			normals[0] = n;
			normals[1] = n;
			normals[2] = n;

			vSystem->graphicsData.AddTriangle(nodes, normals, colors);
		}
	}


	//draw body number at reference frame node position
	if (visualizationSettings.bodies.showNumbers)
	{
		Vector3D refPos3D = cObject->GetPosition(Vector3D({ 0,0,0 }), ConfigurationType::Visualization);
		EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "RF", currentColor);
	}

}


////! Update visualizationSystem -> graphicsData for item
//void VisualizationObjectFFRF::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
//{
//	VisualizationObjectSuperElement::UpdateGraphics(visualizationSettings, vSystem, itemNumber);
//}


//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectGround::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectGround* cObject = (CObjectGround*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF;
	refPos3DF.CopyFrom(refPos3D); // ({ (float)pos3D[0], (float)pos3D[1], (float)pos3D[2] });

	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }
}


void VisualizationObjectANCFCable2DBaseUpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber, const Float4& color, float drawHeight)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectANCFCable2DBase* cObject = (CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[itemNumber];

	Index tiling = visualizationSettings.bodies.beams.axialTiling;

	GLLine item;
	if (color[0] != -1.f) { currentColor = color; }

	Real L = cObject->GetLength();
	item.color1 = currentColor;
	item.color2 = currentColor;

	bool contourPlot = false;
	float value1, value2; //values at endpoints, use linear interpolation
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes())
	{
		//ConstSizeVector<9> value; //cable elements have no more than 9 cooordinates ...
		Vector value;
		cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({0.,0.,0.}), ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			value1 = (float)value[visualizationSettings.contour.outputVariableComponent]; //value at x=0
			cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ L,0.,0. }), ConfigurationType::Visualization, value);
			value2 = (float)value[visualizationSettings.contour.outputVariableComponent]; //value at x=L
			item.color1 = Float4({ 0.,0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
			item.color2 = Float4({ 0.,0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
			contourPlot = true;
		}
	}

	//for now, bending stresses/strains are not computed/plotted off-axis!
	Float3 p0[2];
	Float3 p1[2];
	p0[0].CopyFrom(cObject->GetPosition(Vector3D({ 0., (Real)(-drawHeight * 0.5),0. }), ConfigurationType::Visualization));
	p0[1].CopyFrom(cObject->GetPosition(Vector3D({ 0., (Real)(drawHeight * 0.5),0. }), ConfigurationType::Visualization));

	Real deltaX = L / (Real)tiling;
	Index n = 1; //no height
	if (drawHeight != 0.) 
	{ 
		n = 2;
		//first cross section
		item.point1 = p0[0];
		item.point2 = p0[1];
		item.color1[0] = value1;
		item.color2[0] = value1;
		vSystem->graphicsData.glLines.Append(item);
	}

	for (Index j = 0; j < n; j++)
	{
		Real y = drawHeight*(-0.5 + (Real)j);
		for (Index i = 1; i <= tiling; i++)
		{
			Real x = (Real)i / (Real)tiling*L;

			Vector3D pLoc({ x, y, 0. });
			p1[j].CopyFrom(cObject->GetPosition(pLoc, ConfigurationType::Visualization));

			if (contourPlot) 
			{ 
				item.color1[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)(x - deltaX));
				item.color2[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)x);
			}
			item.point1 = p0[j];
			item.point2 = p1[j];
			vSystem->graphicsData.glLines.Append(item);
			p0[j] = p1[j]; //for next line segment
		}
	}
	if (drawHeight != 0.)
	{
		//last cross section
		item.point1 = p1[0];
		item.point2 = p1[1];
		item.color1[0] = value2;
		item.color2[0] = value2;
		vSystem->graphicsData.glLines.Append(item);
	}

	Vector3D pos3D = cObject->GetPosition(Vector3D({ L*0.5,0.,0. }), ConfigurationType::Visualization);
	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3D, vSystem, itemNumber, "", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectANCFCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	VisualizationObjectANCFCable2DBaseUpdateGraphics(visualizationSettings, vSystem, itemNumber, color, drawHeight);
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectALEANCFCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	VisualizationObjectANCFCable2DBaseUpdateGraphics(visualizationSettings, vSystem, itemNumber, color, drawHeight);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//CONNECTORS

void VisualizationObjectConnectorSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorSpringDamper* cItem = (CObjectConnectorSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	//Index2 markers = Index2({ cItem->GetMarkerNumbers()[0], cItem->GetMarkerNumbers()[1] });
	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }
	//if (!cItem->GetParameters().activeConnector) //if inactive, make the constraint much lighter; or turn to RED?
	//{ currentColor = Float4({ 0.75f+0.25f*currentColor[0],0.75f + 0.25f*currentColor[1],0.75f + 0.25f*currentColor[2],currentColor[3] }); }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	//Vector3D v0 = pos[1] - pos[0]; //vector from p0 to p1
	//Vector3D vN({ -v0[1], v0[0], v0[2] });
	//Real Ln = vN.GetL2Norm(); //length of normal vector
	//if (Ln != 0.f) { vN /= Ln; }
	//const Index numberOfPoints = 12;
	//EXUvis::DrawSpring2D(pos[0], pos[1], vN, numberOfPoints, r, currentColor, vSystem->graphicsData);
	Index numberOfWindings = visualizationSettings.connectors.springNumberOfWindings;
	const Index nTildePerWinding = visualizationSettings.general.circleTiling;
	EXUvis::DrawSpring(pos[0], pos[1], numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorCartesianSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCartesianSpringDamper* cItem = (CObjectConnectorCartesianSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D v0 = pos[1] - pos[0]; //vector from p0 to p1

	Vector3D p0, p1, vN, vRel;

	if (cItem->GetParameters().activeConnector) //does not work in visualization ...
	{
		//draw 3 orthogonal springs
		Index numberOfWindings = visualizationSettings.connectors.springNumberOfWindings;
		const Index nTildePerWinding = visualizationSettings.general.circleTiling;
		p0 = pos[0]; p1 = pos[0] + Vector3D({ v0[0],0,0 });		//x-direction
		EXUvis::DrawSpring(p0, p1, numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData);
		p0 = p1; p1 = pos[0] + Vector3D({ v0[0],v0[1],0 });		//y-direction
		EXUvis::DrawSpring(p0, p1, numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData);
		p0 = p1; p1 = pos[0] + v0;								//z-direction
		EXUvis::DrawSpring(p0, p1, numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData);

		//const Index numberOfPoints = 12;
		//p0 = pos[0]; p1 = pos[0] + Vector3D({ v0[0],0,0 });		//x-direction
		//EXUvis::DrawSpring2D(p0, p1, Vector3D({ 0,1,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
		//p0 = p1; p1 = pos[0] + Vector3D({ v0[0],v0[1],0 });		//y-direction
		//EXUvis::DrawSpring2D(p0, p1, Vector3D({ 1,0,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
		//p0 = p1; p1 = pos[0] + v0;								//z-direction
		//EXUvis::DrawSpring2D(p0, p1, Vector3D({ 0,1,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorRigidBodySpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorRigidBodySpringDamper* cItem = (CObjectConnectorRigidBodySpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }
	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	//draw as sphere with drawSize ...
	EXUvis::DrawSphere(pos[0], r, currentColor, vSystem->graphicsData, visualizationSettings.general.sphereTiling);
	EXUvis::DrawSphere(pos[1], r, EXUvis::ModifyColor(currentColor, EXUvis::modifyColorFactor), vSystem->graphicsData, visualizationSettings.general.sphereTiling);
	EXUvis::DrawCylinder(pos[0], pos[1]-pos[0], 0.8*r, currentColor, vSystem->graphicsData, visualizationSettings.general.cylinderTiling);

	if (visualizationSettings.connectors.showJointAxes)
	{
		Matrix3D rot[2];
		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

		//add marker rotation here!
		rot[0] = rot[0] * cItem->GetParameters().rotationMarker0;
		rot[1] = rot[1] * cItem->GetParameters().rotationMarker1;

		EXUvis::DrawOrthonormalBasis(pos[0], rot[0], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, vSystem->graphicsData, 1.f, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
		EXUvis::DrawOrthonormalBasis(pos[1], rot[1], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, vSystem->graphicsData, EXUvis::modifyColorFactor, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}


void VisualizationObjectConnectorCoordinateSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCoordinateSpringDamper* cItem = (CObjectConnectorCoordinateSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius connectorCoordinate
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	//Vector3D n({ 0,0,1 }); //normal defining the plane in which the 2D spring is drawn
	//Vector3D v = pos[1] - pos[0];
	//if (fabs(v[2]) > fabs(v[0]) + fabs(v[1])) { n = Vector3D({1.,0.,0.}); }
	//const Index numberOfPoints = 12;	
	//EXUvis::DrawSpring2D(pos[0], pos[1], n, numberOfPoints, r, currentColor, vSystem->graphicsData);
	Index numberOfWindings = visualizationSettings.connectors.springNumberOfWindings;
	const Index nTildePerWinding = visualizationSettings.general.circleTiling;
	EXUvis::DrawSpring(pos[0], pos[1], numberOfWindings, nTildePerWinding, r, currentColor, vSystem->graphicsData);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorDistance::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorDistance* cItem = (CObjectConnectorDistance*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddLine(pos[0], pos[1], currentColor, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorCoordinate::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCoordinate* cItem = (CObjectConnectorCoordinate*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius connectorCoordinate
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }

}

void VisualizationObjectConnectorRollingDiscPenalty::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorRollingDiscPenalty* cItem = (CObjectConnectorRollingDiscPenalty*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Matrix3D rot[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }

	Real discRadius = cItem->GetParameters().discRadius;
	Vector3D vAxis({ rot[1](0,0), rot[1](1,0), rot[1](2,0) }); //x-axis is disc axis ==> vAxis = A*[1,0,0]

	//add drawing for disc
	EXUvis::DrawCylinder(pos[1] - 0.5*discWidth*vAxis, discWidth*vAxis, discRadius, currentColor, vSystem->graphicsData, 4 * visualizationSettings.general.cylinderTiling);
	EXUvis::DrawCylinder(pos[1] - discWidth * vAxis, 2.*discWidth*vAxis, 0.1*discRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, visualizationSettings.general.cylinderTiling);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectContactCoordinate::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactCoordinate* cItem = (CObjectContactCoordinate*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius ContactCoordinate
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.contactPointsDefaultSize; } //use default size

		//draw the two according points; change color to red, if contact:
		if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[0] < 0) //this is the gap at the end of the discontinuous iteration
		{
			currentColor = Float4({ 1.,0.,0.,1. }); //red color means contact ...
		}
		vSystem->graphicsData.AddCircleXY(pos[0], r, currentColor);
		vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectContactCircleCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactCircleCable2D* cItem = (CObjectContactCircleCable2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius of contact points
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.contactPointsDefaultSize; } //use default size

		//draw contact circle of first object:
		vSystem->graphicsData.AddCircleXY(pos[0], (float)cItem->GetParameters().circleRadius, currentColor, 64);
		Index nSeg = cItem->GetParameters().numberOfContactSegments;
		Vector3D pContactLast; //previously computed point

		Index objectNum = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
		Real lCable = ((const CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[objectNum])->GetLength();//GetParameters().physicsLength;

		for (Index i = 0; i <= nSeg; i++)
		{
			Real locPos = (Real)i / (Real)nSeg * lCable;
			Vector3D pContact = vSystem->systemData->GetCObjectBody(objectNum).GetPosition(Vector3D({ locPos, 0, 0 }), ConfigurationType::Visualization);
			vSystem->graphicsData.AddCircleXY(pContact, r, currentColor);

			if (i > 0)
			{
				Float4 contactColor = currentColor;
				//draw the two according points; change color to red, if contact:
				if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[i - 1] < 0) //this is the gap at the end of the discontinuous iteration
				{
					contactColor = Float4({ 1.,0.,0.,1. });
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor);
				} //red color means contact ...

			}
			pContactLast = pContact;
		}
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemNumber, "", currentColor); } //midpoint of ANCF element

}

void VisualizationObjectContactFrictionCircleCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactFrictionCircleCable2D* cItem = (CObjectContactFrictionCircleCable2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius of contact points
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.contactPointsDefaultSize; } //use default size

		//draw contact circle of first object:
		vSystem->graphicsData.AddCircleXY(pos[0], (float)cItem->GetParameters().circleRadius, currentColor, 64);
		Index nSeg = cItem->GetParameters().numberOfContactSegments;
		Vector3D pContactLast; //previously computed point

		Index objectNum = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
		//Real lCable = ((const CObjectANCFCable2D&)vSystem->systemData->GetCObjectBody(objectNum)).GetParameters().physicsLength;
		Real lCable = ((const CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[objectNum])->GetLength();//GetParameters().physicsLength;

		for (Index i = 0; i <= nSeg; i++)
		{
			Real locPos = (Real)i / (Real)nSeg * lCable;
			Vector3D pContact = vSystem->systemData->GetCObjectBody(objectNum).GetPosition(Vector3D({ locPos, 0, 0 }), ConfigurationType::Visualization);
			vSystem->graphicsData.AddCircleXY(pContact, r, currentColor);

			if (i > 0)
			{
				Float4 contactColor = currentColor;
				//draw the two according points; change color to red, if contact:
				if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[i - 1] < 0) //this is the gap at the end of the discontinuous iteration
				{
					contactColor = Float4({ 1.,0.,0.,1. });
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor);
				} //red color means contact ...

			}
			pContactLast = pContact;
		}
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemNumber, "", currentColor); } //midpoint of ANCF element

}

void VisualizationObjectJointGeneric::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointGeneric* cItem = (CObjectJointGeneric*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Matrix3D rot[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	rot[0] = rot[0] * cItem->GetParameters().rotationMarker0;
	rot[1] = rot[1] * cItem->GetParameters().rotationMarker1;

	if (color[0] != -1.f) { currentColor = color; }

	Index axesConstrained = cItem->GetParameters().constrainedAxes[3] + cItem->GetParameters().constrainedAxes[4] + cItem->GetParameters().constrainedAxes[5];

	//... add drawings for translational joints ...

	if (axesConstrained == 3) //rigid configuration, draw as sphere
	{
		EXUvis::DrawSphere(pos[0], 0.5*axesRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, visualizationSettings.general.sphereTiling);
		EXUvis::DrawSphere(pos[1], 0.5*axesRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.sphereTiling); 
	}
	else if (axesConstrained == 2) //revolute or cylindrical joint
	{
		for (Index i = 0; i < 3; i++)
		{
			if (cItem->GetParameters().constrainedAxes[3 + i] == 0)
			{
				Vector3D v = rot[0].GetColumnVector<3>(i);
				EXUvis::DrawCylinder(pos[0] - 0.6*axesLength*v, 1.2*axesLength*v, 0.5*axesRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, visualizationSettings.general.cylinderTiling); //axis attached to marker0
				EXUvis::DrawCylinder(pos[1] - 0.5*axesLength*v, axesLength*v, axesRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.cylinderTiling, 0.75*axesRadius); //hinge attached to marker1
			}
		}
	}
	else if (axesConstrained == 1) //revolute or cylindrical joint
	{
		Index offset = 0; //for second body
		for (Index i = 0; i < 3; i++)
		{
			if (cItem->GetParameters().constrainedAxes[3 + i] == 0)
			{
				Vector3D v = rot[offset].GetColumnVector<3>(i);
				EXUvis::DrawCylinder(pos[offset] - 0.6*axesLength*v, 1.2*axesLength*v, 0.5*axesRadius, EXUvis::ModifyColor(currentColor, 1.f-0.75f*offset), 
					vSystem->graphicsData, visualizationSettings.general.cylinderTiling); //axis attached to marker0
				offset++;
			}
		}
	}
	if (visualizationSettings.connectors.showJointAxes)
	{
		EXUvis::DrawOrthonormalBasis(pos[0], rot[0], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, vSystem->graphicsData, 1.f, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
		EXUvis::DrawOrthonormalBasis(pos[1], rot[1], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, vSystem->graphicsData, EXUvis::modifyColorFactor, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}


void VisualizationObjectJointSpherical::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointSpherical* cItem = (CObjectJointSpherical*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }

	Index axesConstrained = cItem->GetParameters().constrainedAxes[0] + cItem->GetParameters().constrainedAxes[1] + cItem->GetParameters().constrainedAxes[2];

	if (axesConstrained < 3) //draw relative vector as cylinder
	{
		EXUvis::DrawCylinder(pos[0], pos[1] - pos[0], 0.5*jointRadius, EXUvis::ModifyColor(currentColor, 0.5), vSystem->graphicsData, 
			visualizationSettings.general.cylinderTiling); //axis attached to marker0
	}

	EXUvis::DrawSphere(pos[0], jointRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, visualizationSettings.general.sphereTiling);
	EXUvis::DrawSphere(pos[1], jointRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.sphereTiling);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointRollingDisc::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointRollingDisc* cItem = (CObjectJointRollingDisc*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Matrix3D rot[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }

	Real discRadius = cItem->GetParameters().discRadius;
	Vector3D vAxis({ rot[1](0,0), rot[1](1,0), rot[1](2,0) }); //x-axis is disc axis ==> vAxis = A*[1,0,0]

	//add drawing for disc
	EXUvis::DrawCylinder(pos[1] - 0.5*discWidth*vAxis, discWidth*vAxis, discRadius, currentColor, vSystem->graphicsData, 4 * visualizationSettings.general.cylinderTiling);
	EXUvis::DrawCylinder(pos[1] - discWidth * vAxis, 2.*discWidth*vAxis, 0.1*discRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, visualizationSettings.general.cylinderTiling);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemNumber, "", currentColor); }
}


void VisualizationObjectJointRevolute2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointRevolute2D* cItem = (CObjectJointRevolute2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointPrismatic2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointPrismatic2D* cItem = (CObjectJointPrismatic2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);
	vSystem->graphicsData.AddLine(pos[0], pos[1], currentColor, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointSliding2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointSliding2D* cItem = (CObjectJointSliding2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointALEMoving2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointALEMoving2D* cItem = (CObjectJointALEMoving2D*)vSystem->systemData->GetCObjects()[itemNumber];
	
	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	//moving body position:
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	
	//marker1 (ANCF) does not provide current positino, but only ANCF coordinates ...
	//vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Index nALEANCF = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
	const CObjectALEANCFCable2D& cable = (const CObjectALEANCFCable2D&)vSystem->systemData->GetCObjectBody(nALEANCF);

	//compute ANCF coordinates:
	const Index ns = 4;
	ConstSizeVector<ns> qNode0;
	ConstSizeVector<ns> qNode1;

	qNode0.CopyFrom(cable.GetCNode(0)->GetCoordinateVector(ConfigurationType::Visualization)); //displacement coordinates node 0
	qNode1.CopyFrom(cable.GetCNode(1)->GetCoordinateVector(ConfigurationType::Visualization)); //displacement coordinates node 1

	qNode0 += ((CNodeODE2*)cable.GetCNode(0))->GetReferenceCoordinateVector(); //reference coordinates + displacements
	qNode1 += ((CNodeODE2*)cable.GetCNode(1))->GetReferenceCoordinateVector();

	//compute sliding position:
	Real L = cable.GetParameters().physicsLength;

	//compute sliding coordinate
	Real slidingCoordinate = cItem->GetCNode(1)->GetCoordinateVector(ConfigurationType::Visualization)[0]
		+ cItem->GetParameters().slidingOffset; //this is the global (Eulerian) sliding position

	Index slidingMarkerIndex = (Index)cItem->GetCNode(0)->GetCoordinateVector(ConfigurationType::Visualization)[0]; //this contains the current index in the cable marker list; slidingMarkerIndex will always be in valid range!

	slidingCoordinate -= cItem->GetParameters().slidingMarkerOffsets[slidingMarkerIndex]; //slidingPos now ranges from 0 to L in current cable element

	//draw sliding position:
	Vector4D SV = CObjectANCFCable2D::ComputeShapeFunctions(slidingCoordinate, L);
	Vector2D slidingPosition = CObjectANCFCable2D::MapCoordinates(SV, qNode0, qNode1);
	pos[1] = { slidingPosition[0],slidingPosition[1],0 };
	//std::cout << "pos1=" << pos[1] << ",pos0=" << pos[0] << "\n";

	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; 
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D vy({ 0,r,0 });
	Vector3D vx({ r,0,0 });
	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));

	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);
	vSystem->graphicsData.AddLine(pos[1] - vx, pos[1] + vx, currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos[1] - vy, pos[1] + vy, currentColor, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! Update visualizationSystem -> graphicsData for item
void VisualizationMarkerBodyPosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyPosition* cMarker = (CMarkerBodyPosition*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyMass::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyMass* cMarker = (CMarkerBodyMass*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor); 
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor); //bodymass-marker has double circle
	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyRigid* cMarker = (CMarkerBodyRigid*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, -radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({  radius, -radius, 0. }), pos + Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({  radius,  radius, 0. }), pos + Vector3D({-radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius,  radius, 0. }), pos + Vector3D({-radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerNodePosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerNodePosition* cMarker = (CMarkerNodePosition*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerNodeRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerNodeRigid* cMarker = (CMarkerNodeRigid*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	//radius /= sqrt(2.f);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, -radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ radius, -radius, 0. }), pos + Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ radius,  radius, 0. }), pos + Vector3D({ -radius, radius, 0. }), currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos + Vector3D({ -radius,  radius, 0. }), pos + Vector3D({ -radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationMarkerSuperElementPosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerSuperElementPosition* cMarker = (CMarkerSuperElementPosition*)vSystem->systemData->GetCMarkers()[itemNumber];
	const CObjectSuperElement* cSuperElement = (const CObjectSuperElement*)vSystem->systemData->GetCObjects()[cMarker->GetObjectNumber()];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	//show marker position
	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);

	if (showMarkerNodes)
	{
		Float4 alternativeColor = EXUvis::ModifyColor(currentColor, 0.25f);
		for (Index node : cMarker->GetParameters().meshNodeNumbers)
		{
			Vector3D p = cSuperElement->GetMeshNodePosition(node, ConfigurationType::Visualization);
			EXUvis::DrawMarker(p, radius, alternativeColor, vSystem->graphicsData, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
		}
	}

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationMarkerSuperElementRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerSuperElementRigid* cMarker = (CMarkerSuperElementRigid*)vSystem->systemData->GetCMarkers()[itemNumber];
	const CObjectSuperElement* cSuperElement = (const CObjectSuperElement*)vSystem->systemData->GetCObjects()[cMarker->GetObjectNumber()];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	//show marker position
	EXUvis::DrawMarker(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);

	Matrix3D A;
	cMarker->GetRotationMatrix(*vSystem->systemData, A, ConfigurationType::Visualization);
	
	//show marker orientation ==> only for rigid marker
	EXUvis::DrawOrthonormalBasis(pos, A, radius*4, 0.1*radius,
		vSystem->graphicsData, 1.f, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces,
		visualizationSettings.general.axesTiling, 2.5);

	if (showMarkerNodes)
	{
		Float4 alternativeColor = EXUvis::ModifyColor(currentColor, 0.25f);
		for (Index node : cMarker->GetParameters().meshNodeNumbers)
		{
			Vector3D p = cSuperElement->GetMeshNodePosition(node, ConfigurationType::Visualization);
			EXUvis::DrawMarker(p, radius, alternativeColor, vSystem->graphicsData, !visualizationSettings.markers.drawSimplified && visualizationSettings.openGL.showFaces);
		}
	}

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyCable2DShape::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyCable2DShape* cMarker = (CMarkerBodyCable2DShape*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyCable2DCoordinates::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyCable2DCoordinates* cMarker = (CMarkerBodyCable2DCoordinates*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++  LOADS  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void VisualizationLoadForceVector::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadForceVector* cLoad = (CLoadForceVector*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	Vector3D pos; //global marker position
	if (cMarker->GetType() & Marker::Position) //marker must be able to measure position
	{
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;

		if (cLoad->IsBodyFixed()) //transform load from local to global coordinates for drawing
		{
			Matrix3D rot;
			cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);
			loadVector = rot * loadVector;
		}

		if (visualizationSettings.loads.fixedLoadSize)
		{
			Real L = loadVector.GetL2Norm();
			if (L > 0.) { loadVector *= 1. / L; }
			loadVector *= size;
		}
		else
		{
			loadVector *= visualizationSettings.loads.loadSizeFactor;
		}

		EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor, 
			vSystem->graphicsData, visualizationSettings.general.axesTiling, false, !visualizationSettings.loads.drawSimplified && visualizationSettings.openGL.showFaces);

		if (visualizationSettings.loads.showNumbers) { EXUvis::DrawItemNumber(pos+loadVector, vSystem, itemNumber, "L", currentColor); }
	}
}

void VisualizationLoadMassProportional::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadMassProportional* cLoad = (CLoadMassProportional*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	Vector3D pos; //global marker position
	if (cMarker->GetType() & Marker::BodyMass) //marker must be able to measure position
	{
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;
		//always draw massproportional loads with fixed size
		Real L = loadVector.GetL2Norm();
		if (L > 0.) { loadVector *= 1. / L; }
		loadVector *= size;

		EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor,
			vSystem->graphicsData, visualizationSettings.general.axesTiling, false, 
			!visualizationSettings.loads.drawSimplified && visualizationSettings.openGL.showFaces);

		//if (visualizationSettings.openGL.showFaces) //show in 3D
		//{
		//	EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.axesTiling);
		//}
		//else
		//{
		//	Vector3D n1; //resulting normal vector to loadVector ==> for drawing of arrow
		//	Vector3D n2;
		//	EXUmath::ComputeOrthogonalBasis(loadVector, n1, n2);

		//	//Vector3D hatOffset({ -0.1*loadVector[1], 0.1*loadVector[0], 0. });
		//	Vector3D hatOffset = (0.1*(Real)size)*n1;

		//	vSystem->graphicsData.AddLine(pos, pos + loadVector, currentColor, currentColor);
		//	vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector + hatOffset, currentColor, currentColor);
		//	vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector - hatOffset, currentColor, currentColor);
		//}
		if (visualizationSettings.loads.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "L", currentColor); }
	}
}

void VisualizationLoadTorqueVector::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadTorqueVector* cLoad = (CLoadTorqueVector*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	if ((cMarker->GetType() & Marker::Position) && (cMarker->GetType() & Marker::Orientation)) //marker must be able to measure position and orientation
	{
		Vector3D pos; //global marker position
		Matrix3D rot; //global marker rotation
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);
		cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;
		if (cLoad->IsBodyFixed()) //transform load from local to global coordinates for drawing
		{
			Matrix3D rot;
			cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);
			loadVector = rot * loadVector;
		}

		if (visualizationSettings.loads.fixedLoadSize)
		{
			Real L = loadVector.GetL2Norm();
			if (L > 0.) { loadVector *= 1. / L; }
			loadVector *= size;
		}
		else
		{
			loadVector *= visualizationSettings.loads.loadSizeFactor;
		}

		EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor,
			vSystem->graphicsData, visualizationSettings.general.axesTiling, true, !visualizationSettings.loads.drawSimplified && visualizationSettings.openGL.showFaces);

		if (visualizationSettings.loads.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "L", currentColor); }
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++    SENSORS    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void VisualizationSensorNode::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	Index nodeNumber = vSystem->systemData->GetCSensors()[itemNumber]->GetNodeNumber();
	CNode* cNode = vSystem->systemData->GetCNodes()[nodeNumber];
	if (cNode->GetNodeGroup() == CNodeGroup::ODE2variables)
	{

		float radius = 0.5f*visualizationSettings.sensors.defaultSize;
		if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

		Vector3D pos(((CNodeODE2*)cNode)->GetPosition(ConfigurationType::Visualization));
		EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);

		if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "S", currentColor); }
	}
}

void VisualizationSensorObject::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	CSensorObject* cSensor = (CSensorObject*)(vSystem->systemData->GetCSensors()[itemNumber]);
	Index objectNumber = cSensor->GetObjectNumber();
	const CObject& cObject = *(vSystem->systemData->GetCObjects()[objectNumber]);

	float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

	//can only be drawn, if position exists
	if ((Index)cObject.GetType() & (Index)CObjectType::Connector)
	{
		const CObjectConnector& cConnector = (const CObjectConnector&)cObject;

		if (cConnector.GetMarkerNumbers().NumberOfItems() == 2)
		{
			const CMarker& cMarker0 = vSystem->systemData->GetCMarker(cConnector.GetMarkerNumbers()[0]);
			const CMarker& cMarker1 = vSystem->systemData->GetCMarker(cConnector.GetMarkerNumbers()[1]);

			Vector3D pos0, pos1;
			cMarker0.GetPosition(*(vSystem->systemData), pos0, ConfigurationType::Visualization);
			cMarker1.GetPosition(*(vSystem->systemData), pos1, ConfigurationType::Visualization);

			Vector3D pos = pos0 + pos1;
			EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);
			if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "S", currentColor); }
		}

	}


}

void VisualizationSensorBody::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	CSensorBody* cSensor = (CSensorBody*)(vSystem->systemData->GetCSensors()[itemNumber]);
	Index objectNumber = cSensor->GetObjectNumber();
	const CObjectBody& cObject = vSystem->systemData->GetCObjectBody(objectNumber);

	float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

	Vector3D pos(cObject.GetPosition(cSensor->GetBodyLocalPosition(), ConfigurationType::Visualization));
	EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);

	if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "S", currentColor); }

}

void VisualizationSensorSuperElement::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	CSensorSuperElement* cSensor = (CSensorSuperElement*)(vSystem->systemData->GetCSensors()[itemNumber]);
	Index objectNumber = cSensor->GetObjectNumber();
	const CObjectSuperElement* cObject = (const CObjectSuperElement*)(vSystem->systemData->GetCObjects()[objectNumber]);

	float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

	Vector3D pos(cObject->GetMeshNodePosition(cSensor->GetMeshNodeNumber(), ConfigurationType::Visualization));
	EXUvis::DrawSensor(pos, radius, currentColor, vSystem->graphicsData, !visualizationSettings.sensors.drawSimplified && visualizationSettings.openGL.showFaces);

	if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "S", currentColor); }

}


