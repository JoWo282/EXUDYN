/** ***********************************************************************************************
* @brief        Implementation for VisualizationNodePoint
*
* @author       Gerstmayr Johannes
* @date         2018-04-18 (generated)
* @date         2019-05-27 (last modfied)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */
#pragma once

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h" //includes stdoutput.h
#include "Utilities/BasicFunctions.h"	//includes stdoutput.h


//#include "Linalg/ConstSizeVector.h"		//includes Vector.h
#include "Linalg/BasicLinalg.h"		//includes Vector.h
//#include "Utilities/ResizableArray.h"	//includes SlimArray.h and BasicFunctions.h
//#include "System/CSystem.h"
//#include "Autogenerated/VisualizationSettings.h" 
//#include "Graphics/GraphicsData.h"
//#include "Graphics/VisualizationSystem.h"
#include "Graphics/VisualizationSystemContainer.h"


//#include "Graphics/VisuNode.h"
#include "Autogenerated/VisuNodePoint.h"
#include "Autogenerated/VisuNodePointGround.h"
#include "Autogenerated/VisuNodePoint2D.h"
#include "Autogenerated/VisuNodeRigidBodyEP.h"
#include "Autogenerated/VisuNodeRigidBody2D.h"
#include "Autogenerated/VisuNodePoint2DSlope1.h"

#include "Autogenerated/VisuObjectMassPoint.h"
#include "Autogenerated/VisuObjectMassPoint2D.h"
#include "Autogenerated/VisuObjectRigidBody.h"
#include "Autogenerated/VisuObjectRigidBody2D.h"
#include "Autogenerated/VisuObjectGround.h"

#include "Autogenerated/VisuObjectANCFCable2D.h"
#include "Autogenerated/VisuObjectALEANCFCable2D.h"

#include "Autogenerated/VisuObjectConnectorSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorDistance.h"
#include "Autogenerated/VisuObjectConnectorCoordinate.h"
#include "Autogenerated/VisuObjectContactCoordinate.h"
#include "Autogenerated/VisuObjectContactCircleCable2D.h"
#include "Autogenerated/VisuObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/VisuObjectJointRevolute2D.h"
#include "Autogenerated/VisuObjectJointPrismatic2D.h"
#include "Autogenerated/VisuObjectJointSliding2D.h"
#include "Autogenerated/VisuObjectJointALEMoving2D.h"

#include "Autogenerated/VisuMarkerBodyPosition.h"
#include "Autogenerated/VisuMarkerBodyRigid.h"
#include "Autogenerated/VisuMarkerBodyMass.h"
#include "Autogenerated/VisuMarkerNodePosition.h"
#include "Autogenerated/VisuMarkerNodeRigid.h"
#include "Autogenerated/VisuMarkerBodyCable2DShape.h"
#include "Autogenerated/VisuMarkerBodyCable2DCoordinates.h"

#include "Autogenerated/VisuLoadForceVector.h"
#include "Autogenerated/VisuLoadTorqueVector.h"
#include "Autogenerated/VisuLoadMassProportional.h"

//++++++++++++++++++++++++++
//should not be needed, appropriate functions added to visualization objects
#include "Autogenerated/CNodePoint.h"
#include "Autogenerated/CNodePointGround.h"
#include "Autogenerated/CNodePoint2D.h"
#include "Autogenerated/CNodeRigidBodyEP.h"
#include "Autogenerated/CNodeRigidBody2D.h"
#include "Autogenerated/CNodePoint2DSlope1.h"

#include "Autogenerated/CObjectMassPoint.h"
#include "Autogenerated/CObjectMassPoint2D.h"
#include "Autogenerated/CObjectRigidBody.h"
#include "Autogenerated/CObjectRigidBody2D.h"
#include "Autogenerated/CObjectGround.h"

#include "Autogenerated/CObjectANCFCable2D.h"
#include "Autogenerated/CObjectALEANCFCable2D.h"

#include "Autogenerated/CObjectConnectorSpringDamper.h"
#include "Autogenerated/CObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/CObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/CObjectConnectorDistance.h"
#include "Autogenerated/CObjectConnectorCoordinate.h"
#include "Autogenerated/CObjectContactCoordinate.h"
#include "Autogenerated/CObjectContactCircleCable2D.h"
#include "Autogenerated/CObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/CObjectJointRevolute2D.h"
#include "Autogenerated/CObjectJointPrismatic2D.h"
#include "Autogenerated/CObjectJointSliding2D.h"
#include "Autogenerated/CObjectJointALEMoving2D.h"

#include "Autogenerated/CMarkerBodyPosition.h"
#include "Autogenerated/CMarkerBodyRigid.h"
#include "Autogenerated/CMarkerBodyMass.h"
#include "Autogenerated/CMarkerNodePosition.h"
#include "Autogenerated/CMarkerNodeRigid.h"
#include "Autogenerated/CMarkerBodyCable2DShape.h"
#include "Autogenerated/CMarkerBodyCable2DCoordinates.h"

#include "Autogenerated/CLoadForceVector.h"
#include "Autogenerated/CLoadTorqueVector.h"
#include "Autogenerated/CLoadMassProportional.h"

//! draw a simple spring in 2D with given endpoints p0,p1 a width, a (normalized) normal vector for the width drawing and number of spring points numberOfPoints
void DrawSpring2D(const Vector3D& p0, const Vector3D& p1, const Vector3D& vN, Index numberOfPoints, Real width, const Float4& color, GraphicsData& graphicsData)
{
	//2D drawing in XY plane
	Vector3D v0 = p1 - p0;

	Real L = v0.GetL2Norm(); //length of spring
	Real d = L / (Real)numberOfPoints; //split spring into pieces: shaft, (n-2) parts, end
	if (L != 0.f) { v0 /= L; }

	Vector3D pLast; //for last drawn point
	for (Index i = 0; i <= numberOfPoints; i++)
	{
		Vector3D pAct = p0 + v0 * (float)i*d;
		Real sign = (Real)(i % 2); //sign
		if (i > 1 && i < numberOfPoints - 1) { pAct += width * (sign*2.f - 1.f)* vN; }

		if (i > 0)
		{
			graphicsData.AddLine(pLast, pAct, color, color);
		}

		pLast = pAct;
	}

}

//! draw number for item at selected position and with label, such as 'N' for nodes, etc.
void DrawItemNumber(const Vector3D& pos, VisualizationSystem* vSystem, Index itemNumber, const char* label = "", const Float4& color = Float4({ 0.f,0.f,0.f,1.f }))
{
	float offx = 0.25f; //in text coordinates, relative to textsize
	float offy = 0.25f; //in text coordinates, relative to textsize
	float textSize = 0.f; //use default value
	vSystem->graphicsData.AddText(pos, color, label + EXUstd::ToString(itemNumber), textSize, offx, offy);
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint* cNode = (CNodePoint*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }


	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 3 coordinates per node ...
		ConstSizeVector<maxSize> value; //cable elements have no more than 9 cooordinates ...
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	if (visualizationSettings.nodes.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePointGround::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePointGround* cNode = (CNodePointGround*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 3 coordinates per node ...
		ConstSizeVector<maxSize> value; //cable elements have no more than 9 cooordinates ...
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}


	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	if (visualizationSettings.nodes.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint2D* cNode = (CNodePoint2D*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 3 coordinates per node ... (3D-displacement vector!)
		ConstSizeVector<maxSize> value; 
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	if (visualizationSettings.nodes.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyEP::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyEP* cNode = (CNodeRigidBodyEP*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 8; //max. 7+1 coordinates per node ...
		ConstSizeVector<maxSize> value; 
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	Vector3D vec;
	vec = A * Vector3D({ radius, 0., 0. }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({1.,0.,0.,1.}));

	vec = A * Vector3D({ 0., radius, 0. }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 0.,1.,0.,1. }));

	vec = A * Vector3D({ 0., 0., radius }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 0.,0.,1.,1. }));

	if (visualizationSettings.nodes.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBody2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBody2D* cNode = (CNodeRigidBody2D*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 2+1 coordinates or 3 components per node ...
		ConstSizeVector<maxSize> value; 
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	Vector3D vec;
	//EXUmath::MultMatrixVector(A, Vector3D({ radius, 0., 0. }), vec);
	vec = A * Vector3D({ radius, 0., 0. }); //this vector is to show the orientation of the node
	vSystem->graphicsData.AddLine(pos - vec, pos + vec, currentColor, currentColor);

	//EXUmath::MultMatrixVector(A, Vector3D({ 0., radius, 0. }), vec);
	vec = A * Vector3D({ 0., radius, 0. }); //this vector is to show the orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor);

	if (visualizationSettings.nodes.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint2DSlope1::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint2DSlope1* cNode = (CNodePoint2DSlope1*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	if (visualizationSettings.nodes.showNodalSlopes)
	{
		Vector3D vec;
		//EXUmath::MultMatrixVector(A, Vector3D({ radius, 0., 0. }), vec);
		vec = A * Vector3D({ 8 * radius, 0., 0. }); //this vector is to show the orientation of the node
		vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor);
	}

	if (visualizationSettings.nodes.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}






//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//BODIES


//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectMassPoint::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMassPoint* cObject = (CObjectMassPoint*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	//Float3 pos({ (float)pos3D[0], (float)pos3D[1], (float)pos3D[2] });

	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	//for (GLLine item : graphicsData.glLines) //copy objects
	//{
	//	item.point1[0] += refPos3DF[0]; //add current position of object //LATERON: add rigid body transformation to graphicsData
	//	item.point1[1] += refPos3DF[1]; //add current position of object
	//	item.point1[2] += refPos3DF[2]; //add current position of object
	//	item.point2[0] += refPos3DF[0]; //add current position of object
	//	item.point2[1] += refPos3DF[1]; //add current position of object
	//	item.point2[2] += refPos3DF[2]; //add current position of object
	//	vSystem->graphicsData.glLines.Append(item);
	//}

	if (visualizationSettings.bodies.showNumbers) { DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }

}

void VisualizationObjectMassPoint2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMassPoint2D* cObject = (CObjectMassPoint2D*)vSystem->systemData->GetCObjects()[itemNumber];

	//Vector3D pos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	//Float3 pos({ (float)pos3D[0], (float)pos3D[1], (float)pos3D[2] });

	//for (GLLine item : graphicsData.glLines) //copy objects
	//{
	//	item.point1[0] += pos[0]; //add current position of object //LATERON: add rigid body transformation to graphicsData
	//	item.point1[1] += pos[1]; //add current position of object
	//	item.point1[2] += pos[2]; //add current position of object
	//	item.point2[0] += pos[0]; //add current position of object
	//	item.point2[1] += pos[1]; //add current position of object
	//	item.point2[2] += pos[2]; //add current position of object
	//	vSystem->graphicsData.glLines.Append(item);
	//}
	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	if (visualizationSettings.bodies.showNumbers) { DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectRigidBody::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRigidBody* cObject = (CObjectRigidBody*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);
	Matrix3DF A; A.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, A);

	if (visualizationSettings.bodies.showNumbers) { DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectRigidBody2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRigidBody2D* cObject = (CObjectRigidBody2D*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF;
	refPos3DF.CopyFrom(refPos3D);

	Matrix3DF A;
	A.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, A);

	if (visualizationSettings.bodies.showNumbers) { DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }

}



//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectGround::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectGround* cObject = (CObjectGround*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF;
	refPos3DF.CopyFrom(refPos3D); // ({ (float)pos3D[0], (float)pos3D[1], (float)pos3D[2] });

	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	if (visualizationSettings.bodies.showNumbers) { DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }
}


void VisualizationObjectANCFCable2DBaseUpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber, const Float4& color, float drawHeight)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectANCFCable2DBase* cObject = (CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[itemNumber];

	Index tiling = visualizationSettings.bodies.beams.axialTiling;

	GLLine item;
	if (color[0] != -1.f) { currentColor = color; }

	Real L = cObject->GetLength();
	item.color1 = currentColor;
	item.color2 = currentColor;

	bool contourPlot = false;
	float value1, value2; //values at endpoints, use linear interpolation
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes())
	{
		//ConstSizeVector<9> value; //cable elements have no more than 9 cooordinates ...
		Vector value;
		cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({0.,0.,0.}), ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			value1 = (float)value[visualizationSettings.contour.outputVariableComponent]; //value at x=0
			cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ L,0.,0. }), ConfigurationType::Visualization, value);
			value2 = (float)value[visualizationSettings.contour.outputVariableComponent]; //value at x=L
			item.color1 = Float4({ 0.,0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
			item.color2 = Float4({ 0.,0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
			contourPlot = true;
		}
	}

	//for now, bending stresses/strains are not computed/plotted off-axis!
	Float3 p0[2];
	Float3 p1[2];
	p0[0].CopyFrom(cObject->GetPosition(Vector3D({ 0., (Real)(-drawHeight * 0.5),0. }), ConfigurationType::Visualization));
	p0[1].CopyFrom(cObject->GetPosition(Vector3D({ 0., (Real)(drawHeight * 0.5),0. }), ConfigurationType::Visualization));

	Real deltaX = L / (Real)tiling;
	Index n = 1; //no height
	if (drawHeight != 0.) 
	{ 
		n = 2;
		//first cross section
		item.point1 = p0[0];
		item.point2 = p0[1];
		item.color1[0] = value1;
		item.color2[0] = value1;
		vSystem->graphicsData.glLines.Append(item);
	}

	for (Index j = 0; j < n; j++)
	{
		Real y = drawHeight*(-0.5 + (Real)j);
		for (Index i = 1; i <= tiling; i++)
		{
			Real x = (Real)i / (Real)tiling*L;

			Vector3D pLoc({ x, y, 0. });
			p1[j].CopyFrom(cObject->GetPosition(pLoc, ConfigurationType::Visualization));

			if (contourPlot) 
			{ 
				item.color1[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)(x - deltaX));
				item.color2[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)x);
			}
			item.point1 = p0[j];
			item.point2 = p1[j];
			vSystem->graphicsData.glLines.Append(item);
			p0[j] = p1[j]; //for next line segment
		}
	}
	if (drawHeight != 0.)
	{
		//last cross section
		item.point1 = p1[0];
		item.point2 = p1[1];
		item.color1[0] = value2;
		item.color2[0] = value2;
		vSystem->graphicsData.glLines.Append(item);
	}

	Vector3D pos3D = cObject->GetPosition(Vector3D({ L*0.5,0.,0. }), ConfigurationType::Visualization);
	if (visualizationSettings.bodies.showNumbers) { DrawItemNumber(pos3D, vSystem, itemNumber, "", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectANCFCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	VisualizationObjectANCFCable2DBaseUpdateGraphics(visualizationSettings, vSystem, itemNumber, color, drawHeight);
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectALEANCFCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	VisualizationObjectANCFCable2DBaseUpdateGraphics(visualizationSettings, vSystem, itemNumber, color, drawHeight);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//CONNECTORS

void VisualizationObjectConnectorSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorSpringDamper* cItem = (CObjectConnectorSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	//Index2 markers = Index2({ cItem->GetMarkerNumbers()[0], cItem->GetMarkerNumbers()[1] });
	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }
	//if (!cItem->GetParameters().activeConnector) //if inactive, make the constraint much lighter; or turn to RED?
	//{ currentColor = Float4({ 0.75f+0.25f*currentColor[0],0.75f + 0.25f*currentColor[1],0.75f + 0.25f*currentColor[2],currentColor[3] }); }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D v0 = pos[1] - pos[0]; //vector from p0 to p1
	Vector3D vN({ -v0[1], v0[0], v0[2] });
	Real Ln = vN.GetL2Norm(); //length of normal vector
	if (Ln != 0.f) { vN /= Ln; }

	const Index numberOfPoints = 12;
	DrawSpring2D(pos[0], pos[1], vN, numberOfPoints, r, currentColor, vSystem->graphicsData);

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorCartesianSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCartesianSpringDamper* cItem = (CObjectConnectorCartesianSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D v0 = pos[1] - pos[0]; //vector from p0 to p1

	Vector3D p0, p1, vN, vRel;
	const Index numberOfPoints = 12;

	if (cItem->GetParameters().activeConnector) //does not work in visualization ...
	{
		//draw 3 orthogonal springs
		p0 = pos[0]; p1 = pos[0] + Vector3D({ v0[0],0,0 });		//x-direction
		DrawSpring2D(p0, p1, Vector3D({ 0,1,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
		p0 = p1; p1 = pos[0] + Vector3D({ v0[0],v0[1],0 });		//y-direction
		DrawSpring2D(p0, p1, Vector3D({ 1,0,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
		p0 = p1; p1 = pos[0] + v0;								//z-direction
		DrawSpring2D(p0, p1, Vector3D({ 0,1,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
	}

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorCoordinateSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCoordinateSpringDamper* cItem = (CObjectConnectorCoordinateSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius connectorCoordinate
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D n({ 0,0,1 }); //normal defining the plane in which the 2D spring is drawn
	Vector3D v = pos[1] - pos[0];
	if (fabs(v[2]) > fabs(v[0]) + fabs(v[1])) { n = Vector3D({1.,0.,0.}); }

	const Index numberOfPoints = 12;	
	DrawSpring2D(pos[0], pos[1], n, numberOfPoints, r, currentColor, vSystem->graphicsData);

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorDistance::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorDistance* cItem = (CObjectConnectorDistance*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddLine(pos[0], pos[1], currentColor, currentColor);

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorCoordinate::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCoordinate* cItem = (CObjectConnectorCoordinate*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius connectorCoordinate
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }

}

void VisualizationObjectContactCoordinate::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactCoordinate* cItem = (CObjectContactCoordinate*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius ContactCoordinate
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.contactPointsDefaultSize; } //use default size

		//draw the two according points; change color to red, if contact:
		if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[0] < 0) //this is the gap at the end of the discontinuous iteration
		{
			currentColor = Float4({ 1.,0.,0.,1. }); //red color means contact ...
		}
		vSystem->graphicsData.AddCircleXY(pos[0], r, currentColor);
		vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);
	}

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectContactCircleCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactCircleCable2D* cItem = (CObjectContactCircleCable2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius of contact points
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.contactPointsDefaultSize; } //use default size

		//draw contact circle of first object:
		vSystem->graphicsData.AddCircleXY(pos[0], (float)cItem->GetParameters().circleRadius, currentColor, 64);
		Index nSeg = cItem->GetParameters().numberOfContactSegments;
		Vector3D pContactLast; //previously computed point

		Index objectNum = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
		Real lCable = ((const CObjectANCFCable2D&)vSystem->systemData->GetCObjectBody(objectNum)).GetParameters().physicsLength;

		for (Index i = 0; i <= nSeg; i++)
		{
			Real locPos = (Real)i / (Real)nSeg * lCable;
			Vector3D pContact = vSystem->systemData->GetCObjectBody(objectNum).GetPosition(Vector3D({ locPos, 0, 0 }), ConfigurationType::Visualization);
			vSystem->graphicsData.AddCircleXY(pContact, r, currentColor);

			if (i > 0)
			{
				Float4 contactColor = currentColor;
				//draw the two according points; change color to red, if contact:
				if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[i - 1] < 0) //this is the gap at the end of the discontinuous iteration
				{
					contactColor = Float4({ 1.,0.,0.,1. });
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor);
				} //red color means contact ...

			}
			pContactLast = pContact;
		}
	}

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(pos[1], vSystem, itemNumber, "", currentColor); } //midpoint of ANCF element

}

void VisualizationObjectContactFrictionCircleCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactFrictionCircleCable2D* cItem = (CObjectContactFrictionCircleCable2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius of contact points
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.contactPointsDefaultSize; } //use default size

		//draw contact circle of first object:
		vSystem->graphicsData.AddCircleXY(pos[0], (float)cItem->GetParameters().circleRadius, currentColor, 64);
		Index nSeg = cItem->GetParameters().numberOfContactSegments;
		Vector3D pContactLast; //previously computed point

		Index objectNum = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
		Real lCable = ((const CObjectANCFCable2D&)vSystem->systemData->GetCObjectBody(objectNum)).GetParameters().physicsLength;

		for (Index i = 0; i <= nSeg; i++)
		{
			Real locPos = (Real)i / (Real)nSeg * lCable;
			Vector3D pContact = vSystem->systemData->GetCObjectBody(objectNum).GetPosition(Vector3D({ locPos, 0, 0 }), ConfigurationType::Visualization);
			vSystem->graphicsData.AddCircleXY(pContact, r, currentColor);

			if (i > 0)
			{
				Float4 contactColor = currentColor;
				//draw the two according points; change color to red, if contact:
				if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[i - 1] < 0) //this is the gap at the end of the discontinuous iteration
				{
					contactColor = Float4({ 1.,0.,0.,1. });
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor);
				} //red color means contact ...

			}
			pContactLast = pContact;
		}
	}

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(pos[1], vSystem, itemNumber, "", currentColor); } //midpoint of ANCF element

}

void VisualizationObjectJointRevolute2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointRevolute2D* cItem = (CObjectJointRevolute2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointPrismatic2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointPrismatic2D* cItem = (CObjectJointPrismatic2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);
	vSystem->graphicsData.AddLine(pos[0], pos[1], currentColor, currentColor);

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointSliding2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointSliding2D* cItem = (CObjectJointSliding2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointALEMoving2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointALEMoving2D* cItem = (CObjectJointALEMoving2D*)vSystem->systemData->GetCObjects()[itemNumber];
	
	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! Update visualizationSystem -> graphicsData for item
void VisualizationMarkerBodyPosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyPosition* cMarker = (CMarkerBodyPosition*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyMass::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyMass* cMarker = (CMarkerBodyMass*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor); 
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor); //bodymass-marker has double circle

	if (visualizationSettings.markers.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyRigid* cMarker = (CMarkerBodyRigid*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, -radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({  radius, -radius, 0. }), pos + Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({  radius,  radius, 0. }), pos + Vector3D({-radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius,  radius, 0. }), pos + Vector3D({-radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyCable2DShape::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyCable2DShape* cMarker = (CMarkerBodyCable2DShape*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyCable2DCoordinates::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyCable2DCoordinates* cMarker = (CMarkerBodyCable2DCoordinates*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerNodePosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerNodePosition* cMarker = (CMarkerNodePosition*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerNodeRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerNodeRigid* cMarker = (CMarkerNodeRigid*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, -radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, -radius, 0. }), pos + Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius,  radius, 0. }), pos + Vector3D({ -radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius,  radius, 0. }), pos + Vector3D({ -radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void VisualizationLoadForceVector::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadForceVector* cLoad = (CLoadForceVector*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	Vector3D pos; //global marker position
	if (cMarker->GetType() & Marker::Position) //marker must be able to measure position
	{
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;
		if (visualizationSettings.loads.fixedLoadSize)
		{
			Real L = loadVector.GetL2Norm();
			if (L > 0.) { loadVector *= 1. / L; }
			loadVector *= size;
		}
		else
		{
			loadVector *= visualizationSettings.loads.loadSizeFactor;
		}

		Vector3D n1; //resulting normal vector to loadVector ==> for drawing of arrow
		Vector3D n2;
		EXUmath::ComputeOrthogonalBasis(loadVector, n1, n2);
		Real L = loadVector.GetL2Norm();

		//Vector3D hatOffset({ -0.1*loadVector[1], 0.1*loadVector[0], 0. });
		Vector3D hatOffset = (0.1*L)*n1;

		vSystem->graphicsData.AddLine(pos, pos + loadVector, currentColor, currentColor);
		vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector + hatOffset, currentColor, currentColor);
		vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector - hatOffset, currentColor, currentColor);

		if (visualizationSettings.loads.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "L", currentColor); }
	}
}

void VisualizationLoadMassProportional::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadMassProportional* cLoad = (CLoadMassProportional*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	Vector3D pos; //global marker position
	if (cMarker->GetType() & Marker::BodyMass) //marker must be able to measure position
	{
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;
		//always draw massproportional loads with fixed size
		Real L = loadVector.GetL2Norm();
		if (L > 0.) { loadVector *= 1. / L; }
		loadVector *= size;

		Vector3D n1; //resulting normal vector to loadVector ==> for drawing of arrow
		Vector3D n2;
		EXUmath::ComputeOrthogonalBasis(loadVector, n1, n2);

		//Vector3D hatOffset({ -0.1*loadVector[1], 0.1*loadVector[0], 0. });
		Vector3D hatOffset = (0.1*(Real)size)*n1;

		vSystem->graphicsData.AddLine(pos, pos + loadVector, currentColor, currentColor);
		vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector + hatOffset, currentColor, currentColor);
		vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector - hatOffset, currentColor, currentColor);

		if (visualizationSettings.loads.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "L", currentColor); }
	}
}

void VisualizationLoadTorqueVector::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadTorqueVector* cLoad = (CLoadTorqueVector*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	if ((cMarker->GetType() & Marker::Position) && (cMarker->GetType() & Marker::Orientation)) //marker must be able to measure position and orientation
	{
		Vector3D pos; //global marker position
		Matrix3D rot; //global marker rotation
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);
		cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;
		if (visualizationSettings.loads.fixedLoadSize)
		{
			Real L = loadVector.GetL2Norm();
			if (L > 0.) { loadVector *= 1. / L; }
			loadVector *= size;
		}
		else
		{
			loadVector *= visualizationSettings.loads.loadSizeFactor;
		}

		Vector3D n1; //resulting normal vector to loadVector ==> for drawing of torque
		Vector3D n2;
		EXUmath::ComputeOrthogonalBasis(loadVector, n1, n2);
		Real L = loadVector.GetL2Norm()*0.5; //size is related to diameter

		vSystem->graphicsData.AddPoint(pos, currentColor); //midpoint of torque

		const Real phiInc = 0.075*EXUstd::pi;
		for (Real phi = 0.; phi < 1.49999*EXUstd::pi; phi += phiInc)
		{
			Real x1 = L * cos(phi);
			Real y1 = L * sin(phi);
			Real x2 = L * cos(phi + phiInc);
			Real y2 = L * sin(phi + phiInc);
			vSystem->graphicsData.AddLine(pos + x1*n1 + y1*n2, pos + x2*n1 + y2*n2, currentColor, currentColor);

			if (phi >= 1.49999*EXUstd::pi - phiInc) //draw Arrow
			{
				x1 = L * 1.1 * cos(phi);
				y1 = L * 1.1 * sin(phi);
				vSystem->graphicsData.AddLine(pos + x1 * n1 + y1 * n2, pos + x2 * n1 + y2 * n2, currentColor, currentColor);
				x1 = L * 0.9 * cos(phi);
				y1 = L * 0.9 * sin(phi);
				vSystem->graphicsData.AddLine(pos + x1 * n1 + y1 * n2, pos + x2 * n1 + y2 * n2, currentColor, currentColor);
			}
		}

		if (visualizationSettings.loads.showNumbers) { DrawItemNumber(pos, vSystem, itemNumber, "L", currentColor); }
	}
}


