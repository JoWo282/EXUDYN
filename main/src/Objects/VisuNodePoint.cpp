/** ***********************************************************************************************
* @brief        Implementation for VisualizationNodePoint
*
* @author       Gerstmayr Johannes
* @date         2018-04-18 (generated)
* @date         2019-05-27 (last modfied)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */
#pragma once

#include <ostream>

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h" //includes stdoutput.h
#include "Utilities/BasicFunctions.h"	//includes stdoutput.h


#include "Linalg/BasicLinalg.h"		//includes Vector.h
#include "Graphics/VisualizationSystemContainer.h"
#include "Graphics/VisualizationPrimitives.h"


#include "Autogenerated/VisuNodePoint.h"
#include "Autogenerated/VisuNodePointGround.h"
#include "Autogenerated/VisuNodePoint2D.h"
#include "Autogenerated/VisuNodeRigidBodyEP.h"
#include "Autogenerated/VisuNodeRigidBodyRxyz.h"
#include "Autogenerated/VisuNodeRigidBodyRotVecLG.h"
#include "Autogenerated/VisuNodeRigidBody2D.h"
#include "Autogenerated/VisuNodePoint2DSlope1.h"

#include "Autogenerated/VisuObjectMassPoint.h"
#include "Autogenerated/VisuObjectMassPoint2D.h"
#include "Autogenerated/VisuObjectRigidBody.h"
#include "Autogenerated/VisuObjectRigidBody2D.h"
#include "Autogenerated/VisuObjectGround.h"

#include "Autogenerated/VisuObjectANCFCable2D.h"
#include "Autogenerated/VisuObjectALEANCFCable2D.h"

#include "Autogenerated/VisuObjectConnectorSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorRigidBodySpringDamper.h"
#include "Autogenerated/VisuObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/VisuObjectConnectorDistance.h"
#include "Autogenerated/VisuObjectConnectorCoordinate.h"
#include "Autogenerated/VisuObjectContactCoordinate.h"
#include "Autogenerated/VisuObjectContactCircleCable2D.h"
#include "Autogenerated/VisuObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/VisuObjectJointGeneric.h"
#include "Autogenerated/VisuObjectJointRevolute2D.h"
#include "Autogenerated/VisuObjectJointPrismatic2D.h"
#include "Autogenerated/VisuObjectJointSliding2D.h"
#include "Autogenerated/VisuObjectJointALEMoving2D.h"

#include "Autogenerated/VisuMarkerBodyPosition.h"
#include "Autogenerated/VisuMarkerBodyRigid.h"
#include "Autogenerated/VisuMarkerBodyMass.h"
#include "Autogenerated/VisuMarkerNodePosition.h"
#include "Autogenerated/VisuMarkerNodeRigid.h"
#include "Autogenerated/VisuMarkerBodyCable2DShape.h"
#include "Autogenerated/VisuMarkerBodyCable2DCoordinates.h"

#include "Autogenerated/VisuLoadForceVector.h"
#include "Autogenerated/VisuLoadTorqueVector.h"
#include "Autogenerated/VisuLoadMassProportional.h"

#include "Autogenerated/VisuSensorNode.h"
#include "Autogenerated/VisuSensorBody.h"
#include "Autogenerated/VisuSensorObject.h"

//++++++++++++++++++++++++++
//should not be needed, appropriate functions added to visualization objects
#include "Autogenerated/CNodePoint.h"
#include "Autogenerated/CNodePointGround.h"
#include "Autogenerated/CNodePoint2D.h"
#include "Autogenerated/CNodeRigidBodyEP.h"
#include "Autogenerated/CNodeRigidBodyRxyz.h"
#include "Autogenerated/CNodeRigidBodyRotVecLG.h"
#include "Autogenerated/CNodeRigidBody2D.h"
#include "Autogenerated/CNodePoint2DSlope1.h"

#include "Autogenerated/CObjectMassPoint.h"
#include "Autogenerated/CObjectMassPoint2D.h"
#include "Autogenerated/CObjectRigidBody.h"
#include "Autogenerated/CObjectRigidBody2D.h"
#include "Autogenerated/CObjectGround.h"

#include "Autogenerated/CObjectANCFCable2D.h"
#include "Autogenerated/CObjectALEANCFCable2D.h"

#include "Autogenerated/CObjectConnectorSpringDamper.h"
#include "Autogenerated/CObjectConnectorCartesianSpringDamper.h"
#include "Autogenerated/CObjectConnectorRigidBodySpringDamper.h"
#include "Autogenerated/CObjectConnectorCoordinateSpringDamper.h"
#include "Autogenerated/CObjectConnectorDistance.h"
#include "Autogenerated/CObjectConnectorCoordinate.h"
#include "Autogenerated/CObjectContactCoordinate.h"
#include "Autogenerated/CObjectContactCircleCable2D.h"
#include "Autogenerated/CObjectContactFrictionCircleCable2D.h"
#include "Autogenerated/CObjectJointGeneric.h"
#include "Autogenerated/CObjectJointRevolute2D.h"
#include "Autogenerated/CObjectJointPrismatic2D.h"
#include "Autogenerated/CObjectJointSliding2D.h"
#include "Autogenerated/CObjectJointALEMoving2D.h"

#include "Autogenerated/CMarkerBodyPosition.h"
#include "Autogenerated/CMarkerBodyRigid.h"
#include "Autogenerated/CMarkerBodyMass.h"
#include "Autogenerated/CMarkerNodePosition.h"
#include "Autogenerated/CMarkerNodeRigid.h"
#include "Autogenerated/CMarkerBodyCable2DShape.h"
#include "Autogenerated/CMarkerBodyCable2DCoordinates.h"

#include "Autogenerated/CLoadForceVector.h"
#include "Autogenerated/CLoadTorqueVector.h"
#include "Autogenerated/CLoadMassProportional.h"

//#include "Autogenerated/CSensorNode.h" //unused
#include "Autogenerated/CSensorBody.h"
#include "Autogenerated/CSensorObject.h"

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint* cNode = (CNodePoint*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }


	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 3 coordinates per node ...
		ConstSizeVector<maxSize> value; //cable elements have no more than 9 cooordinates ...
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePointGround::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePointGround* cNode = (CNodePointGround*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 3 coordinates per node ...
		ConstSizeVector<maxSize> value; //cable elements have no more than 9 cooordinates ...
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}


	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint2D* cNode = (CNodePoint2D*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));

	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 3 coordinates per node ... (3D-displacement vector!)
		ConstSizeVector<maxSize> value; 
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyEP::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyEP* cNode = (CNodeRigidBodyEP*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 8; //max. 7+1 coordinates per node ...
		ConstSizeVector<maxSize> value; 
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	Vector3D vec;
	vec = A * Vector3D({ radius, 0., 0. }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({1.,0.,0.,1.}));

	vec = A * Vector3D({ 0., radius, 0. }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 0.,1.,0.,1. }));

	vec = A * Vector3D({ 0., 0., radius }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 0.,0.,1.,1. }));

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyRxyz::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyRxyz* cNode = (CNodeRigidBodyRxyz*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 8; //max. 7+1 coordinates per node ...
		ConstSizeVector<maxSize> value;
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	Vector3D vec;
	vec = A * Vector3D({ radius, 0., 0. }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 1.,0.,0.,1. }));

	vec = A * Vector3D({ 0., radius, 0. }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 0.,1.,0.,1. }));

	vec = A * Vector3D({ 0., 0., radius }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 0.,0.,1.,1. }));

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBodyRotVecLG::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBodyRotVecLG* cNode = (CNodeRigidBodyRotVecLG*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 8; //max. 7+1 coordinates per node ...
		ConstSizeVector<maxSize> value;
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	Vector3D vec;
	vec = A * Vector3D({ radius, 0., 0. }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 1.,0.,0.,1. }));

	vec = A * Vector3D({ 0., radius, 0. }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 0.,1.,0.,1. }));

	vec = A * Vector3D({ 0., 0., radius }); //this vector is to show the 3D orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, Float4({ 0.,0.,1.,1. }));

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodeRigidBody2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodeRigidBody2D* cNode = (CNodeRigidBody2D*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	//add contour plot values to color:
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cNode->GetOutputVariableTypes())
	{
		const Index maxSize = 3; //max. 2+1 coordinates or 3 components per node ...
		ConstSizeVector<maxSize> value; 
		//Vector value;
		cNode->GetOutputVariable(visualizationSettings.contour.outputVariable, ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			float contourValue = (float)value[visualizationSettings.contour.outputVariableComponent];
			currentColor = Float4({ contourValue, 0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
		}
	}

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	Vector3D vec;
	//EXUmath::MultMatrixVector(A, Vector3D({ radius, 0., 0. }), vec);
	vec = A * Vector3D({ radius, 0., 0. }); //this vector is to show the orientation of the node
	vSystem->graphicsData.AddLine(pos - vec, pos + vec, currentColor, currentColor);

	//EXUmath::MultMatrixVector(A, Vector3D({ 0., radius, 0. }), vec);
	vec = A * Vector3D({ 0., radius, 0. }); //this vector is to show the orientation of the node
	vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor);

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationNodePoint2DSlope1::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.nodes.defaultColor;

	CNodePoint2DSlope1* cNode = (CNodePoint2DSlope1*)vSystem->systemData->GetCNodes()[itemNumber];

	if (color[0] != -1.f) { currentColor = color; }

	float radius = 0.5f*drawSize; //drawSize represents diameter/cube edge length
	if (drawSize == -1.f) { radius = 0.5f*visualizationSettings.nodes.defaultSize; } //use default size
	if (visualizationSettings.nodes.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; } //{ radius = 0.5f*vSystem->rendererState.maxSceneSize * 0.002f; }

	Vector3D pos(cNode->GetPosition(ConfigurationType::Visualization));
	Matrix3D A(cNode->GetRotationMatrix(ConfigurationType::Visualization));

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

	if (visualizationSettings.nodes.showNodalSlopes)
	{
		Vector3D vec;
		//EXUmath::MultMatrixVector(A, Vector3D({ radius, 0., 0. }), vec);
		vec = A * Vector3D({ 8 * radius, 0., 0. }); //this vector is to show the orientation of the node
		vSystem->graphicsData.AddLine(pos, pos + vec, currentColor, currentColor);
	}

	if (visualizationSettings.nodes.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "N", currentColor); }
}






//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//BODIES


//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectMassPoint::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMassPoint* cObject = (CObjectMassPoint*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	//Float3 pos({ (float)pos3D[0], (float)pos3D[1], (float)pos3D[2] });

	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	//for (GLLine item : graphicsData.glLines) //copy objects
	//{
	//	item.point1[0] += refPos3DF[0]; //add current position of object //LATERON: add rigid body transformation to graphicsData
	//	item.point1[1] += refPos3DF[1]; //add current position of object
	//	item.point1[2] += refPos3DF[2]; //add current position of object
	//	item.point2[0] += refPos3DF[0]; //add current position of object
	//	item.point2[1] += refPos3DF[1]; //add current position of object
	//	item.point2[2] += refPos3DF[2]; //add current position of object
	//	vSystem->graphicsData.glLines.Append(item);
	//}

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }

}

void VisualizationObjectMassPoint2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectMassPoint2D* cObject = (CObjectMassPoint2D*)vSystem->systemData->GetCObjects()[itemNumber];

	//Vector3D pos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	//Float3 pos({ (float)pos3D[0], (float)pos3D[1], (float)pos3D[2] });

	//for (GLLine item : graphicsData.glLines) //copy objects
	//{
	//	item.point1[0] += pos[0]; //add current position of object //LATERON: add rigid body transformation to graphicsData
	//	item.point1[1] += pos[1]; //add current position of object
	//	item.point1[2] += pos[2]; //add current position of object
	//	item.point2[0] += pos[0]; //add current position of object
	//	item.point2[1] += pos[1]; //add current position of object
	//	item.point2[2] += pos[2]; //add current position of object
	//	vSystem->graphicsData.glLines.Append(item);
	//}
	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectRigidBody::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRigidBody* cObject = (CObjectRigidBody*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF; refPos3DF.CopyFrom(refPos3D);
	Matrix3DF A; A.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, A);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectRigidBody2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectRigidBody2D* cObject = (CObjectRigidBody2D*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF;
	refPos3DF.CopyFrom(refPos3D);

	Matrix3DF A;
	A.CopyFrom(cObject->GetRotationMatrix(Vector3D(0.), ConfigurationType::Visualization));

	//transform graphics data with rigid body transformation (includes lines, triangles, points, ...)
	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, A);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }

}



//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectGround::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectGround* cObject = (CObjectGround*)vSystem->systemData->GetCObjects()[itemNumber];

	Vector3D refPos3D = cObject->GetPosition(Vector3D(0.), ConfigurationType::Visualization);
	Float3 refPos3DF;
	refPos3DF.CopyFrom(refPos3D); // ({ (float)pos3D[0], (float)pos3D[1], (float)pos3D[2] });

	AddBodyGraphicsData(graphicsData, vSystem->graphicsData, refPos3DF, EXUmath::unitMatrix3DF);

	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(refPos3D, vSystem, itemNumber, "", currentColor); }
}


void VisualizationObjectANCFCable2DBaseUpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber, const Float4& color, float drawHeight)
{
	Float4 currentColor = visualizationSettings.bodies.defaultColor;

	CObjectANCFCable2DBase* cObject = (CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[itemNumber];

	Index tiling = visualizationSettings.bodies.beams.axialTiling;

	GLLine item;
	if (color[0] != -1.f) { currentColor = color; }

	Real L = cObject->GetLength();
	item.color1 = currentColor;
	item.color2 = currentColor;

	bool contourPlot = false;
	float value1, value2; //values at endpoints, use linear interpolation
	if ((Index)visualizationSettings.contour.outputVariable & (Index)cObject->GetOutputVariableTypes())
	{
		//ConstSizeVector<9> value; //cable elements have no more than 9 cooordinates ...
		Vector value;
		cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({0.,0.,0.}), ConfigurationType::Visualization, value);
		if (visualizationSettings.contour.outputVariableComponent < value.NumberOfItems())
		{
			value1 = (float)value[visualizationSettings.contour.outputVariableComponent]; //value at x=0
			cObject->GetOutputVariableBody(visualizationSettings.contour.outputVariable, Vector3D({ L,0.,0. }), ConfigurationType::Visualization, value);
			value2 = (float)value[visualizationSettings.contour.outputVariableComponent]; //value at x=L
			item.color1 = Float4({ 0.,0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
			item.color2 = Float4({ 0.,0.,0.,vSystem->contourPlotFlag }); //transparency of -2. indicates a contour value ... hack!
			contourPlot = true;
		}
	}

	//for now, bending stresses/strains are not computed/plotted off-axis!
	Float3 p0[2];
	Float3 p1[2];
	p0[0].CopyFrom(cObject->GetPosition(Vector3D({ 0., (Real)(-drawHeight * 0.5),0. }), ConfigurationType::Visualization));
	p0[1].CopyFrom(cObject->GetPosition(Vector3D({ 0., (Real)(drawHeight * 0.5),0. }), ConfigurationType::Visualization));

	Real deltaX = L / (Real)tiling;
	Index n = 1; //no height
	if (drawHeight != 0.) 
	{ 
		n = 2;
		//first cross section
		item.point1 = p0[0];
		item.point2 = p0[1];
		item.color1[0] = value1;
		item.color2[0] = value1;
		vSystem->graphicsData.glLines.Append(item);
	}

	for (Index j = 0; j < n; j++)
	{
		Real y = drawHeight*(-0.5 + (Real)j);
		for (Index i = 1; i <= tiling; i++)
		{
			Real x = (Real)i / (Real)tiling*L;

			Vector3D pLoc({ x, y, 0. });
			p1[j].CopyFrom(cObject->GetPosition(pLoc, ConfigurationType::Visualization));

			if (contourPlot) 
			{ 
				item.color1[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)(x - deltaX));
				item.color2[0] = (float)EXUstd::LinearInterpolate(value1, value2, 0, (float)L, (float)x);
			}
			item.point1 = p0[j];
			item.point2 = p1[j];
			vSystem->graphicsData.glLines.Append(item);
			p0[j] = p1[j]; //for next line segment
		}
	}
	if (drawHeight != 0.)
	{
		//last cross section
		item.point1 = p1[0];
		item.point2 = p1[1];
		item.color1[0] = value2;
		item.color2[0] = value2;
		vSystem->graphicsData.glLines.Append(item);
	}

	Vector3D pos3D = cObject->GetPosition(Vector3D({ L*0.5,0.,0. }), ConfigurationType::Visualization);
	if (visualizationSettings.bodies.showNumbers) { EXUvis::DrawItemNumber(pos3D, vSystem, itemNumber, "", currentColor); }

}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectANCFCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	VisualizationObjectANCFCable2DBaseUpdateGraphics(visualizationSettings, vSystem, itemNumber, color, drawHeight);
}

//! Update visualizationSystem -> graphicsData for item
void VisualizationObjectALEANCFCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	VisualizationObjectANCFCable2DBaseUpdateGraphics(visualizationSettings, vSystem, itemNumber, color, drawHeight);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//CONNECTORS

void VisualizationObjectConnectorSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorSpringDamper* cItem = (CObjectConnectorSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	//Index2 markers = Index2({ cItem->GetMarkerNumbers()[0], cItem->GetMarkerNumbers()[1] });
	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }
	//if (!cItem->GetParameters().activeConnector) //if inactive, make the constraint much lighter; or turn to RED?
	//{ currentColor = Float4({ 0.75f+0.25f*currentColor[0],0.75f + 0.25f*currentColor[1],0.75f + 0.25f*currentColor[2],currentColor[3] }); }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D v0 = pos[1] - pos[0]; //vector from p0 to p1
	Vector3D vN({ -v0[1], v0[0], v0[2] });
	Real Ln = vN.GetL2Norm(); //length of normal vector
	if (Ln != 0.f) { vN /= Ln; }

	const Index numberOfPoints = 12;
	EXUvis::DrawSpring2D(pos[0], pos[1], vN, numberOfPoints, r, currentColor, vSystem->graphicsData);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorCartesianSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCartesianSpringDamper* cItem = (CObjectConnectorCartesianSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D v0 = pos[1] - pos[0]; //vector from p0 to p1

	Vector3D p0, p1, vN, vRel;
	const Index numberOfPoints = 12;

	if (cItem->GetParameters().activeConnector) //does not work in visualization ...
	{
		//draw 3 orthogonal springs
		p0 = pos[0]; p1 = pos[0] + Vector3D({ v0[0],0,0 });		//x-direction
		EXUvis::DrawSpring2D(p0, p1, Vector3D({ 0,1,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
		p0 = p1; p1 = pos[0] + Vector3D({ v0[0],v0[1],0 });		//y-direction
		EXUvis::DrawSpring2D(p0, p1, Vector3D({ 1,0,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
		p0 = p1; p1 = pos[0] + v0;								//z-direction
		EXUvis::DrawSpring2D(p0, p1, Vector3D({ 0,1,0 }), numberOfPoints, r, currentColor, vSystem->graphicsData);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorRigidBodySpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorRigidBodySpringDamper* cItem = (CObjectConnectorRigidBodySpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (color[0] != -1.f) { currentColor = color; }
	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	//draw as sphere with drawSize ...
	EXUvis::DrawSphere(pos[0], r, currentColor, vSystem->graphicsData, visualizationSettings.general.sphereTiling);
	EXUvis::DrawSphere(pos[1], r, EXUvis::ModifyColor(currentColor, EXUvis::modifyColorFactor), vSystem->graphicsData, visualizationSettings.general.sphereTiling);
	EXUvis::DrawCylinder(pos[0], pos[1]-pos[0], 0.8*r, currentColor, vSystem->graphicsData, visualizationSettings.general.cylinderTiling);

	if (visualizationSettings.connectors.showJointAxes)
	{
		Matrix3D rot[2];
		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
		vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

		//add marker rotation here!
		rot[0] = rot[0] * cItem->GetParameters().rotationMarker0;
		rot[1] = rot[1] * cItem->GetParameters().rotationMarker1;

		EXUvis::DrawOrthonormalBasis(pos[0], rot[0], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, vSystem->graphicsData, 1.f, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
		EXUvis::DrawOrthonormalBasis(pos[1], rot[1], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, vSystem->graphicsData, EXUvis::modifyColorFactor, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}


void VisualizationObjectConnectorCoordinateSpringDamper::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCoordinateSpringDamper* cItem = (CObjectConnectorCoordinateSpringDamper*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius connectorCoordinate
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D n({ 0,0,1 }); //normal defining the plane in which the 2D spring is drawn
	Vector3D v = pos[1] - pos[0];
	if (fabs(v[2]) > fabs(v[0]) + fabs(v[1])) { n = Vector3D({1.,0.,0.}); }

	const Index numberOfPoints = 12;	
	EXUvis::DrawSpring2D(pos[0], pos[1], n, numberOfPoints, r, currentColor, vSystem->graphicsData);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorDistance::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorDistance* cItem = (CObjectConnectorDistance*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddLine(pos[0], pos[1], currentColor, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectConnectorCoordinate::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectConnectorCoordinate* cItem = (CObjectConnectorCoordinate*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius connectorCoordinate
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }

}

void VisualizationObjectContactCoordinate::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactCoordinate* cItem = (CObjectContactCoordinate*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius ContactCoordinate
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.contactPointsDefaultSize; } //use default size

		//draw the two according points; change color to red, if contact:
		if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[0] < 0) //this is the gap at the end of the discontinuous iteration
		{
			currentColor = Float4({ 1.,0.,0.,1. }); //red color means contact ...
		}
		vSystem->graphicsData.AddCircleXY(pos[0], r, currentColor);
		vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectContactCircleCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactCircleCable2D* cItem = (CObjectContactCircleCable2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius of contact points
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.contactPointsDefaultSize; } //use default size

		//draw contact circle of first object:
		vSystem->graphicsData.AddCircleXY(pos[0], (float)cItem->GetParameters().circleRadius, currentColor, 64);
		Index nSeg = cItem->GetParameters().numberOfContactSegments;
		Vector3D pContactLast; //previously computed point

		Index objectNum = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
		Real lCable = ((const CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[objectNum])->GetLength();//GetParameters().physicsLength;

		for (Index i = 0; i <= nSeg; i++)
		{
			Real locPos = (Real)i / (Real)nSeg * lCable;
			Vector3D pContact = vSystem->systemData->GetCObjectBody(objectNum).GetPosition(Vector3D({ locPos, 0, 0 }), ConfigurationType::Visualization);
			vSystem->graphicsData.AddCircleXY(pContact, r, currentColor);

			if (i > 0)
			{
				Float4 contactColor = currentColor;
				//draw the two according points; change color to red, if contact:
				if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[i - 1] < 0) //this is the gap at the end of the discontinuous iteration
				{
					contactColor = Float4({ 1.,0.,0.,1. });
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor);
				} //red color means contact ...

			}
			pContactLast = pContact;
		}
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemNumber, "", currentColor); } //midpoint of ANCF element

}

void VisualizationObjectContactFrictionCircleCable2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectContactFrictionCircleCable2D* cItem = (CObjectContactFrictionCircleCable2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	if (visualizationSettings.connectors.showContact)
	{
		if (color[0] != -1.f) { currentColor = color; }

		float r = 0.5f*drawSize; //radius of contact points
		if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.contactPointsDefaultSize; } //use default size

		//draw contact circle of first object:
		vSystem->graphicsData.AddCircleXY(pos[0], (float)cItem->GetParameters().circleRadius, currentColor, 64);
		Index nSeg = cItem->GetParameters().numberOfContactSegments;
		Vector3D pContactLast; //previously computed point

		Index objectNum = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
		//Real lCable = ((const CObjectANCFCable2D&)vSystem->systemData->GetCObjectBody(objectNum)).GetParameters().physicsLength;
		Real lCable = ((const CObjectANCFCable2DBase*)vSystem->systemData->GetCObjects()[objectNum])->GetLength();//GetParameters().physicsLength;

		for (Index i = 0; i <= nSeg; i++)
		{
			Real locPos = (Real)i / (Real)nSeg * lCable;
			Vector3D pContact = vSystem->systemData->GetCObjectBody(objectNum).GetPosition(Vector3D({ locPos, 0, 0 }), ConfigurationType::Visualization);
			vSystem->graphicsData.AddCircleXY(pContact, r, currentColor);

			if (i > 0)
			{
				Float4 contactColor = currentColor;
				//draw the two according points; change color to red, if contact:
				if (cItem->GetCNode(0)->GetVisualizationCoordinateVector()[i - 1] < 0) //this is the gap at the end of the discontinuous iteration
				{
					contactColor = Float4({ 1.,0.,0.,1. });
					vSystem->graphicsData.AddLine(pContact, pContactLast, contactColor, contactColor);
				} //red color means contact ...

			}
			pContactLast = pContact;
		}
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(pos[1], vSystem, itemNumber, "", currentColor); } //midpoint of ANCF element

}

void VisualizationObjectJointGeneric::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointGeneric* cItem = (CObjectJointGeneric*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Matrix3D rot[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetRotationMatrix(*vSystem->systemData, rot[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetRotationMatrix(*vSystem->systemData, rot[1], ConfigurationType::Visualization);

	rot[0] = rot[0] * cItem->GetParameters().rotationMarker0;
	rot[1] = rot[1] * cItem->GetParameters().rotationMarker1;

	if (color[0] != -1.f) { currentColor = color; }

	Index axesConstrained = cItem->GetParameters().constrainedAxes[3] + cItem->GetParameters().constrainedAxes[4] + cItem->GetParameters().constrainedAxes[5];

	//... add drawings for translational joints ...

	if (axesConstrained == 3) //rigid configuration, draw as sphere
	{
		EXUvis::DrawSphere(pos[0], 0.5*axesRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, visualizationSettings.general.sphereTiling);
		EXUvis::DrawSphere(pos[1], 0.5*axesRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.sphereTiling); 
	}
	else if (axesConstrained == 2) //revolute or cylindrical joint
	{
		for (Index i = 0; i < 3; i++)
		{
			if (cItem->GetParameters().constrainedAxes[3 + i] == 0)
			{
				Vector3D v = rot[0].GetColumnVector<3>(i);
				EXUvis::DrawCylinder(pos[0] - 0.6*axesLength*v, 1.2*axesLength*v, 0.5*axesRadius, EXUvis::ModifyColor(currentColor, 0.25), vSystem->graphicsData, visualizationSettings.general.cylinderTiling); //axis attached to marker0
				EXUvis::DrawCylinder(pos[1] - 0.5*axesLength*v, axesLength*v, axesRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.cylinderTiling, 0.75*axesRadius); //hinge attached to marker1
			}
		}
	}
	else if (axesConstrained == 1) //revolute or cylindrical joint
	{
		Index offset = 0; //for second body
		for (Index i = 0; i < 3; i++)
		{
			if (cItem->GetParameters().constrainedAxes[3 + i] == 0)
			{
				Vector3D v = rot[offset].GetColumnVector<3>(i);
				EXUvis::DrawCylinder(pos[offset] - 0.6*axesLength*v, 1.2*axesLength*v, 0.5*axesRadius, EXUvis::ModifyColor(currentColor, 1.f-0.75f*offset), 
					vSystem->graphicsData, visualizationSettings.general.cylinderTiling); //axis attached to marker0
				offset++;
			}
		}
	}
	if (visualizationSettings.connectors.showJointAxes)
	{
		EXUvis::DrawOrthonormalBasis(pos[0], rot[0], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, vSystem->graphicsData, 1.f, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
		EXUvis::DrawOrthonormalBasis(pos[1], rot[1], visualizationSettings.connectors.jointAxesLength*1.5, 0.25*visualizationSettings.connectors.jointAxesRadius, vSystem->graphicsData, EXUvis::modifyColorFactor, visualizationSettings.openGL.showFaces, visualizationSettings.general.axesTiling);
	}

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}


void VisualizationObjectJointRevolute2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointRevolute2D* cItem = (CObjectJointRevolute2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointPrismatic2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointPrismatic2D* cItem = (CObjectJointPrismatic2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);
	vSystem->graphicsData.AddLine(pos[0], pos[1], currentColor, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointSliding2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointSliding2D* cItem = (CObjectJointSliding2D*)vSystem->systemData->GetCObjects()[itemNumber];

	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);


	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));
	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}

void VisualizationObjectJointALEMoving2D::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.connectors.defaultColor;

	CObjectJointALEMoving2D* cItem = (CObjectJointALEMoving2D*)vSystem->systemData->GetCObjects()[itemNumber];
	
	const ArrayIndex& markerNumbers = cItem->GetMarkerNumbers();

	Vector3D pos[2];
	//moving body position:
	vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[0]]->GetPosition(*vSystem->systemData, pos[0], ConfigurationType::Visualization);
	
	//marker1 (ANCF) does not provide current positino, but only ANCF coordinates ...
	//vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetPosition(*vSystem->systemData, pos[1], ConfigurationType::Visualization);

	Index nALEANCF = vSystem->systemData->GetCMarkers()[cItem->GetMarkerNumbers()[1]]->GetObjectNumber();
	const CObjectALEANCFCable2D& cable = (const CObjectALEANCFCable2D&)vSystem->systemData->GetCObjectBody(nALEANCF);

	//compute ANCF coordinates:
	const Index ns = 4;
	ConstSizeVector<ns> qNode0;
	ConstSizeVector<ns> qNode1;

	qNode0.CopyFrom(cable.GetCNode(0)->GetCoordinateVector(ConfigurationType::Visualization)); //displacement coordinates node 0
	qNode1.CopyFrom(cable.GetCNode(1)->GetCoordinateVector(ConfigurationType::Visualization)); //displacement coordinates node 1

	qNode0 += ((CNodeODE2*)cable.GetCNode(0))->GetReferenceCoordinateVector(); //reference coordinates + displacements
	qNode1 += ((CNodeODE2*)cable.GetCNode(1))->GetReferenceCoordinateVector();

	//compute sliding position:
	Real L = cable.GetParameters().physicsLength;

	//compute sliding coordinate
	Real slidingCoordinate = cItem->GetCNode(1)->GetCoordinateVector(ConfigurationType::Visualization)[0]
		+ cItem->GetParameters().slidingOffset; //this is the global (Eulerian) sliding position

	Index slidingMarkerIndex = (Index)cItem->GetCNode(0)->GetCoordinateVector(ConfigurationType::Visualization)[0]; //this contains the current index in the cable marker list; slidingMarkerIndex will always be in valid range!

	slidingCoordinate -= cItem->GetParameters().slidingMarkerOffsets[slidingMarkerIndex]; //slidingPos now ranges from 0 to L in current cable element

	//draw sliding position:
	Vector4D SV = CObjectANCFCable2D::ComputeShapeFunctions(slidingCoordinate, L);
	Vector2D slidingPosition = CObjectANCFCable2D::MapCoordinates(SV, qNode0, qNode1);
	pos[1] = { slidingPosition[0],slidingPosition[1],0 };
	//std::cout << "pos1=" << pos[1] << ",pos0=" << pos[0] << "\n";

	if (color[0] != -1.f) { currentColor = color; }

	float r = 0.5f*drawSize; //radius of spring
	if (drawSize == -1.f) { r = 0.5f*visualizationSettings.connectors.defaultSize; } //use default size

	Vector3D vy({ 0,r,0 });
	Vector3D vx({ r,0,0 });
	vSystem->graphicsData.AddCircleXY(pos[0], r, Float4({ 1.,0.,0.,1. }));

	vSystem->graphicsData.AddCircleXY(pos[1], r, currentColor);
	vSystem->graphicsData.AddLine(pos[1] - vx, pos[1] + vx, currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos[1] - vy, pos[1] + vy, currentColor, currentColor);

	if (visualizationSettings.connectors.showNumbers) { EXUvis::DrawItemNumber(0.5*(pos[0] + pos[1]), vSystem, itemNumber, "", currentColor); }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! Update visualizationSystem -> graphicsData for item
void VisualizationMarkerBodyPosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyPosition* cMarker = (CMarkerBodyPosition*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyMass::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyMass* cMarker = (CMarkerBodyMass*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor); 
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor); //bodymass-marker has double circle

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyRigid* cMarker = (CMarkerBodyRigid*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, -radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({  radius, -radius, 0. }), pos + Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({  radius,  radius, 0. }), pos + Vector3D({-radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius,  radius, 0. }), pos + Vector3D({-radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyCable2DShape::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyCable2DShape* cMarker = (CMarkerBodyCable2DShape*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerBodyCable2DCoordinates::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerBodyCable2DCoordinates* cMarker = (CMarkerBodyCable2DCoordinates*)vSystem->systemData->GetCMarkers()[itemNumber];
	//CObjectBody* cBody = &vSystem->systemData->GetCObjectBody(cMarker->GetObjectNumber());

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerNodePosition::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerNodePosition* cMarker = (CMarkerNodePosition*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, radius, 0. }), pos - Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

void VisualizationMarkerNodeRigid::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.markers.defaultColor;

	CMarkerNodeRigid* cMarker = (CMarkerNodeRigid*)vSystem->systemData->GetCMarkers()[itemNumber];

	Vector3D pos; //global marker position
	cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

	float radius = 0.5f*visualizationSettings.markers.defaultSize;
	if (visualizationSettings.markers.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	radius /= sqrt(2.f);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius, -radius, 0. }), pos + Vector3D({ radius, -radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius, -radius, 0. }), pos + Vector3D({ radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ radius,  radius, 0. }), pos + Vector3D({ -radius, radius, 0. }), currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos + Vector3D({ -radius,  radius, 0. }), pos + Vector3D({ -radius, -radius, 0. }), currentColor, currentColor);

	if (visualizationSettings.markers.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "M", currentColor); }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++  LOADS  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void VisualizationLoadForceVector::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadForceVector* cLoad = (CLoadForceVector*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	Vector3D pos; //global marker position
	if (cMarker->GetType() & Marker::Position) //marker must be able to measure position
	{
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;

		if (cLoad->IsBodyFixed()) //transform load from local to global coordinates for drawing
		{
			Matrix3D rot;
			cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);
			loadVector = rot * loadVector;
		}

		if (visualizationSettings.loads.fixedLoadSize)
		{
			Real L = loadVector.GetL2Norm();
			if (L > 0.) { loadVector *= 1. / L; }
			loadVector *= size;
		}
		else
		{
			loadVector *= visualizationSettings.loads.loadSizeFactor;
		}


		if (visualizationSettings.openGL.showFaces) //show in 3D
		{
			EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.axesTiling);
		}
		else
		{
			Vector3D n1; //resulting normal vector to loadVector ==> for drawing of arrow
			Vector3D n2;
			EXUmath::ComputeOrthogonalBasis(loadVector, n1, n2);
			Real L = loadVector.GetL2Norm();

			//Vector3D hatOffset({ -0.1*loadVector[1], 0.1*loadVector[0], 0. });
			Vector3D hatOffset = (0.1*L)*n1;

			vSystem->graphicsData.AddLine(pos, pos + loadVector, currentColor, currentColor);
			vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector + hatOffset, currentColor, currentColor);
			vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector - hatOffset, currentColor, currentColor);
		}

		if (visualizationSettings.loads.showNumbers) { EXUvis::DrawItemNumber(pos+loadVector, vSystem, itemNumber, "L", currentColor); }
	}
}

void VisualizationLoadMassProportional::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadMassProportional* cLoad = (CLoadMassProportional*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	Vector3D pos; //global marker position
	if (cMarker->GetType() & Marker::BodyMass) //marker must be able to measure position
	{
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;
		//always draw massproportional loads with fixed size
		Real L = loadVector.GetL2Norm();
		if (L > 0.) { loadVector *= 1. / L; }
		loadVector *= size;

		if (visualizationSettings.openGL.showFaces) //show in 3D
		{
			EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.axesTiling);
		}
		else
		{
			Vector3D n1; //resulting normal vector to loadVector ==> for drawing of arrow
			Vector3D n2;
			EXUmath::ComputeOrthogonalBasis(loadVector, n1, n2);

			//Vector3D hatOffset({ -0.1*loadVector[1], 0.1*loadVector[0], 0. });
			Vector3D hatOffset = (0.1*(Real)size)*n1;

			vSystem->graphicsData.AddLine(pos, pos + loadVector, currentColor, currentColor);
			vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector + hatOffset, currentColor, currentColor);
			vSystem->graphicsData.AddLine(pos + loadVector, pos + 0.8*loadVector - hatOffset, currentColor, currentColor);
		}
		if (visualizationSettings.loads.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "L", currentColor); }
	}
}

void VisualizationLoadTorqueVector::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.loads.defaultColor;

	CLoadTorqueVector* cLoad = (CLoadTorqueVector*)vSystem->systemData->GetCLoads()[itemNumber];
	CMarker* cMarker = vSystem->systemData->GetCMarkers()[cLoad->GetMarkerNumber()];

	if ((cMarker->GetType() & Marker::Position) && (cMarker->GetType() & Marker::Orientation)) //marker must be able to measure position and orientation
	{
		Vector3D pos; //global marker position
		Matrix3D rot; //global marker rotation
		cMarker->GetPosition(*vSystem->systemData, pos, ConfigurationType::Visualization);
		cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);

		float size = visualizationSettings.loads.defaultSize;
		if (visualizationSettings.loads.defaultSize == -1.f) { size = visualizationSettings.openGL.initialMaxSceneSize * 0.002f; }

		Vector3D loadVector = cLoad->GetParameters().loadVector;
		if (cLoad->IsBodyFixed()) //transform load from local to global coordinates for drawing
		{
			Matrix3D rot;
			cMarker->GetRotationMatrix(*vSystem->systemData, rot, ConfigurationType::Visualization);
			loadVector = rot * loadVector;
		}

		if (visualizationSettings.loads.fixedLoadSize)
		{
			Real L = loadVector.GetL2Norm();
			if (L > 0.) { loadVector *= 1. / L; }
			loadVector *= size;
		}
		else
		{
			loadVector *= visualizationSettings.loads.loadSizeFactor;
		}

		if (visualizationSettings.openGL.showFaces) //show in 3D
		{
			EXUvis::DrawArrow(pos, loadVector, visualizationSettings.loads.defaultRadius, currentColor, vSystem->graphicsData, visualizationSettings.general.axesTiling, true);
		}
		else
		{

			Vector3D n1; //resulting normal vector to loadVector ==> for drawing of torque
			Vector3D n2;
			EXUmath::ComputeOrthogonalBasis(loadVector, n1, n2);
			Real L = loadVector.GetL2Norm()*0.5; //size is related to diameter

			vSystem->graphicsData.AddPoint(pos, currentColor); //midpoint of torque

			const Real phiInc = 0.075*EXUstd::pi;
			for (Real phi = 0.; phi < 1.49999*EXUstd::pi; phi += phiInc)
			{
				Real x1 = L * cos(phi);
				Real y1 = L * sin(phi);
				Real x2 = L * cos(phi + phiInc);
				Real y2 = L * sin(phi + phiInc);
				vSystem->graphicsData.AddLine(pos + x1 * n1 + y1 * n2, pos + x2 * n1 + y2 * n2, currentColor, currentColor);

				if (phi >= 1.49999*EXUstd::pi - phiInc) //draw Arrow
				{
					x1 = L * 1.1 * cos(phi);
					y1 = L * 1.1 * sin(phi);
					vSystem->graphicsData.AddLine(pos + x1 * n1 + y1 * n2, pos + x2 * n1 + y2 * n2, currentColor, currentColor);
					x1 = L * 0.9 * cos(phi);
					y1 = L * 0.9 * sin(phi);
					vSystem->graphicsData.AddLine(pos + x1 * n1 + y1 * n2, pos + x2 * n1 + y2 * n2, currentColor, currentColor);
				}
			}
		}
		if (visualizationSettings.loads.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "L", currentColor); }
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++    SENSORS    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void VisualizationSensorNode::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	Index nodeNumber = vSystem->systemData->GetCSensors()[itemNumber]->GetNodeNumber();
	CNode* cNode = vSystem->systemData->GetCNodes()[nodeNumber];
	if (cNode->GetNodeGroup() == CNodeGroup::ODE2variables)
	{

		float radius = 0.5f*visualizationSettings.sensors.defaultSize;
		if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

		Vector3D pos(((CNodeODE2*)cNode)->GetPosition(ConfigurationType::Visualization));
		Vector3D v1({ radius,0.,0. });
		Vector3D v2({ 0.,radius,0. });
		Vector3D v3({ 0.,0.,radius });
		vSystem->graphicsData.AddLine(pos - v1, pos + v1, currentColor, currentColor);
		vSystem->graphicsData.AddLine(pos - v2, pos + v2, currentColor, currentColor);
		vSystem->graphicsData.AddLine(pos - v3, pos + v3, currentColor, currentColor);

		vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);

		if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "S", currentColor); }
	}
}

void VisualizationSensorBody::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	Float4 currentColor = visualizationSettings.sensors.defaultColor;

	CSensorBody* cSensor = (CSensorBody*)(vSystem->systemData->GetCSensors()[itemNumber]);
	Index objectNumber = cSensor->GetObjectNumber();
	const CObjectBody& cObject = vSystem->systemData->GetCObjectBody(objectNumber);

	float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

	Vector3D pos(cObject.GetPosition(cSensor->GetBodyLocalPosition(), ConfigurationType::Visualization));
	Vector3D v1({ radius,0.,0. });
	Vector3D v2({ 0.,radius,0. });
	Vector3D v3({ 0.,0.,radius });
	vSystem->graphicsData.AddLine(pos - v1, pos + v1, currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos - v2, pos + v2, currentColor, currentColor);
	vSystem->graphicsData.AddLine(pos - v3, pos + v3, currentColor, currentColor);

	vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	vSystem->graphicsData.AddCircleXY(pos, 0.5f*radius, currentColor);

	if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "S", currentColor); }

}

void VisualizationSensorObject::UpdateGraphics(const VisualizationSettings& visualizationSettings, VisualizationSystem* vSystem, Index itemNumber)
{
	//@TODO: VisualizationSensorObject: consider to draw connector sensors at midpoint of connector positions

	//Float4 currentColor = visualizationSettings.sensors.defaultColor;

	//CSensorObject* cSensor = (CSensorObject*)(vSystem->systemData->GetCSensors()[itemNumber]);
	//Index objectNumber = cSensor->GetObjectNumber();
	//const CObject& cObject = *(vSystem->systemData->GetCObjects()[objectNumber]);

	//float radius = 0.5f*visualizationSettings.sensors.defaultSize;
	//if (visualizationSettings.sensors.defaultSize == -1.f) { radius = 0.5f*visualizationSettings.openGL.initialMaxSceneSize * 0.003f; }

	//Vector3D pos(cObject.Get.GetPosition(cSensor->GetBodyLocalPosition(), ConfigurationType::Visualization));
	//Vector3D v1({ radius,0.,0. });
	//Vector3D v2({ 0.,radius,0. });
	//Vector3D v3({ 0.,0.,radius });
	//vSystem->graphicsData.AddLine(pos - v1, pos + v1, currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos - v2, pos + v2, currentColor, currentColor);
	//vSystem->graphicsData.AddLine(pos - v3, pos + v3, currentColor, currentColor);

	//vSystem->graphicsData.AddCircleXY(pos, radius, currentColor);
	//vSystem->graphicsData.AddCircleXY(pos, 0.5f*radius, currentColor);

	//if (visualizationSettings.sensors.showNumbers) { EXUvis::DrawItemNumber(pos, vSystem, itemNumber, "S", currentColor); }

}


