/** ***********************************************************************************************
* @brief        Implementation of CObjectConnectorRigidBodySpringDamper
*
* @author       Gerstmayr Johannes
* @date         2018-05-06 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CObjectConnectorRigidBodySpringDamper.h"
#include "Utilities/RigidBodyMath.h"

void CObjectConnectorRigidBodySpringDamper::ComputeSpringForceTorque(const MarkerDataStructure& markerData,
	Matrix3D& A0all, Vector3D& vLocPos, Vector3D& vLocVel, Vector3D& vLocRot, Vector3D& vLocAngVel, Vector6D& fLocVec6D) const
{
	//spring is measured relative to marker0:

	const Matrix3D& A0 = markerData.GetMarkerData(0).orientation;
	const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
	const Matrix3D& A0off = parameters.rotationMarker0;
	const Matrix3D& A1off = parameters.rotationMarker1;
	//Matrix3D A0all = (A0off * A0);
	//Matrix3D A1all = (A1off * A1);
	A0all = (A0*A0off);
	Matrix3D A1all = (A1*A1off);

	//relative position, spring length and inverse spring length
	vLocPos = A0all.GetTransposed()*(markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position); //vLocPos transformed to marker0 local coordinate system, where springs are defined
	vLocVel = A0all.GetTransposed()*(markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity);

	//relative rotation
	Matrix3D relRot = A0all.GetTransposed() * A1all;
	vLocRot = RigidBodyMath::RotationMatrix2RotXYZ(relRot);

	vLocAngVel = A0all.GetTransposed()*(A1*markerData.GetMarkerData(1).angularVelocityLocal - A0 * markerData.GetMarkerData(0).angularVelocityLocal);


	if (vLocRot[0] > EXUstd::pi) { vLocRot[0] -= 2.*EXUstd::pi; }
	if (vLocRot[1] > EXUstd::pi) { vLocRot[1] -= 2.*EXUstd::pi; }
	if (vLocRot[2] > EXUstd::pi) { vLocRot[2] -= 2.*EXUstd::pi; }

	//compute resulting displacement vector:
	Vector6D uLoc6D;
	Vector6D vLoc6D;
	for (Index i = 0; i < 3; i++)
	{
		uLoc6D[i] = vLocPos[i];
		uLoc6D[i + 3] = vLocRot[i];
		vLoc6D[i] = vLocVel[i];
		vLoc6D[i + 3] = vLocAngVel[i];
	}


	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//evaluate force-torque vector:
	//compute resulting force vector:
	if (!parameters.springForceTorqueUserFunction)
	{
		uLoc6D -= parameters.offset;

		EXUmath::MultMatrixVector(parameters.stiffness, uLoc6D, fLocVec6D);

		Vector6D temp;
		EXUmath::MultMatrixVector(parameters.damping, vLoc6D, temp);
		fLocVec6D += temp;
	}
	else
	{
		EvaluateUserFunctionForce(fLocVec6D, cSystemData->GetMainSystemBacklink(), markerData.GetTime(), uLoc6D, vLoc6D);
	}
}


//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectConnectorRigidBodySpringDamper::ComputeODE2LHS(Vector& ode2Lhs, const MarkerDataStructure& markerData) const
{
	CHECKandTHROW(markerData.GetMarkerData(1).velocityAvailable && markerData.GetMarkerData(0).velocityAvailable,
		"CObjectConnectorRigidBodySpringDamper::ComputeODE2LHS: marker do not provide velocityLevel information");

	//link separate vectors to result (ode2Lhs) vector
	ode2Lhs.SetNumberOfItems(markerData.GetMarkerData(0).positionJacobian.NumberOfColumns() + markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
	ode2Lhs.SetAll(0.);

	//pout << "test\n";
	if (parameters.activeConnector)
	{
		Vector3D vLocPos;
		Vector3D vLocVel;
		Vector3D vLocRot;
		Vector3D vLocAngVel;
		Vector6D fLocVec6D;
		Matrix3D A0all;
		ComputeSpringForceTorque(markerData, A0all, vLocPos, vLocVel, vLocRot, vLocAngVel, fLocVec6D);

		LinkedDataVector fPosLoc(fLocVec6D, 0, 3);
		LinkedDataVector fRotLoc(fLocVec6D, 3, 3);

		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//transform to global coordinates (application of forces/torques always global):
		Vector3D fPos;
		Vector3D fRot;
		EXUmath::MultMatrixVector(A0all, fPosLoc, fPos);
		EXUmath::MultMatrixVector(A0all, fRotLoc, fRot);

		//now link ode2Lhs Vector to partial result using the two jacobians
		if (markerData.GetMarkerData(1).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			//positionJacobian.NumberOfColumns() == rotationJacobian.NumberOfColumns()
			LinkedDataVector ldv1(ode2Lhs, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns(), markerData.GetMarkerData(1).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(1).positionJacobian, fPos, ldv1);
			EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(1).rotationJacobian, fRot, ldv1);
		}

		if (markerData.GetMarkerData(0).positionJacobian.NumberOfColumns()) //special case: COGround has (0,0) Jacobian
		{
			fPos *= -1.;
			fRot *= -1.;
			LinkedDataVector ldv0(ode2Lhs, 0, markerData.GetMarkerData(0).positionJacobian.NumberOfColumns());
			EXUmath::MultMatrixTransposedVector(markerData.GetMarkerData(0).positionJacobian, fPos, ldv0);
			EXUmath::MultMatrixTransposedVectorAdd(markerData.GetMarkerData(0).rotationJacobian, fRot, ldv0);
		}
		//pout << "  ode2Lhs=" << ode2Lhs << "\n";
	}

}

void CObjectConnectorRigidBodySpringDamper::ComputeJacobianODE2_ODE2(ResizableMatrix& jacobian, ResizableMatrix& jacobian_ODE2_t, const MarkerDataStructure& markerData) const
{
	CHECKandTHROWstring("ERROR: illegal call to CObjectConnectorRigidBodySpringDamper::ComputeODE2LHSJacobian");
}
//
////! Flags to determine, which output variables are available (displacment, velocity, stress, ...)
//OutputVariableType CObjectConnectorRigidBodySpringDamper::GetOutputVariableTypes() const
//{
//	return OutputVariableType::Distance;
//}

//! provide according output variable in "value"
void CObjectConnectorRigidBodySpringDamper::GetOutputVariableConnector(OutputVariableType variableType, const MarkerDataStructure& markerData, Vector& value) const
{
	Vector3D vLocPos;
	Vector3D vLocVel;
	Vector3D vLocRot;
	Vector3D vLocAngVel;
	Vector6D fLocVec6D;
	Matrix3D A0all;
	ComputeSpringForceTorque(markerData, A0all, vLocPos, vLocVel, vLocRot, vLocAngVel, fLocVec6D);

	//const Matrix3D& A0 = markerData.GetMarkerData(0).orientation;
	//const Matrix3D& A1 = markerData.GetMarkerData(1).orientation;
	//const Matrix3D& A0off = parameters.rotationMarker0;
	//const Matrix3D& A1off = parameters.rotationMarker1;
	////Matrix3D A0all = (A0off * A0);
	////Matrix3D A1all = (A1off * A1);
	//Matrix3D A0all = (A0*A0off);
	//Matrix3D A1all = (A1*A1off);

	////relative position, spring length and inverse spring length
	//Vector3D vLocPos = A0all.GetTransposed()*(markerData.GetMarkerData(1).position - markerData.GetMarkerData(0).position); //vLocPos transformed to marker0 local coordinate system, where springs are defined
	//Vector3D vLocVel = A0all.GetTransposed()*(markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity);

	////relative rotation
	//Matrix3D relRot = A0all.GetTransposed() * A1all;
	//Vector3D vLocRot = RigidBodyMath::RotationMatrix2RotXYZ(relRot);

	//Vector3D vLocAngVel = A0all.GetTransposed()*(A1*markerData.GetMarkerData(1).angularVelocityLocal - A0 * markerData.GetMarkerData(0).angularVelocityLocal);


	//if (vLocRot[0] > EXUstd::pi) { vLocRot[0] -= 2.*EXUstd::pi; }
	//if (vLocRot[1] > EXUstd::pi) { vLocRot[1] -= 2.*EXUstd::pi; }
	//if (vLocRot[2] > EXUstd::pi) { vLocRot[2] -= 2.*EXUstd::pi; }

	////unit direction and relative velocity of spring-damper
	////Vector3D vVel = (markerData.GetMarkerData(1).velocity - markerData.GetMarkerData(0).velocity);

	////if (markerData.GetMarkerData(1).velocity.GetL2NormSquared() == 0)
	////{
	////	pout << "RSD: vel=0" << "\n";
	////}

	////compute resulting displacement vector:
	//Vector6D uLoc6D;
	//Vector6D vLoc6D;
	//for (Index i = 0; i < 3; i++)
	//{
	//	uLoc6D[i] = vLocPos[i];
	//	uLoc6D[i + 3] = vLocRot[i];
	//	vLoc6D[i] = vLocVel[i];
	//	vLoc6D[i + 3] = vLocAngVel[i];
	//}
	//uLoc6D -= parameters.offset;

	//Vector6D fLocVec6D;
	//EXUmath::MultMatrixVector(parameters.stiffness, uLoc6D, fLocVec6D);

	//Vector6D temp;
	//EXUmath::MultMatrixVector(parameters.damping, vLoc6D, temp);
	//fLocVec6D += temp;

	LinkedDataVector fPosLoc(fLocVec6D, 0, 3);
	LinkedDataVector fRotLoc(fLocVec6D, 3, 3);

	switch (variableType)
	{
	case OutputVariableType::DisplacementLocal: value.CopyFrom(vLocPos); break;
	case OutputVariableType::VelocityLocal: value.CopyFrom(vLocVel); break;
	case OutputVariableType::Rotation: value.CopyFrom(vLocRot); break;
	case OutputVariableType::AngularVelocityLocal: value.CopyFrom(vLocAngVel); break;
	case OutputVariableType::ForceLocal: value.CopyFrom(fPosLoc); break;
	case OutputVariableType::TorqueLocal: value.CopyFrom(fRotLoc); break;
	default:
		SysError("CObjectConnectorRigidBodySpringDamper::GetOutputVariableConnector failed"); //error should not occur, because types are checked!
	}
}



