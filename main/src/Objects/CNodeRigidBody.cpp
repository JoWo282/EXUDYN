/** ***********************************************************************************************
* @brief		Implementation for NodeRigidBodyEP
*
* @author		Gerstmayr Johannes
* @date			2019-10-19 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: missing
* 				
*
* *** Example code ***
*
************************************************************************************************ */
#pragma once

#include "Main/CSystemData.h"
#include "Autogenerated/CNodeRigidBodyEP.h"
#include "Utilities/RigidBodyMath.h"

//for CallFunction(...)
#include "Main/MainSystem.h"
#include "Pymodules/PybindUtilities.h"
#include "Autogenerated/MainNodeRigidBodyEP.h"

// Compute vector to of 4 Euler Parameters from reference and configuration coordinates
ConstSizeVector<CNodeRigidBodyEP::nRotationCoordinates> CNodeRigidBodyEP::GetEulerParameters(ConfigurationType configuration) const
{
	LinkedDataVector refCoordinates = GetReferenceCoordinateVector();
	
	ConstSizeVector<nRotationCoordinates> ep({ refCoordinates[nDisplacementCoordinates + 0], //these are the reference values
		refCoordinates[nDisplacementCoordinates + 1],
		refCoordinates[nDisplacementCoordinates + 2],
		refCoordinates[nDisplacementCoordinates + 3] }); //reference values for Euler Parameters

	if (configuration != ConfigurationType::Reference)
	{
		LinkedDataVector coordinates = GetCoordinateVector(configuration);
		ep[0] += coordinates[nDisplacementCoordinates + 0];
		ep[1] += coordinates[nDisplacementCoordinates + 1];
		ep[2] += coordinates[nDisplacementCoordinates + 2];
		ep[3] += coordinates[nDisplacementCoordinates + 3];
	}

	return ep;
}

// Link vector to time derivative of 4 Euler Parameters in given configuration
ConstSizeVector<CNodeRigidBodyEP::nRotationCoordinates> CNodeRigidBodyEP::GetEulerParameters_t(ConfigurationType configuration) const
{
	LinkedDataVector ep_t = GetCoordinateVector_t(configuration);
	return ConstSizeVector<nRotationCoordinates>({ 
		ep_t[nDisplacementCoordinates + 0], 
		ep_t[nDisplacementCoordinates + 1],
		ep_t[nDisplacementCoordinates + 2],
		ep_t[nDisplacementCoordinates + 3] }); 
}

Vector3D CNodeRigidBodyEP::GetPosition(ConfigurationType configuration) const
{
	//compute reference coordinate vector (this is the position/orientation of the node without displacements)
	LinkedDataVector pRef3D = GetReferenceCoordinateVector();
	Vector3D pRef({ pRef3D[0], pRef3D[1], pRef3D[2] });
	if (configuration == ConfigurationType::Reference) { return pRef; }

	//compute displacement vector (this is the displacement/rotation superimposed to reference configuration)
	LinkedDataVector u3D = GetCoordinateVector(configuration);
	Vector3D displacement({ u3D[0], u3D[1], u3D[2] });
	
	return pRef + displacement; //valid, because position and displacement is still additive!
}

Vector3D CNodeRigidBodyEP::GetVelocity(ConfigurationType configuration) const
{
	//release_assert(configuration == ConfigurationType::Current && "CNodeRigidBodyEP::GetVelocity: not implemented");

	LinkedDataVector u3D_t = GetCoordinateVector_t(configuration);
	return Vector3D({ u3D_t[0], u3D_t[1], u3D_t[2] });
}

Matrix3D CNodeRigidBodyEP::GetRotationMatrix(ConfigurationType configuration) const
{
	ConstSizeVector<nRotationCoordinates> ep(GetEulerParameters(configuration));
	return RigidBodyMath::EP2RotationMatrix(ep);
}

//! return configuration dependent angular velocity of node; returns always a 3D Vector
Vector3D CNodeRigidBodyEP::GetAngularVelocity(ConfigurationType configuration) const
{
	ConstSizeVector<nRotationCoordinates> ep(GetEulerParameters(configuration));
	LinkedDataVector ep_t(GetEulerParameters_t(configuration));
	ConstSizeMatrix<3 * nRotationCoordinates> G = RigidBodyMath::EP2G(ep);;

	Vector3D omega;
	EXUmath::MultMatrixVector(G, ep_t, omega);

	return omega;
}

//! return configuration dependent local (=body fixed) angular velocity of node; returns always a 3D Vector
Vector3D CNodeRigidBodyEP::GetAngularVelocityLocal(ConfigurationType configuration) const
{
	ConstSizeVector<nRotationCoordinates> ep(GetEulerParameters(configuration));
	LinkedDataVector ep_t(GetEulerParameters_t(configuration));
	ConstSizeMatrix<3 * nRotationCoordinates> Glocal = RigidBodyMath::EP2Glocal(ep);

	Vector3D omegaLocal;
	EXUmath::MultMatrixVector(Glocal, ep_t, omegaLocal);

	return omegaLocal;
}

//! provide position jacobian of node; derivative of 3D Position with respect to 7 coordinates ux,uy,uz,ep0,...,ep3
void CNodeRigidBodyEP::GetPositionJacobian(Matrix& value) const
{
	value.SetNumberOfRowsAndColumns(3, nDisplacementCoordinates + nRotationCoordinates);
	value.SetAll(0.);
	value(0, 0) = 1.;
	value(1, 1) = 1.;
	value(2, 2) = 1.;
}

//! provide "rotation" jacobian \f$\Jm_R\f$ of node; derivative of 3D angular velocity vector with respect to all velocity coordinates ("G-matrix"); action of torque \f$\mv\f$: \f$\Qm_m = \Jm_R^T \mv\f$
void CNodeRigidBodyEP::GetRotationJacobian(Matrix& value) const
{
	value.SetNumberOfRowsAndColumns(3, nDisplacementCoordinates + nRotationCoordinates);
	value.SetAll(0.);

	ConstSizeVector<nRotationCoordinates> ep(GetEulerParameters());
	ConstSizeMatrix<3*nRotationCoordinates> G = RigidBodyMath::EP2G(ep);

	for (int i = 0; i < 3; i++) //dimensionality
	{
		for (int j = 0; j < nRotationCoordinates; j++)
		{
			value(i, j + nDisplacementCoordinates) = G(i, j);
		}
	}
}



//! provide according output variable in "value"
void CNodeRigidBodyEP::GetOutputVariable(OutputVariableType variableType, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(configuration)); break;
	case OutputVariableType::Displacement: value.CopyFrom(GetPosition(configuration) - GetPosition(ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(configuration)); break;
	case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(configuration)); break;
	case OutputVariableType::Coordinates:
	{
		if (IsConfigurationInitialCurrentReferenceVisualization(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Reference + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector(configuration);
		}
		else
		{
			PyError("CNodeRigidBodyEP::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_t:
	{
		if (IsConfigurationInitialCurrentVisualization(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector_t(configuration);
		}
		else
		{
			PyError("CNodeRigidBodyEP::GetOutputVariable: invalid configuration");
		}
		break;
	}
	default:
		SysError("CNodeRigidBodyEP::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}

//! call a certain function of object (autogenerated in future!)
py::object MainNodeRigidBodyEP::CallFunction(STDstring functionName, py::dict args) const
{
	////these calls should be automated by python script ...
	//if (functionName == "GetTypeName")
	//{
	//	return py::str(GetTypeName());
	//}
	//else if (functionName == "GetNodeType")
	//{
	//	return py::cast(GetCNodeRigidBodyEP()->GetType());
	//}
	//else if (functionName == "GetNodeGroup")
	//{
	//	return py::cast(GetCNodeRigidBodyEP()->GetNodeGroup());
	//}
	//else if (functionName == "GetNumberOfODE2Coordinates")
	//{
	//	return py::int_(GetCNodeRigidBodyEP()->GetNumberOfODE2Coordinates());
	//}
	//else if (functionName == "GetGlobalODE2CoordinateIndex")
	//{
	//	return py::int_(GetCNodeRigidBodyEP()->GetGlobalODE2CoordinateIndex());
	//}
	//else if (functionName == "GetCurrentCoordinateVector")
	//{
	//	Vector v(GetCNodeRigidBodyEP()->GetCurrentCoordinateVector());
	//	return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	//}
	//else if (functionName == "GetInitialCoordinateVector")
	//{
	//	Vector v(GetCNodeRigidBodyEP()->GetInitialCoordinateVector());
	//	return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	//}
	//else if (functionName == "GetCurrentCoordinateVector_t")
	//{
	//	Vector v(GetCNodeRigidBodyEP()->GetCurrentCoordinateVector_t());
	//	return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	//}
	//else if (functionName == "GetInitialCoordinateVector_t")
	//{
	//	Vector v(GetCNodeRigidBodyEP()->GetInitialCoordinateVector_t());
	//	return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	//}
	//else if (functionName == "GetCurrentPosition")
	//{
	//	Vector3D v = GetCNodeRigidBodyEP()->GetPosition(ConfigurationType::Current);
	//	return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	//}
	////before doing so, use : https://pybind11.readthedocs.io/en/master/advanced/pycpp/numpy.html?highlight=numpy#f
	//// and matrix example : https://github.com/pybind/pybind11/blob/master/tests/test_buffers.cpp
	////else if (functionName == "GetCurrentRotationMatrix")
	////{
	////	Matrix3D m = GetCNodeRigidBodyEP()->GetRotationMatrix(ConfigurationType::Current);
	////	return py::array_t<Real>(m.NumberOfItems(), m.GetDataPointer());
	////}

	PyError(STDstring("MainNodeRigidBodyEP::CallFunction called with invalid functionName '" + functionName + "'"));
	return py::int_(EXUstd::InvalidIndex);
}
