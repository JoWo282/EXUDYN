/** ***********************************************************************************************
* @brief        CObjectFFRF implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"
#include "Main/CSystemData.h"

#include "Main/MainSystem.h"
#include "Pymodules/PybindUtilities.h"
#include "Autogenerated/MainObjectFFRF.h"

#include "Autogenerated/CObjectFFRF.h"
#include "Utilities/RigidBodyMath.h"

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/stl_bind.h>
#include <pybind11/operators.h>
#include <pybind11/numpy.h>       //interface to numpy
#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
#include <pybind11/embed.h>       //scoped interpreter
//does not work globally: #include <pybind11/iostream.h> //used to redirect cout:  py::scoped_ostream_redirect output;
//#include <pybind11/cast.h> //for arguments
#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)

//typedef py::array_t<Real> NumpyMatrix; //declaration to avoid all pybind includes

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

bool MainObjectFFRF::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectFFRF* cObject = (CObjectFFRF*)GetCObject();

	Index numberOfNodes = cObject->GetNumberOfNodes();
	//Index numberOfMeshNodes = cObject->GetNumberOfMeshNodes();

	//Index nODE2test = cObject->GetODE2Size(); //NOT AVAILABLE YET
	Index nODE2 = 0; //total number of coordinates
	for (Index i = 0; i < cObject->GetParameters().nodeNumbers.NumberOfItems(); i++)
	{
		cObject->GetCoordinateIndexPerNode()[i] = nODE2;
		nODE2 += cObject->GetCNode(i)->GetNumberOfODE2Coordinates();
	}


	Index nR = cObject->GetCNode(cObject->rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nF = nODE2 - nR; //number of flexible coordinates

	if (numberOfNodes == 0)
	{
		errorString = "ObjectFFRF: has 0 nodes, but must have at least 1 node (rigid body node)";
		return false;
	}

	//check specific node types
	for (Index nn = 0; nn < numberOfNodes; nn++)
	{
		if (((Index)cObject->GetCNode(nn)->GetNodeGroup() & (Index)CNodeGroup::ODE2variables) == 0)
		{
			errorString = "ObjectFFRF: local node " + EXUstd::ToString(nn) + " has invalide node type " + EXUstd::ToString(Node::GetTypeString(cObject->GetCNode(nn)->GetType())) + ", but should be ODE2 node (node group ODE2variables)";
				return false;
		}
		if (nn > 0 && cObject->GetCNode(nn)->GetNumberOfODE2Coordinates() != CObjectFFRF::ffrfNodeDim)
		{
			errorString = "ObjectFFRF: local node " + EXUstd::ToString(nn) + " has " + EXUstd::ToString(cObject->GetCNode(nn)->GetNumberOfODE2Coordinates()) + " coordinates, but must have number of coordinates = 3";
			return false;
		}
	}

	if (!EXUstd::IsOfType(cObject->GetCNode(CObjectFFRF::rigidBodyNodeNumber)->GetType(), (Node::Type)(Node::RigidBody)))
	{
		errorString = "ObjectFFRF: local node 0 must be of type 'Node.RigidBody'";
		return false;
	}

	Index nForce = cObject->GetParameters().forceVector.NumberOfItems();
	if (nForce != nODE2 && nForce != 0)
	{
		errorString = "ObjectFFRF: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but forceVector has size " + EXUstd::ToString(nForce);
		return false;
	}

	Index rowsMass = cObject->GetParameters().massMatrixFF.NumberOfRows();
	Index columnsMass = cObject->GetParameters().massMatrixFF.NumberOfColumns();
	if (!(rowsMass == nF && columnsMass == nF))
	{
		if (rowsMass == 0 && columnsMass == 0)
		{
			if (cObject->GetParameters().computeFFRFterms)
			{
				errorString = "ObjectFFRF: massMatrixFF must be specified if computeFFRFterms = True";
				return false;
			}
		}
		else
		{
			errorString = "ObjectFFRF: number of flexible coordinates of object is " + EXUstd::ToString(nF) + ", but mass matrix has size (" + EXUstd::ToString(rowsMass) + " x " + EXUstd::ToString(columnsMass) + ")";
			return false;
		}
	}

	Index rowsStiffness = cObject->GetParameters().stiffnessMatrixFF.NumberOfRows();
	Index columnsStiffness = cObject->GetParameters().stiffnessMatrixFF.NumberOfColumns();
	if (!(rowsStiffness == nF && columnsStiffness == nF))
	{
		if (rowsStiffness == 0 && columnsStiffness == 0)
		{
			if (cObject->GetParameters().computeFFRFterms)
			{
				errorString = "ObjectFFRF: stiffnessMatrixFF must be specified if computeFFRFterms = True";
				return false;
			}
		}
		else
		{
			errorString = "ObjectFFRF: number of flexible coordinates of object is " + EXUstd::ToString(nF) + ", but stiffnessMatrixFF has size (" + EXUstd::ToString(rowsStiffness) + " x " + EXUstd::ToString(columnsStiffness) + ")";
			return false;
		}
	}

	Index rowsDamping = cObject->GetParameters().dampingMatrixFF.NumberOfRows();
	Index columnsDamping = cObject->GetParameters().dampingMatrixFF.NumberOfColumns();
	if (!(rowsDamping == nF && columnsDamping == nF) && !((rowsDamping == 0 && columnsDamping == 0)))
	{
		errorString = "ObjectFFRF: number of flexible coordinates of object is " + EXUstd::ToString(nF) + ", but dampingMatrixFF has size (" + EXUstd::ToString(rowsDamping) + " x " + EXUstd::ToString(columnsDamping) + ")";
		return false;
	}

	//check visualization
	VisualizationObjectFFRF* vObject = (VisualizationObjectFFRF*)GetVisualizationObject();
	if (vObject->GetTriangleMesh().NumberOfRows() != 0)
	{
		if (vObject->GetTriangleMesh().NumberOfColumns() != 3)
		{
			errorString = "ObjectFFRF: number of columns in triangleMesh must be 3";
			return false;
		}

		auto& trigs = vObject->GetTriangleMesh();
		for (Index i = 0; i < trigs.NumberOfRows(); i++)
		{
			for (Index j = 0; j < trigs.NumberOfColumns(); j++)
			{
				if (trigs(i, j) >= cObject->GetNumberOfMeshNodes())
				{
					errorString = "ObjectFFRF: node number in triangleMesh(" + EXUstd::ToString(i) + "," + EXUstd::ToString(j) + ") is invalid; valid node numbers: 0 .. " + EXUstd::ToString(cObject->GetNumberOfMeshNodes());
					return false;
				}
			}
		}
	}


	return true;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CObjectFFRF::ComputeObjectCoordinates(Vector& coordinates, Vector& coordinates_t, ConfigurationType configuration) const
{
	coordinates.SetNumberOfItems(GetODE2Size());
	coordinates_t.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode(GetCNode(nn)->GetCoordinateVector(configuration));
		LinkedDataVector vNode_t(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_t(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates[cnt + i] = vNode[i];
			coordinates_t[cnt + i] = vNode_t[i];
		}
		cnt += nc;
	}

}

Index CObjectFFRF::GetODE2Size() const
{
	//Index s = 0;
	//for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	//{
	//	s += GetCNode(i)->GetNumberOfODE2Coordinates();
	//}
	//return s;
	CHECKandTHROW(coordinateIndexPerNode.NumberOfItems() != 0, "CObjectFFRF::GetODE2Size internal error: called before coordinateIndexPerNode has been initialized");
	//faster version, does not require iterations:
	Index nn = parameters.nodeNumbers.NumberOfItems();
	if (nn) { return coordinateIndexPerNode.Last() + GetCNode(nn - 1)->GetNumberOfODE2Coordinates(); }
	else { return 0; }
}

void CObjectFFRF::InitializeObject()
{
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//initialize coordinate indices
	coordinateIndexPerNode.SetNumberOfItems(parameters.nodeNumbers.NumberOfItems());

	Index s = 0;
	for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	{
		coordinateIndexPerNode[i] = s;
		s += GetCNode(i)->GetNumberOfODE2Coordinates();
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//initialize all inertia shape matrices
	//Index nODE2 = GetODE2Size(); //needed here?
	Index nM = GetNumberOfMeshNodes();
	Index nODE2FF = nM * ffrfNodeDim;

	Matrix PHIt;// = np.kron(np.ones(nNodes), unit3D).T
	RigidBodyMath::ComputeBlockColumnMatrix(nM, EXUmath::unitMatrix3D, PHIt);

	//compute PHItTM;
	parameters.massMatrixFF.MultDenseMatrixTransposedMatrix(PHIt, PHItTM); //PHItTM = PHIt^T * M

	//compute Mtt and total mass
	Matrix3D Mtt;
	EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, PHIt, Mtt);

	//Mtt = PHIt.T @ massMatrix @ PHIt
	//Mnew[0:3, 0 : 3] = Mtt
	physicsMass = Mtt(0, 0); //must be diagonal matrix with mass in diagonal

	//xRefNodes = nodes.flatten() #node reference values in single vector(can be added then to q[7:])
	//xRefTilde = ComputeSkewMatrix(xRefNodes) #rfTilde without q
	referencePositions = Vector(nODE2FF);
	Matrix xRefTilde(nODE2FF, ffrfNodeDim);
	for (Index i = 0; i < nM; i++)
	{
		Vector3D x = GetMeshNodeLocalPosition(i, ConfigurationType::Reference); //previously: GetMeshNodePosition ==> leads to wrong results, if reference position is wrong ...!

		for (Index j = 0; j < ffrfNodeDim; j++)
		{
			referencePositions[i * ffrfNodeDim + j] = x[j];
		}
		Matrix3D xTilde = RigidBodyMath::Vector2SkewMatrix(x);
		xRefTilde.SetSubmatrix(xTilde, i * ffrfNodeDim, 0);

		//LinkedDataVector xRefSub(xRefNodes, i * 3, 3);
		//xRefSub.CopyFrom(x);
		//LinkedDataVector(xRefNodes, i * 3, 3) = x; //works?
	}

	//inertiaLocal = xRefTilde.T @ massMatrix @ xRefTilde
	Matrix xRefTildeTM;
	parameters.massMatrixFF.MultDenseMatrixTransposedMatrix(xRefTilde, xRefTildeTM);
	EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(xRefTildeTM, xRefTilde, physicsInertia);

//#define CObjectFFRFInitializeObjectOutput
#ifdef CObjectFFRFInitializeObjectOutput
	pout << "PHIt = " << PHIt.GetSubmatrix(0, 0, 6, 3) << "\n";
	pout << "PHItTM = " << PHItTM.GetSubmatrix(0, 0, 3, 6) << "\n";
	pout << "xRefTilde size = " << xRefTilde.NumberOfRows() << "," << xRefTilde.NumberOfColumns() << "\n";
	pout << "xRefTilde = " << xRefTilde.GetSubmatrix(0, 0, 6, 3) << "\n";
	pout << "inertiaLocal = " << physicsInertia << "\n";
	pout << "parameters.physicsMass = " << physicsMass << "\n";
	pout << "Mtt = " << Mtt << "\n";
#endif

	//++++++++++++++++++++++++++
	//finally
	objectIsInitialized = true;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! Computational function: compute mass matrix
void CObjectFFRF::ComputeMassMatrix(Matrix& massMatrix) const
{
//#define CObjectFFRFComputeMassMatrixOutput
	if (!objectIsInitialized) { PyError("CObjectFFRF::ComputeMassMatrix: objectIsInitialized = false: run Assemble() before computation."); }

	Index nODE2 = GetODE2Size();
	if (parameters.massMatrixUserFunction)
	{
		Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
		Vector coordinates_t(nODE2);
		ComputeObjectCoordinates(coordinates, coordinates_t);

		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		{
			//user function args:(t, coordinates, coordinates_t)
			EPyUtils::NumPy2Matrix(parameters.massMatrixUserFunction(t, coordinates, coordinates_t), massMatrix);
		}, "ObjectFFRF::massMatrixUserFunction");
	}
	else //initialize with zero
	{
		massMatrix.SetNumberOfRowsAndColumns(nODE2, nODE2);
		massMatrix.SetAll(0.);
	}
	if (parameters.computeFFRFterms)
	{
		Index nODE2FF = GetNumberOfMeshNodes() * ffrfNodeDim;
		Index nODE2Rigid = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfODE2Coordinates();

		tempCoordinates.SetNumberOfItems(nODE2); 
		tempCoordinates_t.SetNumberOfItems(nODE2); 
		LinkedDataVector coordinatesFF(tempCoordinates, nODE2Rigid, nODE2FF);
		//LinkedDataVector coordinatesFF_t(tempCoordinates_t, nODE2Rigid, nODE2FF);

		ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);
		const Index GMaxSize = CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D; //12

		ConstSizeMatrix<GMaxSize> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);
		ConstSizeMatrix<GMaxSize> GlocalT;
		GlocalT = Glocal.GetTransposed();


		Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix();

		coordinatesFF += referencePositions; //this are now the local nodal positions for mesh (FF) coordinates

		RigidBodyMath::ComputeSkewMatrix(coordinatesFF, tempRefPosSkew);

		//Mtt
		Matrix3D Mtt(3, 3);
		Mtt.SetScalarMatrix(3, physicsMass);
		massMatrix.AddSubmatrix(Mtt, 0, 0);

		//++++++++++++++++++++++++++++++++
		//Mtr = -A @ PHItTM @ rfTilde @ G
		//Mnew[0:dim3D, dim3D : dim3D + nODE2rot] = Mtr
		//Mnew[dim3D:dim3D + nODE2rot, 0 : dim3D] = Mtr.T
		Matrix3D X;
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, tempRefPosSkew, X);
		X = -1.*A*X;
		ConstSizeMatrix<GMaxSize> Mtr;
		EXUmath::MultMatrixMatrixTemplate<Matrix3D, ConstSizeMatrix<GMaxSize>, ConstSizeMatrix<GMaxSize>>(X, Glocal, Mtr);

		massMatrix.AddSubmatrix(Mtr, 0, ffrfNodeDim);
		massMatrix.AddSubmatrixTransposed(Mtr, ffrfNodeDim, 0);

		//++++++++++++++++++++++++++++++++
		//#Mtf:
		//Mtf = A @ PHItTM
		//Mnew[0:dim3D, nODE2rigid : ] = Mtf
		//Mnew[nODE2rigid:, 0 : dim3D] = Mtf.T
		EXUmath::MultMatrixMatrixTemplate<Matrix3D, Matrix, Matrix>(A, PHItTM, tempMatrix);
		massMatrix.AddSubmatrix(tempMatrix, 0, nODE2Rigid);
		massMatrix.AddSubmatrixTransposed(tempMatrix, nODE2Rigid, 0);


		//++++++++++++++++++++++++++++++++
		//#Mrf:
		//Mrf = -G.T @ rfTilde.T @ massMatrix
		//Mnew[dim3D:dim3D + nODE2rot, nODE2rigid : ] = Mrf
		//Mnew[nODE2rigid:, dim3D : dim3D + nODE2rot] = Mrf.T
		parameters.massMatrixFF.MultDenseMatrixTransposedMatrix(tempRefPosSkew, tempMatrix);
		EXUmath::MultMatrixMatrixTemplate<ConstSizeMatrix<GMaxSize>, Matrix, Matrix>(-1.*GlocalT, tempMatrix, tempMatrix2);
		massMatrix.AddSubmatrix(tempMatrix2, ffrfNodeDim, nODE2Rigid);
		massMatrix.AddSubmatrixTransposed(tempMatrix2, nODE2Rigid, ffrfNodeDim);

		
		//++++++++++++++++++++++++++++++++
		//#Mrr:
		const Index MrrMaxSize = CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::maxRotationCoordinates;
		ConstSizeMatrix<MrrMaxSize> Mrr;
		ConstSizeMatrix<GMaxSize> temp; //gives a 4x3 matrix for EP
		//Mnew[dim3D:dim3D + nODE2rot, dim3D : dim3D + nODE2rot] = -Mrf @ rfTilde @ G   #G.T @ rfTilde.T @ massMatrix @ rfTilde @ G
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, ConstSizeMatrix<GMaxSize>>(tempMatrix2, tempRefPosSkew, temp);
		EXUmath::MultMatrixMatrixTemplate<ConstSizeMatrix<GMaxSize>, 
			ConstSizeMatrix<GMaxSize>, 
			ConstSizeMatrix<MrrMaxSize>>(temp, -1.*Glocal, Mrr);
		massMatrix.AddSubmatrix(Mrr, ffrfNodeDim, ffrfNodeDim);

		//++++++++++++++++++++++++++++++++
		//Mff:
		Index nR = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
		massMatrix.AddSubmatrix(parameters.massMatrixFF.GetEXUdenseMatrix(), nR, nR);

#ifdef CObjectFFRFComputeMassMatrixOutput
		pout << "Mtt Mtr Mtf=" << massMatrix.GetSubmatrix(0, 0, 3, 10) << "\n";
		pout << "Mrr        =" << massMatrix.GetSubmatrix(3, 3, 4, 4) << "\n";
		pout << "Mff        =" << massMatrix.GetSubmatrix(7, 7, 3, 6) << "\n";
#endif
	}
}








//! Computational function: compute right-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2rhs"
//in fact, this is the LHS function!
void CObjectFFRF::ComputeODE2RHS(Vector& ode2Rhs) const
{
	Index nODE2 = GetODE2Size(); //total number of coordinates
	Index nODE2FF = GetNumberOfMeshNodes() * ffrfNodeDim;
	Index nODE2Rigid = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfODE2Coordinates();

	ode2Rhs.SetNumberOfItems(nODE2);
	ode2Rhs.SetAll(0.);

	//tempCoordinates.SetNumberOfItems(nODE2); //delete
	//tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);

	if (parameters.computeFFRFterms)
	{
		//K*q and D*q_T put to LHS !!!
		//link to flexible parts of vectors:
		LinkedDataVector coordinatesFF(tempCoordinates, nODE2Rigid, nODE2FF);
		LinkedDataVector coordinatesFF_t(tempCoordinates_t, nODE2Rigid, nODE2FF); //cF_t in python
		LinkedDataVector ode2RhsTT(ode2Rhs, 0, ffrfNodeDim);
		LinkedDataVector ode2RhsRR(ode2Rhs, ffrfNodeDim, nODE2Rigid-ffrfNodeDim);
		LinkedDataVector ode2RhsFF(ode2Rhs, nODE2Rigid, nODE2FF);

		Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix();

		const Index GMaxSize = CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D; //12


		if (parameters.stiffnessMatrixFF.NumberOfRows() != 0)
		{
			//EXUmath::MultMatrixVectorAdd(parameters.stiffnessMatrixFF, coordinatesFF, ode2RhsFF);
			parameters.stiffnessMatrixFF.MultMatrixVectorAdd(coordinatesFF, ode2RhsFF);
		}

		if (parameters.dampingMatrixFF.NumberOfRows() != 0)
		{
			parameters.dampingMatrixFF.MultMatrixVectorAdd(coordinatesFF_t, ode2RhsFF);

			//delete:
			//Vector test = ode2RhsFF;
			//test *= 0;
			//parameters.dampingMatrixFF.MultMatrixVectorAdd(coordinatesFF_t, test);
			//pout << "|damping term|=" << test.GetL2Norm() << "\n";
		}

		if (parameters.forceVector.NumberOfItems() != 0)
		{
			//CHECKandTHROWstring("CObjectFFRF::ComputeODE2RHS: forceVector not implemented!");
			//transformation needed, which transforms f_{ff} components from global to local coordiantes
			LinkedDataVector forceVectorRigid(parameters.forceVector, 0, nODE2Rigid);
			LinkedDataVector forceVectorFF(parameters.forceVector, nODE2Rigid, nODE2FF);
			LinkedDataVector ode2RhsRigid(ode2Rhs, 0, nODE2Rigid);

			ode2RhsRigid -= forceVectorRigid;
			Matrix3D AT = GetRotationMatrix(Vector3D({ 0, 0, 0 })).GetTransposed();
			AT *= -1; //because forceVector is subtracted
			RigidBodyMath::ApplyTransformationAndAdd(AT, forceVectorFF, ode2RhsFF);

			//ode2Rhs -= parameters.forceVector;
		}

		ConstSizeMatrix<GMaxSize> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);
		ConstSizeMatrix<GMaxSize> GlocalT;
		GlocalT = Glocal.GetTransposed();

		coordinatesFF += referencePositions; //this are now the local nodal positions for mesh (FF) coordinates; rF in python

		Vector3D omega3D = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal();
		Matrix3D omega3Dtilde = RigidBodyMath::Vector2SkewMatrix(omega3D);
		Matrix3D omega3Dtilde2 = omega3Dtilde * omega3Dtilde;

		RigidBodyMath::ComputeSkewMatrix(coordinatesFF, tempRefPosSkew); //tempRefPosSkew = rfTilde in python
		RigidBodyMath::ComputeSkewMatrix(coordinatesFF_t, tempVelSkew); //tempVelSkew = cF_tTilde in python

		//    omega = np.array(list(omega3D)*nNodes)
		//    omegaTilde = np.kron(np.eye(nNodes),omega3Dtilde)
		//    omegaTilde2 = np.kron(np.eye(nNodes),omega3Dtilde2)


		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//fTrans = A @ (omega3Dtilde @ PHItTM @ rfTilde @ omega3D + 2*PHItTM @ cF_tTilde @ omega3D)
		//force[0:dim3D] = fTrans
		Matrix3D temp;
		//omega3Dtilde @ PHItTM @ rfTilde @ omega3D
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, tempRefPosSkew, temp);
		Vector3D tempVec = temp * omega3D;
		tempVec = omega3Dtilde * tempVec;

		//2*PHItTM @ cF_tTilde @ omega3D
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, tempVelSkew, temp);
		tempVec += temp * (2. * omega3D);
		ode2RhsTT -= A * tempVec; //-= for all ode2Rhs terms

		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//fRot = -G.T@(omega3Dtilde @ rfTilde.T @ massMatrix @ rfTilde @ omega3D + 
		//		        2*rfTilde.T @ massMatrix @ cF_tTilde @ omega3D)
		//force[dim3D:nODE2rigid] = fRot
		//omega3Dtilde @ (rfTilde.T @ massMatrix @ rfTilde) @ omega3D 
		parameters.massMatrixFF.MultDenseMatrixTransposedMatrix(tempRefPosSkew, tempMatrix); //tempMatrix=rfTilde.T @ massMatrix
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(tempMatrix, tempRefPosSkew, temp);
		tempVec = omega3Dtilde * (temp * omega3D);

		//2*rfTilde.T @ massMatrix @ cF_tTilde @ omega3D
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(tempMatrix, tempVelSkew, temp);
		tempVec += 2.*(temp * omega3D);

		//ode2RhsRR -= -1.*(GlocalT * tempVec); //-= for all ode2Rhs terms; NOT IMPLEMENTED, because cannot decide result vector at compile time
		EXUmath::MultMatrixVectorAdd(GlocalT, tempVec, ode2RhsRR); //double negative signs cancel!



		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//fFlex = -massMatrix @ (omegaTilde2 @ rF + 2*(omegaTilde @ cF_t))
		//force[nODE2rigid:] = fFlex
		tempVector = coordinatesFF;
		RigidBodyMath::ApplyTransformation(omega3Dtilde2, tempVector);
		RigidBodyMath::ApplyTransformationAndAdd(2.*omega3Dtilde, coordinatesFF_t, tempVector);
		parameters.massMatrixFF.MultMatrixVectorAdd(tempVector, ode2RhsFF); //two negative signs cancel: fFlex = - ... and ode2RhsFF -= ...
		

		//#add gravity:
		//if False:
		//    fGrav = np.array(fGravRigid + list(PHItTM.T @ (A.T @ g)) ) #only local vector, without rotation
		//    force += fGrav
		//

	}
	if (parameters.forceUserFunction)
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		Vector userForce;

		UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		{
			//user function args:(t, coordinates, coordinates_t)
			userForce = (Vector)(parameters.forceUserFunction(t, tempCoordinates, tempCoordinates_t));
		}, "ObjectFFRF::forceUserFunction");

		ode2Rhs -= userForce;
	}

}



//! number of AE coordinates; depends on node
Index CObjectFFRF::GetAlgebraicEquationsSize() const
{
	Index nAE = 0;
	if (((Index)((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetType() & (Index)Node::RotationEulerParameters) != 0) { nAE += 1; }
	//if (parameters.constrainRigidBodyMotion) { nAE += 6; }
	return nAE;
}

//! Compute algebraic equations part of rigid body
void CObjectFFRF::ComputeAlgebraicEquations(Vector& algebraicEquations, bool useIndex2) const
{
	algebraicEquations.SetNumberOfItems(GetAlgebraicEquationsSize());
	//Index offset = 0;

	if (((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetType() & Node::RotationEulerParameters)
	{
		//offset = 1; //for Euler parameter constraint
		if (GetCNode(rigidBodyNodeNumber)->GetNumberOfAECoordinates() != 0)
		{
			algebraicEquations.SetNumberOfItems(1);
			if (!useIndex2)
			{
				//position level constraint:

				ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationParameters();
				algebraicEquations[0] = ep * ep - 1.;
			}
			else
			{
				//velocity level constraint:
				ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationParameters();
				LinkedDataVector ep_t = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationParameters_t();

				algebraicEquations[0] = 2. * (ep * ep_t);
			}
		}
	}

	//impossible now: object cannot have constraints without algebraic nodal variables:
	//if (parameters.constrainRigidBodyMotion)
	//{ 
	//	Index nODE2FF = GetNumberOfMeshNodes() * ffrfNodeDim;
	//	Index nODE2Rigid = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfODE2Coordinates();

	//	LinkedDataVector gTrans(algebraicEquations, offset, ffrfNodeDim);
	//	LinkedDataVector gRot(algebraicEquations, offset, (nODE2Rigid-ffrfNodeDim));
	//	ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);

	//	LinkedDataVector qf(tempCoordinates, nODE2Rigid, nODE2FF);
	//	RigidBodyMath::ComputeSkewMatrix(referencePositions, tempRefPosSkew); //\tilde x_ref^T

	//	EXUmath::MultMatrixVector(PHItTM, qf, gTrans);
	//	parameters.massMatrixFF.MultMatrixVector(qf, tempVector); //tempVector =  M_ff * qf
	//	EXUmath::MultMatrixTransposedVector(tempRefPosSkew, tempVector, gRot); //\tilde x_ref^T * M_ff * qf
	//}

}

//! Compute jacobians of algebraic equations part of rigid body w.r.t. ODE2
void CObjectFFRF::ComputeJacobianAE(ResizableMatrix& jacobian, ResizableMatrix& jacobian_t, ResizableMatrix& jacobian_AE) const
{
	//Index offset = 0;
	if (GetCNode(rigidBodyNodeNumber)->GetNumberOfAECoordinates() != 0)
	{
		Index nODE2 = GetODE2Size(); //total number of coordinates
		//Index nODE2FF = GetNumberOfMeshNodes() * ffrfNodeDim;
		//Index nODE2Rigid = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfODE2Coordinates();

		jacobian.SetNumberOfRowsAndColumns(GetAlgebraicEquationsSize(), nODE2);
		jacobian_t.SetNumberOfRowsAndColumns(0, 0); //for safety!
		jacobian_AE.SetNumberOfRowsAndColumns(0, 0);//for safety!
		jacobian.SetAll(0.); //many rigid body entries zero ==> for simplicity

		if (((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetType() & Node::RotationEulerParameters)
		{
			//offset = 1;
			ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();

			//jacobian = [0 0 0 2*ep0 2*ep1 2*ep2 2*ep3]
			for (Index i = 0; i < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); i++)
			{
				jacobian(0, ffrfNodeDim + i) = 2.*ep[i];
			}
		}
	}
		//impossible now: object cannot have constraints without algebraic nodal variables:
		//else if (parameters.constrainRigidBodyMotion)
		//{
		//	jacobian.SetSubmatrix(PHItTM, offset, nODE2Rigid); //for constraints on translational rigid body motion

		//	RigidBodyMath::ComputeSkewMatrix(referencePositions, tempRefPosSkew); //\tilde x_ref
		//	parameters.massMatrixFF.MultDenseMatrixTransposedMatrix(tempRefPosSkew, tempMatrix); //fill matrix directly into jacobian; jacSub = \tilde x_ref^T M_ff

		//	jacobian.SetSubmatrix(tempMatrix, offset + ffrfNodeDim, nODE2Rigid); //ffrfNodeDim also used for 3 rigid body rotation modes
		//}
	else
	{
		jacobian.SetNumberOfRowsAndColumns(0, 0);
		jacobian_t.SetNumberOfRowsAndColumns(0, 0); //for safety!
		jacobian_AE.SetNumberOfRowsAndColumns(0, 0);//for safety!
	}
}


//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectFFRF::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt+(Index)AccessFunctionType::AngularVelocity_qt + 
		(Index)AccessFunctionType::DisplacementMassIntegral_q + (Index)AccessFunctionType::SuperElement);
}

//! provide Jacobian at localPosition in "value" ONLY OF reference frame, according to configuration type
void CObjectFFRF::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	static_assert(CNodeRigidBody::nDim3D == CNodeRigidBody::maxDisplacementCoordinates); //add this code to raise compiler error, if max. number of displacement coordiantes changes in RigidBodyNode ==> requires reimplementation in this file!
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt: //global translational velocity at localPosition derivative w.r.t. qt = L-matrix = [I   -A*uLocalTilde*Glocal]
	{
		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		//Jac = -A*uLocalTilde*Glocal
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

		ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix(-localPosition); //negative sign in -A*uLocalTilde*Glocal
		//uLocalTilde *= -1.;//moved into (-localPosition)

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> temp; //temporary matrix during computation
		EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(), temp, Glocal); //Glocal now is: A*(-uLocalTilde)*Glocal

		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());
		//unit matrix
		value(0, 0) = 1.; value(0, 1) = 0.; value(0, 2) = 0.;
		value(1, 0) = 0.; value(1, 1) = 1.; value(1, 2) = 0.;
		value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = 1.;

		//-A*uLocalTilde*Glocal part (=L in this case
		for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		{
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, CNodeRigidBody::nDim3D + j) = Glocal(i, j);
			}
		}


		break;
	}
	case AccessFunctionType::AngularVelocity_qt: //global angular velocity
	{
		//d(omega)/d(q_t): derivative of angular velocity w.r.t. all coordinates_t = [0_{3x3} G-matrix]
		//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationParameters();
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> G;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetG(G);// RigidBodyMath::EP2G(rot);

		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());
		for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		{
			value(0, i) = 0;
			value(1, i) = 0;
			value(2, i) = 0;
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, CNodeRigidBody::nDim3D + j) = G(i, j);
			}
		}
		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());

		Real m = physicsMass;

		if (physicsCenterOfMass == 0.)
		{
			for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
			{
				for (Index j = 0; j < GetODE2Size(); j++)
				{
					if (i != j) { value(i, j) = 0.; }
					else { value(i, j) = m; } //only diagonal 3x3 term!
				}
			}
		}
		else
		{
			//gives m* \partial p_COM / \partial q
			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> Glocal;
			((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);
			CHECKandTHROW(physicsCenterOfMass == localPosition, "CObjectFFRF::GetAccessFunctionBody: inconsistent localPosition");


			ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix((-m)*physicsCenterOfMass); //negative sign in -A*uLocalTilde*Glocal
			//uLocalTilde *= -1.;//moved into ((-m)*parameters.physicsCenterOfMass)

			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> temp; //temporary matrix during computation
			EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
			EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(), temp, Glocal); //Glocal=A*(-m*uLocalTilde)*Glocal

			//unit matrix
			value(0, 0) = m; value(0, 1) = 0.; value(0, 2) = 0.;
			value(1, 0) = 0.; value(1, 1) = m; value(1, 2) = 0.;
			value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = m;

			//-A*uLocalTilde*Glocal part (=L in this case
			for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
			{
				for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
				{
					value(i, CNodeRigidBody::nDim3D + j) = Glocal(i, j);
				}
			}
		}

		break;
	}
	default:
		SysError("CObjectFFRF:GetAccessFunctionBody illegal accessType");
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     REFERENCE FRAME FUNCTIONS     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! provide according output variable in "value", localPosition ONLY REFERS TO THE REFERENCE FRAME!
void CObjectFFRF::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value) const
{
	Index nODE2 = GetODE2Size();
	Vector coordinates(nODE2);
	Vector coordinates_t(nODE2);
	ComputeObjectCoordinates(coordinates, coordinates_t, configuration);

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(coordinates);	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(coordinates_t);	break;
	case OutputVariableType::Force:			ComputeODE2RHS(value);	break;
	default:
		SysError("CObjectFFRF::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}


//  return the (global) position of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRF::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration) + 
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) * localPosition;

}

//  return the (global) position of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRF::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) + 
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(localPosition); //add omega x r
}

//! return the (global) displacement of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRF::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration) - ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

//! return the rotation matrix ONLY OF reference frame (localPosition ignored), according to configuration type
Matrix3D CObjectFFRF::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
}

//! return configuration dependent angular velocity ONLY OF reference frame (localPosition ignored), according to configuration type
Vector3D CObjectFFRF::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocity(configuration);
}

//! return configuration dependent local (=body fixed) angular velocity ONLY OF reference frame (localPosition ignored), according to configuration type
Vector3D CObjectFFRF::GetAngularVelocityLocal(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     MESH NODE FUNCTIONS      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! for definition see CObjectSuperElement
void CObjectFFRF::GetAccessFunctionSuperElement(AccessFunctionType accessType, const Matrix& weightingMatrix, const ArrayIndex& meshNodeNumbers, Matrix& value) const
{
	CObjectSuperElement::GetAccessFunctionSuperElement(accessType, weightingMatrix, meshNodeNumbers, value);
}

//! get extended output variable types for multi-nodal objects with mesh nodes
OutputVariableType CObjectFFRF::GetOutputVariableTypesSuperElement(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetOutputVariableTypesSuperElement: meshNodeNumber out of range ");

	//return GetCNode(meshNodeNumber + 1)->GetOutputVariableTypes();

	//the following types are available independent of node output capabilities, as the MeshNode functions are implemented here ...
	//additional outputvariables could be added in future...
	return (OutputVariableType)(
		(Index)OutputVariableType::Position +
		(Index)OutputVariableType::Displacement +
		(Index)OutputVariableType::Velocity +
		(Index)OutputVariableType::DisplacementLocal +
		(Index)OutputVariableType::VelocityLocal);
}

//! get extended output variables for multi-nodal objects with mesh nodes
void CObjectFFRF::GetOutputVariableSuperElement(OutputVariableType variableType, Index meshNodeNumber, ConfigurationType configuration, Vector& value) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetOutputVariableSuperElement: meshNodeNumber out of range ");
	//return GetCNode(meshNodeNumber + 1)->GetOutputVariable(variableType, configuration, value);

	switch (variableType)
	{
	case OutputVariableType::Position:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration));	break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration) - GetMeshNodePosition(meshNodeNumber, ConfigurationType::Reference));	break;
	case OutputVariableType::Velocity:	value.CopyFrom(GetMeshNodeVelocity(meshNodeNumber, configuration));	break;

	case OutputVariableType::DisplacementLocal:	value.CopyFrom(GetMeshNodeLocalPosition(meshNodeNumber, configuration) - GetMeshNodeLocalPosition(meshNodeNumber, ConfigurationType::Reference));	break;
	case OutputVariableType::VelocityLocal:	value.CopyFrom(GetMeshNodeLocalVelocity(meshNodeNumber, configuration));	break;
	default:
		SysError("CObjectFFRF::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//! return the (local) position of a mesh node according to configuration type; use Configuration.Reference to access the mesh reference position; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodeLocalPosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodeLocalPosition: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	return ((CNodeODE2*)(GetCNode(meshNodeNumber + 1)))->GetPosition(configuration);
}

//! return the (local) velocity of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodeLocalVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodeLocalVelocity: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	return ((CNodeODE2*)(GetCNode(meshNodeNumber + 1)))->GetVelocity(configuration);
}

//! return the (global) position of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodePosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodePosition: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	Matrix3D refRot = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
	Vector3D refPos = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration);

	return refPos + refRot * GetMeshNodeLocalPosition(meshNodeNumber, configuration); //no "+1", because it is already the mesh function
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRF::GetMeshNodeVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRF::GetMeshNodeVelocity: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	// \dot R + A * (localVelocity +  localOmega x localPosition)
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) +
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
		(GetMeshNodeLocalVelocity(meshNodeNumber, configuration) + 
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(GetMeshNodeLocalPosition(meshNodeNumber, configuration)) );
}






