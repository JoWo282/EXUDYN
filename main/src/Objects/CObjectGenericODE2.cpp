/** ***********************************************************************************************
* @brief        CObjectGenericODE2 implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"

#include "Main/CSystemData.h"
#include "Utilities/RigidBodyMath.h"

#include "Autogenerated/CObjectGenericODE2.h"
#include "Pymodules/PybindUtilities.h"

//**delete
//#include <pybind11/pybind11.h>
//#include <pybind11/stl.h>
//#include <pybind11/stl_bind.h>
//#include <pybind11/operators.h>
//#include <pybind11/numpy.h>       //interface to numpy
//#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
//#include <pybind11/embed.h>       //scoped interpreter
////does not work globally: #include <pybind11/iostream.h> //used to redirect cout:  py::scoped_ostream_redirect output;
////#include <pybind11/cast.h> //for arguments
//#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)

//typedef py::array_t<Real> NumpyMatrix; //declaration to avoid all pybind includes


void CObjectGenericODE2::ComputeObjectCoordinates(Vector& coordinates, Vector& coordinates_t, ConfigurationType configuration) const
{
	coordinates.SetNumberOfItems(GetODE2Size());
	coordinates_t.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode(GetCNode(nn)->GetCoordinateVector(configuration));
		LinkedDataVector vNode_t(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_t(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates[cnt + i] = vNode[i];
			coordinates_t[cnt + i] = vNode_t[i];
		}
		cnt += nc;
	}

}

void CObjectGenericODE2::ComputeObjectCoordinates_tt(Vector& coordinates_tt, ConfigurationType configuration) const
{
	coordinates_tt.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode_tt(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_tt(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates_tt[cnt + i] = vNode_tt[i];
		}
		cnt += nc;
	}
}

//! Computational function: compute mass matrix
void CObjectGenericODE2::ComputeMassMatrix(Matrix& massMatrix) const
{
	if (parameters.massMatrixUserFunction)
	{
		Index nODE2 = GetODE2Size();
		Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
		Vector coordinates_t(nODE2);
		ComputeObjectCoordinates(coordinates, coordinates_t);

		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		EvaluateUserFunctionMassMatrix(massMatrix, cSystemData->GetMainSystemBacklink(), t, coordinates, coordinates_t);
	}
	else //standard constant matrix
	{
		if (parameters.massMatrix.NumberOfRows() != 0)
		{
			massMatrix = parameters.massMatrix;
		}
		else //set zero mass matrix, e.g. for static computation
		{
			Index nODE2 = GetODE2Size();
			massMatrix.SetNumberOfRowsAndColumns(nODE2, nODE2);
			massMatrix.SetAll(0.);
		}
	}
}

//! Computational function: compute right-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//in fact, this is the LHS function!
void CObjectGenericODE2::ComputeODE2LHS(Vector& ode2Lhs) const
{
	Index nODE2 = GetODE2Size();
	ode2Lhs.SetNumberOfItems(nODE2);
	ode2Lhs.SetAll(0.);

	Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
	Vector coordinates_t(nODE2);
	ComputeObjectCoordinates(coordinates, coordinates_t);

	//K*q and D*q_T put to LHS !!!

	if (parameters.stiffnessMatrix.NumberOfRows() != 0)
	{
		EXUmath::MultMatrixVectorAdd(parameters.stiffnessMatrix, coordinates, ode2Lhs);
	}

	if (parameters.dampingMatrix.NumberOfRows() != 0)
	{
		EXUmath::MultMatrixVectorAdd(parameters.dampingMatrix, coordinates_t, ode2Lhs);
	}

	if (parameters.forceVector.NumberOfItems() != 0)
	{
		ode2Lhs -= parameters.forceVector;
	}

	if (parameters.forceUserFunction)
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		Vector userForce;

		EvaluateUserFunctionForce(userForce, cSystemData->GetMainSystemBacklink(), t, coordinates, coordinates_t);

		ode2Lhs -= userForce;
	}

}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectGenericODE2::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::AngularVelocity_qt +
		(Index)AccessFunctionType::DisplacementMassIntegral_q + (Index)AccessFunctionType::SuperElement);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectGenericODE2::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	SysError("CObjectGenericODE2:GetAccessFunctionBody not available");
}

//! provide according output variable in "value"
void CObjectGenericODE2::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value) const
{
	Index nODE2 = GetODE2Size();
	Vector coordinates(nODE2);
	Vector coordinates_t(nODE2);
	ComputeObjectCoordinates(coordinates, coordinates_t, configuration);

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(coordinates);	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(coordinates_t);	break;
	case OutputVariableType::Coordinates_tt: 
	{
		Vector coordinates_tt(nODE2);
		ComputeObjectCoordinates_tt(coordinates_tt, configuration);
		value.CopyFrom(coordinates_tt);
		break;
	}
	case OutputVariableType::Force:			ComputeODE2LHS(value);	break;
	default:
		SysError("CObjectGenericODE2::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetPosition: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) + localPosition;

}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetVelocity: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetVelocity(configuration);
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetDisplacement: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) - ((CNodeODE2*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

Index CObjectGenericODE2::GetODE2Size() const
{
	//Index s = 0;
	//for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	//{
	//	s += GetCNode(i)->GetNumberOfODE2Coordinates();
	//}
	//return s;

	//faster version, does not require iterations:
	Index nn = parameters.nodeNumbers.NumberOfItems();
	if (nn) { return parameters.coordinateIndexPerNode.Last() + GetCNode(nn - 1)->GetNumberOfODE2Coordinates(); }
	else { return 0; }
}

void CObjectGenericODE2::InitializeCoordinateIndices()
{
	parameters.coordinateIndexPerNode.SetNumberOfItems(parameters.nodeNumbers.NumberOfItems());

	Index s = 0;
	for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	{
		parameters.coordinateIndexPerNode[i] = s;
		if (!EXUstd::IndexIsInRange(parameters.nodeNumbers[i], 0, cSystemData->GetCNodes().NumberOfItems()))
		{
			PyError("ObjectGenericODE2: invalid node number detected; alle nodes used in ObjectGenericODE2 must already exist");
		}
		else
		{
			s += GetCNode(i)->GetNumberOfODE2Coordinates();
		}
	}
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     MESH NODE FUNCTIONS      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! for definition see CObjectSuperElement
void CObjectGenericODE2::GetAccessFunctionSuperElement(AccessFunctionType accessType, const Matrix& weightingMatrix, const ArrayIndex& meshNodeNumbers, Matrix& value) const
{
	CObjectSuperElement::GetAccessFunctionSuperElement(accessType, weightingMatrix, meshNodeNumbers, value);
	//switch ((Index)accessType)
	//{
	//case (Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::SuperElement: //global translational velocity at mesh position derivative w.r.t. all q_t: without reference frame: [0,..., 0, w0*nodeJac0, 0, ..., 0, w1*nodeJac1, 0,...]; with reference frame: [I, -A * pLocalTilde * Glocal, A*(0,...,0, w0*nodeJac0, 0,..., 0, w1*nodeJac1, ...)]
	//{
	//	value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
	//	value.SetAll(0.);

	//	Matrix3D A;
	//	Index localReferenceNodeIndex;
	//	bool hasReferenceFrame = HasReferenceFrame(localReferenceNodeIndex);
	//	Index refFrameOffset = 0;

	//	if (hasReferenceFrame)
	//	{
	//		A = ((const CNodeODE2*)(GetCNode(localReferenceNodeIndex)))->GetRotationMatrix();
	//		refFrameOffset++;
	//	}
	//	else
	//	{
	//		A = EXUmath::unitMatrix3D;
	//	}

	//	//Index cOffset = 0; //coordinates offset
	//	for (Index i = 0; i < meshNodeNumbers.NumberOfItems(); i++)
	//	{
	//		Index iNode = meshNodeNumbers[i] + refFrameOffset;

	//		if (GetCNode(iNode)->GetNumberOfODE2Coordinates() >= CNodeRigidBody::maxDisplacementCoordinates + CNodeRigidBody::maxRotationCoordinates) { CHECKandTHROWstring("CObjectGenericODE2::GetAccessFunctionSuperElement: MarkerSuperElement only available in case of nodes with equal or less than 7 coordinates!"); }

	//		//use temporary jacobian structure, to get node jacobian
	//		ConstSizeMatrix<CNodeRigidBody::nDim3D * (CNodeRigidBody::maxDisplacementCoordinates + CNodeRigidBody::maxRotationCoordinates)> posJac0;
	//		((const CNodeODE2*)GetCNode(iNode))->GetPositionJacobian(posJac0);

	//		//assume that the first 3 coordinates of the node are the displacement coordinates!!!
	//		Matrix3D jac = A;
	//		if (weightingMatrix.NumberOfColumns() == 1)
	//		{
	//			jac *= weightingMatrix(i, 0);
	//		}
	//		else
	//		{
	//			for (Index j = 0; j < 3; j++)
	//			{
	//				for (Index k = 0; k < 3; k++)
	//				{
	//					jac(j, k) *= weightingMatrix(i, k); //add weighting to columns, because every column corresponds to local x,y and z direction (weigthing effects needed on local coordinates)
	//				}
	//			}
	//		}
	//		EXUmath::ApplyTransformation<3>(jac, posJac0); //size=3: always 3D

	//		Index offset = GetLocalODE2CoordinateIndexPerNode(iNode); //gives correct coordinates also in case of referenceFrame node
	//		//pout << "offsetFFRF" << i << "=" << offset << "\n";
	//		value.SetSubmatrix(posJac0, 0, offset);
	//	}
	//	//pout << "posJac=" << markerData.positionJacobian << "\n";

	//	if (hasReferenceFrame)
	//	{
	//		//\partial vMarker / \partial q_t = [I, -A * pLocalTilde * Glocal, A*(w0*nodeJac0, w1*nodeJac1, ...)]

	//		Vector3D localPosition({ 0,0,0 });
	//		for (Index i = 0; i < meshNodeNumbers.NumberOfItems(); i++)
	//		{
	//			if (weightingMatrix.NumberOfColumns() == 1)
	//			{
	//				localPosition += weightingMatrix(i, 0) * GetMeshNodeLocalPosition(meshNodeNumbers[i]); //((const CNodeODE2&)cSystemData.GetCNode(cObject.GetNodeNumber(nodeNumbers[i]))).GetPosition();
	//			}
	//			else
	//			{
	//				for (Index j = 0; j < 3; j++)
	//				{
	//					localPosition[j] += weightingMatrix(i, j) * GetMeshNodeLocalPosition(meshNodeNumbers[i])[j]; //((const CNodeODE2&)cSystemData.GetCNode(cObject.GetNodeNumber(nodeNumbers[i]))).GetPosition();
	//				}
	//			}
	//		}

	//		const CNodeRigidBody* cNode = (const CNodeRigidBody*)GetCNode(localReferenceNodeIndex);

	//		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::nDim3D> Glocal;

	//		//compute: -A*pLocalTilde*GLocal
	//		cNode->GetGlocal(Glocal);
	//		EXUmath::ApplyTransformation<3>(RigidBodyMath::Vector2SkewMatrixTemplate(-localPosition), Glocal);
	//		EXUmath::ApplyTransformation<3>(A, Glocal);

	//		//now compute remaining jacobian terms for reference frame motion:
	//		ConstSizeMatrix<CNodeRigidBody::nDim3D * (CNodeRigidBody::maxDisplacementCoordinates + CNodeRigidBody::maxRotationCoordinates)> posJac0;
	//		((const CNodeODE2*)GetCNode(referenceNodeIndex))->GetPositionJacobian(posJac0);

	//		value.SetSubmatrix(posJac0, 0, 0);
	//		value.SetSubmatrix(Glocal, 0, CNodeRigidBody::maxDisplacementCoordinates);
	//	}
	//	break;
	//}
	//default:
	//	CHECKandTHROWstring("CObjectGenericODE2:GetAccessFunctionSuperElement illegal accessType");
	//}
}

//! get extended output variable types for multi-nodal objects with mesh nodes
OutputVariableType CObjectGenericODE2::GetOutputVariableTypesSuperElement(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetOutputVariableTypesSuperElement: meshNodeNumber out of range ");

	return GetCNode(meshNodeNumber)->GetOutputVariableTypes();
}

//! get extended output variables for multi-nodal objects with mesh nodes
void CObjectGenericODE2::GetOutputVariableSuperElement(OutputVariableType variableType, Index meshNodeNumber, ConfigurationType configuration, Vector& value) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetOutputVariableSuperElement: meshNodeNumber out of range ");
	return GetCNode(meshNodeNumber)->GetOutputVariable(variableType, configuration, value);
}

//! return the (local) position of a mesh node according to configuration type; use Configuration.Reference to access the mesh reference position; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodeLocalPosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodeLocalPosition: meshNodeNumber out of range");
	
	return ((CNodeODE2*)(GetCNode(meshNodeNumber)))->GetPosition(configuration);
}

//! return the (local) velocity of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodeLocalVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodeLocalVelocity: meshNodeNumber out of range ");

	return ((CNodeODE2*)(GetCNode(meshNodeNumber)))->GetVelocity(configuration);
}

//! return the (global) position of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodePosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodePosition: meshNodeNumber out of range");
	//if (parameters.useFirstNodeAsReferenceFrame)
	//{
	//	Matrix3D refRot = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
	//	Vector3D refPos = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration);

	//	return refPos + refRot * GetMeshNodeLocalPosition(meshNodeNumber, configuration); //no "+1", because it is already the mesh function
	//}
	//else
	//{
	return GetMeshNodeLocalPosition(meshNodeNumber, configuration);
	//}
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodeVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodeVelocity: meshNodeNumber out of range");

	//if (parameters.useFirstNodeAsReferenceFrame)
	//{
	//	// \dot R + A * \localOmega x \localPosition
	//	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) +
	//		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
	//		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(GetMeshNodeLocalPosition(meshNodeNumber, configuration)) +
	//		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) * GetMeshNodeLocalVelocity(meshNodeNumber, configuration);
	//}
	//else
	//{
	return GetMeshNodeLocalVelocity(meshNodeNumber, configuration);
	//}
}

