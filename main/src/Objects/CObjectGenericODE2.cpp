/** ***********************************************************************************************
* @brief        CObjectGenericODE2 implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"

#include "Main/CSystemData.h"
#include "Utilities/RigidBodyMath.h"

#include "Autogenerated/CObjectGenericODE2.h"
#include "Pymodules/PybindUtilities.h"

//**delete
//#include <pybind11/pybind11.h>
//#include <pybind11/stl.h>
//#include <pybind11/stl_bind.h>
//#include <pybind11/operators.h>
//#include <pybind11/numpy.h>       //interface to numpy
//#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
//#include <pybind11/embed.h>       //scoped interpreter
////does not work globally: #include <pybind11/iostream.h> //used to redirect cout:  py::scoped_ostream_redirect output;
////#include <pybind11/cast.h> //for arguments
//#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)

//typedef py::array_t<Real> NumpyMatrix; //declaration to avoid all pybind includes


void CObjectGenericODE2::ComputeObjectCoordinates(Vector& coordinates, Vector& coordinates_t, ConfigurationType configuration) const
{
	coordinates.SetNumberOfItems(GetODE2Size());
	coordinates_t.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode(GetCNode(nn)->GetCoordinateVector(configuration));
		LinkedDataVector vNode_t(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_t(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates[cnt + i] = vNode[i];
			coordinates_t[cnt + i] = vNode_t[i];
		}
		cnt += nc;
	}

}

void CObjectGenericODE2::ComputeObjectCoordinates_tt(Vector& coordinates_tt, ConfigurationType configuration) const
{
	coordinates_tt.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode_tt(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_tt(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates_tt[cnt + i] = vNode_tt[i];
		}
		cnt += nc;
	}
}

//! Computational function: compute mass matrix
void CObjectGenericODE2::ComputeMassMatrix(Matrix& massMatrix, Index objectNumber) const
{
	if (parameters.massMatrixUserFunction)
	{
		Index nODE2 = GetODE2Size();
		//Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
		//Vector coordinates_t(nODE2);
		tempCoordinates.SetNumberOfItems(nODE2);
		tempCoordinates_t.SetNumberOfItems(nODE2);
		ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);

		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		EvaluateUserFunctionMassMatrix(massMatrix, cSystemData->GetMainSystemBacklink(), t, objectNumber, tempCoordinates, tempCoordinates_t);
	}
	else //standard constant matrix
	{
		if (parameters.massMatrix.NumberOfRows() != 0)
		{
			massMatrix = parameters.massMatrix;
		}
		else //set zero mass matrix, e.g. for static computation
		{
			Index nODE2 = GetODE2Size();
			massMatrix.SetNumberOfRowsAndColumns(nODE2, nODE2);
			massMatrix.SetAll(0.);
		}
	}
}

//! Computational function: compute right-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//in fact, this is the LHS function!
void CObjectGenericODE2::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	Index nODE2 = GetODE2Size();
	ode2Lhs.SetNumberOfItems(nODE2);
	ode2Lhs.SetAll(0.);

	//Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
	//Vector coordinates_t(nODE2);
	tempCoordinates.SetNumberOfItems(nODE2);
	tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t);

	//K*q and D*q_T put to LHS !!!

	if (parameters.stiffnessMatrix.NumberOfRows() != 0)
	{
		EXUmath::MultMatrixVectorAdd(parameters.stiffnessMatrix, tempCoordinates, ode2Lhs);
	}

	if (parameters.dampingMatrix.NumberOfRows() != 0)
	{
		EXUmath::MultMatrixVectorAdd(parameters.dampingMatrix, tempCoordinates_t, ode2Lhs);
	}

	if (parameters.forceVector.NumberOfItems() != 0)
	{
		ode2Lhs -= parameters.forceVector;
	}

	if (parameters.forceUserFunction)
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		Vector userForce;

		EvaluateUserFunctionForce(userForce, cSystemData->GetMainSystemBacklink(), t, objectNumber, tempCoordinates, tempCoordinates_t);

		ode2Lhs -= userForce;
	}

}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectGenericODE2::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::AngularVelocity_qt +
		(Index)AccessFunctionType::DisplacementMassIntegral_q + (Index)AccessFunctionType::SuperElement);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectGenericODE2::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	SysError("CObjectGenericODE2:GetAccessFunctionBody not available");
}

//! provide according output variable in "value"
void CObjectGenericODE2::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	Index nODE2 = GetODE2Size();
	//Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
	//Vector coordinates_t(nODE2);
	tempCoordinates.SetNumberOfItems(nODE2);
	tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates, tempCoordinates_t, configuration);

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(tempCoordinates);	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(tempCoordinates_t);	break;
	case OutputVariableType::Coordinates_tt: 
	{
		//Vector coordinates_tt(nODE2);
		tempCoordinates_tt.SetNumberOfItems(nODE2);
		ComputeObjectCoordinates_tt(tempCoordinates_tt, configuration);
		value.CopyFrom(tempCoordinates_tt);
		break;
	}
	case OutputVariableType::Force:			ComputeODE2LHS(value, objectNumber);	break;
	default:
		SysError("CObjectGenericODE2::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetPosition: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) + localPosition;

}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetVelocity: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetVelocity(configuration);
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetDisplacement: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) - ((CNodeODE2*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

Index CObjectGenericODE2::GetODE2Size() const
{
	//Index s = 0;
	//for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	//{
	//	s += GetCNode(i)->GetNumberOfODE2Coordinates();
	//}
	//return s;

	//faster version, does not require iterations:
	Index nn = parameters.nodeNumbers.NumberOfItems();
	if (nn) { return parameters.coordinateIndexPerNode.Last() + GetCNode(nn - 1)->GetNumberOfODE2Coordinates(); }
	else { return 0; }
}

void CObjectGenericODE2::InitializeCoordinateIndices()
{
	parameters.coordinateIndexPerNode.SetNumberOfItems(parameters.nodeNumbers.NumberOfItems());

	Index s = 0;
	for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	{
		parameters.coordinateIndexPerNode[i] = s;
		if (!EXUstd::IndexIsInRange(parameters.nodeNumbers[i], 0, cSystemData->GetCNodes().NumberOfItems()))
		{
			PyError("ObjectGenericODE2: invalid node number detected; all nodes used in ObjectGenericODE2 must already exist");
		}
		else
		{
			s += GetCNode(i)->GetNumberOfODE2Coordinates();
		}
	}
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     MESH NODE FUNCTIONS      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! for definition see CObjectSuperElement
void CObjectGenericODE2::GetAccessFunctionSuperElement(AccessFunctionType accessType, const Matrix& weightingMatrix, const ArrayIndex& meshNodeNumbers, Matrix& value) const
{
	CObjectSuperElement::GetAccessFunctionSuperElement(accessType, weightingMatrix, meshNodeNumbers, value);
}

//! get extended output variable types for multi-nodal objects with mesh nodes
OutputVariableType CObjectGenericODE2::GetOutputVariableTypesSuperElement(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetOutputVariableTypesSuperElement: meshNodeNumber out of range ");

	return GetCNode(meshNodeNumber)->GetOutputVariableTypes();
}

//! get extended output variables for multi-nodal objects with mesh nodes
void CObjectGenericODE2::GetOutputVariableSuperElement(OutputVariableType variableType, Index meshNodeNumber, ConfigurationType configuration, Vector& value) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetOutputVariableSuperElement: meshNodeNumber out of range ");
	return GetCNode(meshNodeNumber)->GetOutputVariable(variableType, configuration, value);
}

//! return the (local) position of a mesh node according to configuration type; use Configuration.Reference to access the mesh reference position; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodeLocalPosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodeLocalPosition: meshNodeNumber out of range");
	
	return ((CNodeODE2*)(GetCNode(meshNodeNumber)))->GetPosition(configuration);
}

//! return the (local) velocity of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodeLocalVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodeLocalVelocity: meshNodeNumber out of range ");

	return ((CNodeODE2*)(GetCNode(meshNodeNumber)))->GetVelocity(configuration);
}

//! return the (global) position of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodePosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodePosition: meshNodeNumber out of range");
	//if (parameters.useFirstNodeAsReferenceFrame)
	//{
	//	Matrix3D refRot = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
	//	Vector3D refPos = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration);

	//	return refPos + refRot * GetMeshNodeLocalPosition(meshNodeNumber, configuration); //no "+1", because it is already the mesh function
	//}
	//else
	//{
	return GetMeshNodeLocalPosition(meshNodeNumber, configuration);
	//}
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectGenericODE2::GetMeshNodeVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectGenericODE2::GetMeshNodeVelocity: meshNodeNumber out of range");

	//if (parameters.useFirstNodeAsReferenceFrame)
	//{
	//	// \dot R + A * \localOmega x \localPosition
	//	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) +
	//		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
	//		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(GetMeshNodeLocalPosition(meshNodeNumber, configuration)) +
	//		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) * GetMeshNodeLocalVelocity(meshNodeNumber, configuration);
	//}
	//else
	//{
	return GetMeshNodeLocalVelocity(meshNodeNumber, configuration);
	//}
}

