/** ***********************************************************************************************
* @brief        CObjectGenericODE2 implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */

#include "Main/CSystemData.h"

#include "Main/MainSystem.h"
#include "Pymodules/PybindUtilities.h"
#include "Autogenerated/MainObjectGenericODE2.h"



#include "Autogenerated/CObjectGenericODE2.h"

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/stl_bind.h>
#include <pybind11/operators.h>
#include <pybind11/numpy.h>       //interface to numpy
#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
#include <pybind11/embed.h>       //scoped interpreter
//does not work globally: #include <pybind11/iostream.h> //used to redirect cout:  py::scoped_ostream_redirect output;
//#include <pybind11/cast.h> //for arguments
#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)

//typedef py::array_t<Real> NumpyMatrix; //declaration to avoid all pybind includes

bool MainObjectGenericODE2::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectGenericODE2* cObject = (CObjectGenericODE2*)GetCObject();

	if (cObject->GetParameters().nodeNumbers.NumberOfItems() == 0)
	{
		errorString = "ObjectGenericODE2: has 0 nodes, but must have at least 1 node";
		return false;
	}

	//check specific node types
	for (Index nn = 0; nn < cObject->GetParameters().nodeNumbers.NumberOfItems(); nn++)
	//for (auto item : cObject->GetParameters().nodeNumbers)
	{
		if (!EXUstd::IsOfType((Node::Type)( Node::GenericODE2 + Node::Position2D + Node::Orientation2D + Node::Point2DSlope1 + Node::Position + Node::Orientation + Node::RigidBody), cObject->GetCNode(nn)->GetType()))
		{
			errorString = "ObjectGenericODE2: local node " + EXUstd::ToString(nn) + " has invalide node type " + EXUstd::ToString(Node::GetTypeString(cObject->GetCNode(nn)->GetType())) + ", but should be ODE2 node";
				return false;
		}
	}



	//now check size of vectors and matrices
	Index nODE2 = cObject->GetODE2Size();

	Index nForce = cObject->GetParameters().forceVector.NumberOfItems();
	if (nForce != nODE2 && nForce != 0)
	{
		errorString = "ObjectGenericODE2: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but forceVector has size " + EXUstd::ToString(nForce);
		return false;
	}

	Index rowsMass = cObject->GetParameters().massMatrix.NumberOfRows();
	Index columnsMass = cObject->GetParameters().massMatrix.NumberOfColumns();
	if (!(rowsMass == nODE2 && columnsMass == nODE2)) //mass matrix always must exist
	{
		errorString = "ObjectGenericODE2: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but mass matrix has size (" + EXUstd::ToString(rowsMass) + " x " + EXUstd::ToString(columnsMass) + ")";
		return false;
	}

	Index rowsStiffness = cObject->GetParameters().stiffnessMatrix.NumberOfRows();
	Index columnsStiffness = cObject->GetParameters().stiffnessMatrix.NumberOfColumns();
	if (!(rowsStiffness == nODE2 && columnsStiffness == nODE2) && !((rowsStiffness == 0 && columnsStiffness == 0)))
	{
		errorString = "ObjectGenericODE2: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but stiffness matrix has size (" + EXUstd::ToString(rowsStiffness) + " x " + EXUstd::ToString(columnsStiffness) + ")";
		return false;
	}

	Index rowsDamping = cObject->GetParameters().dampingMatrix.NumberOfRows();
	Index columnsDamping = cObject->GetParameters().dampingMatrix.NumberOfColumns();
	if (!(rowsDamping == nODE2 && columnsDamping == nODE2) && !((rowsDamping == 0 && columnsDamping == 0)))
	{
		errorString = "ObjectGenericODE2: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but damping matrix has size (" + EXUstd::ToString(rowsDamping) + " x " + EXUstd::ToString(columnsDamping) + ")";
		return false;
	}


	return true;
}


void CObjectGenericODE2::ComputeObjectCoordinates(Vector& coordinates, Vector& coordinates_t, ConfigurationType configuration) const
{
	coordinates.SetNumberOfItems(GetODE2Size());
	coordinates_t.SetNumberOfItems(GetODE2Size());
	Index cnt = 0;
	for (Index nn = 0; nn < parameters.nodeNumbers.NumberOfItems(); nn++)
	{
		Index nc = GetCNode(nn)->GetNumberOfODE2Coordinates();
		LinkedDataVector vNode(GetCNode(nn)->GetCoordinateVector(configuration));
		LinkedDataVector vNode_t(((CNodeODE2*)GetCNode(nn))->GetCoordinateVector_t(configuration));
		for (Index i = 0; i < nc; i++)
		{
			coordinates[cnt + i] = vNode[i];
			coordinates_t[cnt + i] = vNode_t[i];
		}
		cnt += nc;
	}

}

//! Computational function: compute mass matrix
void CObjectGenericODE2::ComputeMassMatrix(Matrix& massMatrix) const
{
	if (parameters.massMatrixUserFunction)
	{
		Index nODE2 = GetODE2Size();
		Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
		Vector coordinates_t(nODE2);
		ComputeObjectCoordinates(coordinates, coordinates_t);

		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		EPyUtils::NumPy2Matrix(parameters.massMatrixUserFunction(t, coordinates, coordinates_t), massMatrix);
	}
	else //standard constant matrix
	{
		massMatrix = parameters.massMatrix;
	}
}

//! Computational function: compute right-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2rhs"
//in fact, this is the LHS function!
void CObjectGenericODE2::ComputeODE2RHS(Vector& ode2Rhs) const
{
	Index nODE2 = GetODE2Size();
	ode2Rhs.SetNumberOfItems(nODE2);
	ode2Rhs.SetAll(0.);

	Vector coordinates(nODE2); //leads to new==> change to direct matrix multiplication / add with nodal coordinates
	Vector coordinates_t(nODE2);
	ComputeObjectCoordinates(coordinates, coordinates_t);

	//K*q and D*q_T put to LHS !!!

	if (parameters.stiffnessMatrix.NumberOfRows() != 0)
	{
		EXUmath::MultMatrixVectorAdd(parameters.stiffnessMatrix, coordinates, ode2Rhs);
	}

	if (parameters.dampingMatrix.NumberOfRows() != 0)
	{
		EXUmath::MultMatrixVectorAdd(parameters.dampingMatrix, coordinates_t, ode2Rhs);
	}

	if (parameters.forceVector.NumberOfItems() != 0)
	{
		ode2Rhs -= parameters.forceVector;
	}

	if (parameters.forceUserFunction)
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();
		Vector userForce(parameters.forceUserFunction(t, coordinates, coordinates_t));
		ode2Rhs -= userForce;
	}

}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectGenericODE2::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::_None);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectGenericODE2::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	SysError("CObjectGenericODE2:GetAccessFunctionBody not available");
}

//! provide according output variable in "value"
void CObjectGenericODE2::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value) const
{
	Index nODE2 = GetODE2Size();
	Vector coordinates(nODE2);
	Vector coordinates_t(nODE2);
	ComputeObjectCoordinates(coordinates, coordinates_t, configuration);

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(coordinates);	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(coordinates_t);	break;
	case OutputVariableType::Force:			ComputeODE2RHS(value);	break;
	default:
		SysError("CObjectGenericODE2::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//! @todo: add ConfigurationType to CObjectMassPoint::GetPosition; 
//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetPosition: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) + localPosition;

}

//! @todo: add ConfigurationType to CObjectMassPoint::GetPosition; 
//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetVelocity: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetVelocity(configuration);
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectGenericODE2::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	CHECKandTHROWstring("CObjectGenericODE2::GetDisplacement: function not available");
	return { 0,0,0 };
	//return ((CNodeODE2*)GetCNode(0))->GetPosition(configuration) - ((CNodeODE2*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

Index CObjectGenericODE2::GetODE2Size() const
{
	Index s = 0;
	for (Index i = 0; i < parameters.nodeNumbers.NumberOfItems(); i++)
	{
		s += GetCNode(i)->GetNumberOfODE2Coordinates();
	}
	return s;
}