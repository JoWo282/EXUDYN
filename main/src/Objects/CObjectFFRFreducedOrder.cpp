/** ***********************************************************************************************
* @brief        CObjectFFRFreducedOrder implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"
#include "Main/CSystemData.h"

#include "Main/MainSystem.h"
#include "Pymodules/PybindUtilities.h"
#include "Autogenerated/MainObjectFFRFreducedOrder.h"

#include "Autogenerated/CObjectFFRFreducedOrder.h"
#include "Utilities/RigidBodyMath.h"

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/stl_bind.h>
#include <pybind11/operators.h>
#include <pybind11/numpy.h>       //interface to numpy
#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
#include <pybind11/embed.h>       //scoped interpreter
//does not work globally: #include <pybind11/iostream.h> //used to redirect cout:  py::scoped_ostream_redirect output;
//#include <pybind11/cast.h> //for arguments
#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)

//#define computeFFRFfullTerms

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

bool MainObjectFFRFreducedOrder::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	CObjectFFRFreducedOrder* cObject = (CObjectFFRFreducedOrder*)GetCObject();

	Index numberOfNodes = cObject->GetNumberOfNodes();
	Index numberOfMeshNodes = cObject->GetNumberOfMeshNodes();

	//Index nODE2test = cObject->GetODE2Size(); //NOT AVAILABLE YET
	
	Index nODE2Rigid = cObject->GetCNode(cObject->rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = cObject->GetCNode(cObject->genericNodeNumber)->GetNumberOfODE2Coordinates();
	Index nODE2 = nODE2Rigid+nODE2FF; //total number of coordinates

	if (numberOfNodes != 2)
	{
		errorString = "ObjectFFRFreducedOrder: has " + EXUstd::ToString(numberOfNodes) + " nodes, but must have 2 nodes (one rigid body node and one generic ODE2 node)";
		return false;
	}

	//check specific node types
	for (Index nn = 0; nn < numberOfNodes; nn++)
	{
		//if (!EXUstd::IsOfType((Node::Type)(Node::GenericODE2 + Node::Position2D + Node::Orientation2D + Node::Point2DSlope1 + Node::Position + Node::Orientation + Node::RigidBody),
		//	cObject->GetCNode(nn)->GetType()))
		if (((Index)cObject->GetCNode(nn)->GetNodeGroup() & (Index)CNodeGroup::ODE2variables) == 0)
		{
			errorString = "ObjectFFRFreducedOrder: local node " + EXUstd::ToString(nn) + " has invalide node type " + EXUstd::ToString(Node::GetTypeString(cObject->GetCNode(nn)->GetType())) + ", but should be ODE2 node (node group ODE2variables)";
				return false;
		}
	}

	if (!EXUstd::IsOfType(cObject->GetCNode(CObjectFFRFreducedOrder::rigidBodyNodeNumber)->GetType(), (Node::Type)(Node::RigidBody)))
	{
		errorString = "ObjectFFRFreducedOrder: local node 0 must be of type 'Node.RigidBody'";
		return false;
	}

	//Index nForce = cObject->GetParameters().forceVector.NumberOfItems();
	//if (nForce != nODE2 && nForce != 0)
	//{
	//	errorString = "ObjectFFRFreducedOrder: total ODE2 coordinates of nodes is " + EXUstd::ToString(nODE2) + ", but forceVector has size " + EXUstd::ToString(nForce);
	//	return false;
	//}

	Index rowsMass = cObject->GetParameters().massMatrixReduced.NumberOfRows();
	Index columnsMass = cObject->GetParameters().massMatrixReduced.NumberOfColumns();
	if (!(rowsMass == nODE2FF && columnsMass == nODE2FF))
	{
		if (rowsMass == 0 && columnsMass == 0)
		{
			if (cObject->GetParameters().computeFFRFterms)
			{
				errorString = "ObjectFFRFreducedOrder: massMatrixReduced must be specified if computeFFRFterms = True";
				return false;
			}
		}
		else
		{
			errorString = "ObjectFFRFreducedOrder: number of flexible coordinates of object is " + EXUstd::ToString(nODE2FF) + ", but mass matrix has size (" + EXUstd::ToString(rowsMass) + " x " + EXUstd::ToString(columnsMass) + ")";
			return false;
		}
	}

	Index rowsStiffness = cObject->GetParameters().stiffnessMatrixReduced.NumberOfRows();
	Index columnsStiffness = cObject->GetParameters().stiffnessMatrixReduced.NumberOfColumns();
	if (!(rowsStiffness == nODE2FF && columnsStiffness == nODE2FF))
	{
		if (rowsStiffness == 0 && columnsStiffness == 0)
		{
			if (cObject->GetParameters().computeFFRFterms)
			{
				errorString = "ObjectFFRFreducedOrder: stiffnessMatrixReduced must be specified if computeFFRFterms = True";
				return false;
			}
		}
		else
		{
			errorString = "ObjectFFRFreducedOrder: number of flexible coordinates of object is " + EXUstd::ToString(nODE2FF) + ", but stiffnessMatrixFF has size (" + EXUstd::ToString(rowsStiffness) + " x " + EXUstd::ToString(columnsStiffness) + ")";
			return false;
		}
	}

	Index rowsDamping = cObject->GetParameters().dampingMatrixReduced.NumberOfRows();
	Index columnsDamping = cObject->GetParameters().dampingMatrixReduced.NumberOfColumns();
	if (!(rowsDamping == nODE2FF && columnsDamping == nODE2FF) && !((rowsDamping == 0 && columnsDamping == 0)))
	{
		errorString = "ObjectFFRFreducedOrder: number of flexible coordinates of object is " + EXUstd::ToString(nODE2FF) + ", but dampingMatrixReduced has size (" + EXUstd::ToString(rowsDamping) + " x " + EXUstd::ToString(columnsDamping) + ")";
		return false;
	}

	//check node reference positions and mode Basis
	Index modeRows = cObject->GetParameters().modeBasis.NumberOfRows();
	if (cObject->GetParameters().referencePositions.NumberOfItems()%3 != 0)
	{
		errorString = "ObjectFFRFreducedOrder: referencePositions must have a length of mesh nodes * 3, but has length " + EXUstd::ToString(cObject->GetParameters().referencePositions.NumberOfItems());
		return false;
	}
	if (cObject->GetParameters().modeBasis.NumberOfColumns() != nODE2FF)
	{
		errorString = "ObjectFFRFreducedOrder: number of modal coordinates (NodeGenericODE2) " + EXUstd::ToString(nODE2FF) +
			", but number of columns in modeBasis = " + EXUstd::ToString(cObject->GetParameters().modeBasis.NumberOfColumns());
		return false;
	}
	if (modeRows != cObject->GetNumberOfMeshNodes()*3)
	{
		errorString = "ObjectFFRFreducedOrder: number of full coordinates (rows in modeBasis) " + EXUstd::ToString(modeRows) +
			", but number of mesh nodes * 3 = " + EXUstd::ToString(cObject->GetNumberOfMeshNodes() * 3);
		return false;
	}

	//check visualization
	VisualizationObjectFFRFreducedOrder* vObject = (VisualizationObjectFFRFreducedOrder*)GetVisualizationObject();
	if (vObject->GetTriangleMesh().NumberOfRows() != 0)
	{
		if (vObject->GetTriangleMesh().NumberOfColumns() != 3)
		{
			errorString = "ObjectFFRFreducedOrder: number of columns in triangleMesh must be 3";
			return false;
		}

		auto& trigs = vObject->GetTriangleMesh();
		for (Index i = 0; i < trigs.NumberOfRows(); i++)
		{
			for (Index j = 0; j < trigs.NumberOfColumns(); j++)
			{
				if (trigs(i, j) >= cObject->GetNumberOfMeshNodes())
				{
					errorString = "ObjectFFRFreducedOrder: node number in triangleMesh(" + EXUstd::ToString(i) + "," + EXUstd::ToString(j) + ") is invalid; valid node numbers: 0 .. " + EXUstd::ToString(cObject->GetNumberOfMeshNodes());
					return false;
				}
			}
		}
	}


	return true;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CObjectFFRFreducedOrder::ComputeObjectCoordinates(Vector& coordinates, ConfigurationType configuration) const
{
	Index nODE2Rigid = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
	coordinates.SetNumberOfItems(GetODE2Size());

	LinkedDataVector coordinatesRR(coordinates, 0, nODE2Rigid);
	LinkedDataVector coordinatesFF(coordinates, nODE2Rigid, nODE2FF);

	coordinatesRR = GetCNode(rigidBodyNodeNumber)->GetCoordinateVector(configuration);
	coordinatesFF = GetCNode(genericNodeNumber)->GetCoordinateVector(configuration);
}

void CObjectFFRFreducedOrder::ComputeObjectCoordinates_t(Vector& coordinates_t, ConfigurationType configuration) const
{
	Index nODE2Rigid = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
	coordinates_t.SetNumberOfItems(GetODE2Size());

	LinkedDataVector coordinates_tRR(coordinates_t, 0, nODE2Rigid);
	LinkedDataVector coordinates_tFF(coordinates_t, nODE2Rigid, nODE2FF);

	coordinates_tRR = ((CNodeODE2*)GetCNode(rigidBodyNodeNumber))->GetCoordinateVector_t(configuration);
	coordinates_tFF = ((CNodeODE2*)GetCNode(genericNodeNumber))->GetCoordinateVector_t(configuration);
}

Index CObjectFFRFreducedOrder::GetODE2Size() const
{
	return GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates() + GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! Computational function: compute mass matrix
void CObjectFFRFreducedOrder::ComputeMassMatrix(Matrix& massMatrix) const
{
//#define CObjectFFRFreducedOrderComputeMassMatrixOutput

	Index nODE2Rigid = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
	Index nODE2 = nODE2Rigid + nODE2FF; //total number of coordinates
	if (parameters.massMatrixUserFunction)
	{
		tempCoordinates.SetNumberOfItems(nODE2);
		tempCoordinates_t.SetNumberOfItems(nODE2);
		ComputeObjectCoordinates(tempCoordinates);
		ComputeObjectCoordinates_t(tempCoordinates_t);

		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		{
			//user function args:(t, coordinates, coordinates_t)
			EPyUtils::NumPy2Matrix(parameters.massMatrixUserFunction(t, tempCoordinates, tempCoordinates_t), massMatrix);
		}, "ObjectFFRFreducedOrder::massMatrixUserFunction");
	}
	else //initialize with zero
	{
		massMatrix.SetNumberOfRowsAndColumns(nODE2, nODE2);
		massMatrix.SetAll(0.);
	}
	if (parameters.computeFFRFterms)
	{
#ifdef computeFFRFfullTerms

		tempCoordinates.SetNumberOfItems(nODE2); 
		tempCoordinates_t.SetNumberOfItems(nODE2); 
		LinkedDataVector coordinatesFF(tempCoordinates, nODE2Rigid, nODE2FF);
		//LinkedDataVector coordinatesFF_t(tempCoordinates_t, nODE2Rigid, nODE2FF);

		ComputeObjectCoordinates(coordinates);
		ComputeObjectCoordinates_t(coordinates_t);
		const Index GMaxSize = CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D; //12

		ConstSizeMatrix<GMaxSize> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);
		ConstSizeMatrix<GMaxSize> GlocalT;
		GlocalT = Glocal.GetTransposed();


		Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix();

		coordinatesFF += parameters.referencePositions; //this are now the local nodal positions for mesh (FF) coordinates

		RigidBodyMath::ComputeSkewMatrix(coordinatesFF, tempRefPosSkew);

		//Mtt
		Matrix3D Mtt(3, 3);
		Mtt.SetScalarMatrix(3, physicsMass);
		massMatrix.AddSubmatrix(Mtt, 0, 0);

		//++++++++++++++++++++++++++++++++
		//Mtr = -A @ PHItTM @ rfTilde @ G
		//Mnew[0:dim3D, dim3D : dim3D + nODE2rot] = Mtr
		//Mnew[dim3D:dim3D + nODE2rot, 0 : dim3D] = Mtr.T
		Matrix3D X;
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, tempRefPosSkew, X);
		X = -1.*A*X;
		ConstSizeMatrix<GMaxSize> Mtr;
		EXUmath::MultMatrixMatrixTemplate<Matrix3D, ConstSizeMatrix<GMaxSize>, ConstSizeMatrix<GMaxSize>>(X, Glocal, Mtr);

		massMatrix.AddSubmatrix(Mtr, 0, ffrfNodeDim);
		massMatrix.AddSubmatrixTransposed(Mtr, ffrfNodeDim, 0);

		//++++++++++++++++++++++++++++++++
		//#Mtf:
		//Mtf = A @ PHItTM
		//Mnew[0:dim3D, nODE2rigid : ] = Mtf
		//Mnew[nODE2rigid:, 0 : dim3D] = Mtf.T
		EXUmath::MultMatrixMatrixTemplate<Matrix3D, Matrix, Matrix>(A, PHItTM, tempMatrix);
		massMatrix.AddSubmatrix(tempMatrix, 0, nODE2Rigid);
		massMatrix.AddSubmatrixTransposed(tempMatrix, nODE2Rigid, 0);


		//++++++++++++++++++++++++++++++++
		//#Mrf:
		//Mrf = -G.T @ rfTilde.T @ massMatrix
		//Mnew[dim3D:dim3D + nODE2rot, nODE2rigid : ] = Mrf
		//Mnew[nODE2rigid:, dim3D : dim3D + nODE2rot] = Mrf.T
		//parameters.massMatrixReduced.MultMatrixTransposedMatrix(tempRefPosSkew, tempMatrix);
		EXUmath::MultMatrixTransposedMatrixTemplate<Matrix,Matrix,Matrix>(parameters.massMatrixReduced, tempRefPosSkew, tempMatrix);
		EXUmath::MultMatrixMatrixTemplate<ConstSizeMatrix<GMaxSize>, Matrix, Matrix>(-1.*GlocalT, tempMatrix, tempMatrix2);
		massMatrix.AddSubmatrix(tempMatrix2, ffrfNodeDim, nODE2Rigid);
		massMatrix.AddSubmatrixTransposed(tempMatrix2, nODE2Rigid, ffrfNodeDim);

		
		//++++++++++++++++++++++++++++++++
		//#Mrr:
		const Index MrrMaxSize = CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::maxRotationCoordinates;
		ConstSizeMatrix<MrrMaxSize> Mrr;
		ConstSizeMatrix<GMaxSize> temp; //gives a 4x3 matrix for EP
		//Mnew[dim3D:dim3D + nODE2rot, dim3D : dim3D + nODE2rot] = -Mrf @ rfTilde @ G   #G.T @ rfTilde.T @ massMatrix @ rfTilde @ G
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, ConstSizeMatrix<GMaxSize>>(tempMatrix2, tempRefPosSkew, temp);
		EXUmath::MultMatrixMatrixTemplate<ConstSizeMatrix<GMaxSize>, 
			ConstSizeMatrix<GMaxSize>, 
			ConstSizeMatrix<MrrMaxSize>>(temp, -1.*Glocal, Mrr);
		massMatrix.AddSubmatrix(Mrr, ffrfNodeDim, ffrfNodeDim);

#endif
		//++++++++++++++++++++++++++++++++
		//Mff:
		massMatrix.AddSubmatrix(parameters.massMatrixReduced.GetEXUdenseMatrix(), nODE2Rigid, nODE2Rigid); //inefficient ...
		
#ifdef CObjectFFRFreducedOrderComputeMassMatrixOutput
		pout << "Mtt Mtr Mtf=" << massMatrix.GetSubmatrix(0, 0, 3, 10) << "\n";
		pout << "Mrr        =" << massMatrix.GetSubmatrix(3, 3, 4, 4) << "\n";
		pout << "Mff        =" << massMatrix.GetSubmatrix(7, 7, 3, 6) << "\n";
#endif
	}
}








//! Computational function: compute right-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2rhs"
//in fact, this is the LHS function!
void CObjectFFRFreducedOrder::ComputeODE2RHS(Vector& ode2Rhs) const
{
	Index nODE2Rigid = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
	Index nODE2 = nODE2Rigid + nODE2FF; //total number of coordinates

	ode2Rhs.SetNumberOfItems(nODE2);
	ode2Rhs.SetAll(0.);

	tempCoordinates.SetNumberOfItems(nODE2);
	tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates);
	ComputeObjectCoordinates_t(tempCoordinates_t);

	if (parameters.computeFFRFterms)
	{
		//K*q and D*q_T put to LHS !!!
		//link to flexible parts of vectors:
		LinkedDataVector coordinatesFF(tempCoordinates, nODE2Rigid, nODE2FF);
		LinkedDataVector coordinatesFF_t(tempCoordinates_t, nODE2Rigid, nODE2FF); //cF_t in python
		LinkedDataVector ode2RhsTT(ode2Rhs, 0, ffrfNodeDim);
		LinkedDataVector ode2RhsRR(ode2Rhs, ffrfNodeDim, nODE2Rigid-ffrfNodeDim);
		LinkedDataVector ode2RhsFF(ode2Rhs, nODE2Rigid, nODE2FF);

		Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix();

		const Index GMaxSize = CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D; //12


		if (parameters.stiffnessMatrixReduced.NumberOfRows() != 0)
		{
			//EXUmath::MultMatrixVectorAdd(parameters.stiffnessMatrixReduced, coordinatesFF, ode2RhsFF);
			parameters.stiffnessMatrixReduced.MultMatrixVectorAdd(coordinatesFF, ode2RhsFF);
			//pout << "coordinatesFF=" << coordinatesFF << "\n";
		}

		if (parameters.dampingMatrixReduced.NumberOfRows() != 0)
		{
			//EXUmath::MultMatrixVectorAdd(parameters.dampingMatrixReduced, coordinatesFF_t, ode2RhsFF);
			parameters.dampingMatrixReduced.MultMatrixVectorAdd(coordinatesFF_t, ode2RhsFF);
		}

		//if (parameters.forceVector.NumberOfItems() != 0)
		//{
		//	//CHECKandTHROWstring("CObjectRigidBody::ComputeODE2RHS: forceVector not implemented!");
		//	//transformation needed, which transforms f_{ff} components from global to local coordiantes
		//	LinkedDataVector forceVectorRigid(parameters.forceVector, 0, nODE2Rigid);
		//	LinkedDataVector forceVectorFF(parameters.forceVector, nODE2Rigid, nODE2FF);
		//	LinkedDataVector ode2RhsRigid(ode2Rhs, 0, nODE2Rigid);

		//	ode2RhsRigid -= forceVectorRigid;
		//	Matrix3D AT = GetRotationMatrix(Vector3D({ 0, 0, 0 })).GetTransposed();
		//	AT *= -1; //because forceVector is subtracted
		//	ApplyTransformationAndAdd(AT, forceVectorFF, ode2RhsFF);

		//	//ode2Rhs -= parameters.forceVector;
		//}

#ifdef computeFFRFfullTerms
		ConstSizeMatrix<GMaxSize> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);
		ConstSizeMatrix<GMaxSize> GlocalT;
		GlocalT = Glocal.GetTransposed();

		coordinatesFF += parameters.referencePositions; //this are now the local nodal positions for mesh (FF) coordinates; rF in python

		Vector3D omega3D = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal();
		Matrix3D omega3Dtilde = RigidBodyMath::Vector2SkewMatrix(omega3D);
		Matrix3D omega3Dtilde2 = omega3Dtilde * omega3Dtilde;

		RigidBodyMath::ComputeSkewMatrix(coordinatesFF, tempRefPosSkew); //tempRefPosSkew = rfTilde in python
		RigidBodyMath::ComputeSkewMatrix(coordinatesFF_t, tempVelSkew); //tempVelSkew = cF_tTilde in python

		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//fTrans = A @ (omega3Dtilde @ PHItTM @ rfTilde @ omega3D + 2*PHItTM @ cF_tTilde @ omega3D)
		//force[0:dim3D] = fTrans
		Matrix3D temp;
		//omega3Dtilde @ PHItTM @ rfTilde @ omega3D
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, tempRefPosSkew, temp);
		Vector3D tempVec = temp * omega3D;
		tempVec = omega3Dtilde * tempVec;

		//2*PHItTM @ cF_tTilde @ omega3D
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(PHItTM, tempVelSkew, temp);
		tempVec += temp * (2. * omega3D);
		ode2RhsTT -= A * tempVec; //-= for all ode2Rhs terms

		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//fRot = -G.T@(omega3Dtilde @ rfTilde.T @ massMatrix @ rfTilde @ omega3D + 
		//		        2*rfTilde.T @ massMatrix @ cF_tTilde @ omega3D)
		//force[dim3D:nODE2rigid] = fRot
		//omega3Dtilde @ (rfTilde.T @ massMatrix @ rfTilde) @ omega3D
		EXUmath::MultMatrixTransposedMatrixTemplate<Matrix, Matrix, Matrix>(parameters.massMatrixReduced, tempRefPosSkew, tempMatrix);
		//parameters.massMatrixReduced.MultDenseMatrixTransposedMatrix(tempRefPosSkew, tempMatrix); //tempMatrix=rfTilde.T @ massMatrix
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(tempMatrix, tempRefPosSkew, temp);
		tempVec = omega3Dtilde * (temp * omega3D);

		//2*rfTilde.T @ massMatrix @ cF_tTilde @ omega3D
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(tempMatrix, tempVelSkew, temp);
		tempVec += 2.*(temp * omega3D);

		//ode2RhsRR -= -1.*(GlocalT * tempVec); //-= for all ode2Rhs terms; NOT IMPLEMENTED, because cannot decide result vector at compile time
		EXUmath::MultMatrixVectorAdd(GlocalT, tempVec, ode2RhsRR); //double negative signs cancel!



		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//fFlex = -massMatrix @ (omegaTilde2 @ rF + 2*(omegaTilde @ cF_t))
		//force[nODE2rigid:] = fFlex
		tempVector = coordinatesFF;
		RigidBodyMath::ApplyTransformation(omega3Dtilde2, tempVector);
		RigidBodyMath::ApplyTransformationAndAdd(2.*omega3Dtilde, coordinatesFF_t, tempVector);
		EXUmath::MultMatrixVectorAdd(parameters.massMatrixReduced, tempVector, ode2RhsFF);
		//parameters.massMatrixReduced.MultMatrixVectorAdd(tempVector, ode2RhsFF); //two negative signs cancel: fFlex = - ... and ode2RhsFF -= ...
		

		//#add gravity:
		//if False:
		//    fGrav = np.array(fGravRigid + list(PHItTM.T @ (A.T @ g)) ) #only local vector, without rotation
		//    force += fGrav
		//
#endif
	}
	if (parameters.forceUserFunction)
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		{
			//user function args:(t, coordinates, coordinates_t)
			tempUserFunctionForce = (Vector)(parameters.forceUserFunction(t, tempCoordinates, tempCoordinates_t));
		}, "ObjectFFRFreducedOrder::forceUserFunction");

		ode2Rhs -= tempUserFunctionForce;
	}

}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectFFRFreducedOrder::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::AngularVelocity_qt +
		(Index)AccessFunctionType::DisplacementMassIntegral_q + (Index)AccessFunctionType::SuperElement);
}

//! provide Jacobian at localPosition in "value" ONLY OF reference frame, according to configuration type
void CObjectFFRFreducedOrder::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	static_assert(CNodeRigidBody::nDim3D == CNodeRigidBody::maxDisplacementCoordinates); //add this code to raise compiler error, if max. number of displacement coordiantes changes in RigidBodyNode ==> requires reimplementation in this file!
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt: //global translational velocity at localPosition derivative w.r.t. qt = L-matrix = [I   -A*uLocalTilde*Glocal]
	{
		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		//Jac = -A*uLocalTilde*Glocal
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

		ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix(-localPosition); //negative sign in -A*uLocalTilde*Glocal
		//uLocalTilde *= -1.;//moved into (-localPosition)

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> temp; //temporary matrix during computation
		EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(), temp, Glocal); //Glocal now is: A*(-uLocalTilde)*Glocal

		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());
		//unit matrix
		value(0, 0) = 1.; value(0, 1) = 0.; value(0, 2) = 0.;
		value(1, 0) = 0.; value(1, 1) = 1.; value(1, 2) = 0.;
		value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = 1.;

		//-A*uLocalTilde*Glocal part (=L in this case
		for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		{
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, CNodeRigidBody::nDim3D + j) = Glocal(i, j);
			}
		}


		break;
	}
	case AccessFunctionType::AngularVelocity_qt: //global angular velocity
	{
		//d(omega)/d(q_t): derivative of angular velocity w.r.t. all coordinates_t = [0_{3x3} G-matrix]
		//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationParameters();
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> G;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetG(G);// RigidBodyMath::EP2G(rot);

		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());
		for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		{
			value(0, i) = 0;
			value(1, i) = 0;
			value(2, i) = 0;
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, CNodeRigidBody::nDim3D + j) = G(i, j);
			}
		}
		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());

		Real m = physicsMass;

		if (physicsCenterOfMass == 0.)
		{
			for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
			{
				for (Index j = 0; j < GetODE2Size(); j++)
				{
					if (i != j) { value(i, j) = 0.; }
					else { value(i, j) = m; } //only diagonal 3x3 term!
				}
			}
		}
		else
		{
			//gives m* \partial p_COM / \partial q
			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> Glocal;
			((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);
			CHECKandTHROW(physicsCenterOfMass == localPosition, "CObjectRigidBody::GetAccessFunctionBody: inconsistent localPosition");


			ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix((-m)*physicsCenterOfMass); //negative sign in -A*uLocalTilde*Glocal
			//uLocalTilde *= -1.;//moved into ((-m)*parameters.physicsCenterOfMass)

			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> temp; //temporary matrix during computation
			EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
			EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(), temp, Glocal); //Glocal=A*(-m*uLocalTilde)*Glocal

			//unit matrix
			value(0, 0) = m; value(0, 1) = 0.; value(0, 2) = 0.;
			value(1, 0) = 0.; value(1, 1) = m; value(1, 2) = 0.;
			value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = m;

			//-A*uLocalTilde*Glocal part (=L in this case
			for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
			{
				for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
				{
					value(i, CNodeRigidBody::nDim3D + j) = Glocal(i, j);
				}
			}
		}

		break;
	}
	default:
		SysError("CObjectFFRFreducedOrder:GetAccessFunctionBody illegal accessType");
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     REFERENCE FRAME FUNCTIONS     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! provide according output variable in "value", localPosition ONLY REFERS TO THE REFERENCE FRAME!
void CObjectFFRFreducedOrder::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value) const
{
	Index nODE2 = GetODE2Size();
	tempCoordinates.SetNumberOfItems(nODE2);
	tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates, configuration);
	ComputeObjectCoordinates_t(tempCoordinates_t, configuration);

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(tempCoordinates);	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(tempCoordinates_t);	break;
	case OutputVariableType::Force:			ComputeODE2RHS(value);	break;
	default:
		SysError("CObjectFFRFreducedOrder::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}


//  return the (global) position of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRFreducedOrder::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration) + 
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) * localPosition;

}

//  return the (global) position of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRFreducedOrder::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) +
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(localPosition); //add omega x r
}

//! return the (global) displacement of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRFreducedOrder::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration) - 
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

//! return the rotation matrix ONLY OF reference frame (localPosition ignored), according to configuration type
Matrix3D CObjectFFRFreducedOrder::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
}

//! return configuration dependent angular velocity ONLY OF reference frame (localPosition ignored), according to configuration type
Vector3D CObjectFFRFreducedOrder::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocity(configuration);
}

//! return configuration dependent local (=body fixed) angular velocity ONLY OF reference frame (localPosition ignored), according to configuration type
Vector3D CObjectFFRFreducedOrder::GetAngularVelocityLocal(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     MESH NODE FUNCTIONS      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! compute coordinates for nodeNumber(without reference coordinates) from modeBasis(= multiplication of according part of mode Basis with modal coordinates)
Vector3D CObjectFFRFreducedOrder::GetMeshNodeCoordinates(Index nodeNumber, const Vector& coordinates) const
{
	Vector3D u({ 0.,0.,0. }); //can be displacements and velocities, depending on coordinates!
	const Matrix& Psi = parameters.modeBasis;
	Index nModes = Psi.NumberOfColumns();
	Index nOffset = nodeNumber*3; //offset in modeBasis, giving according x-coordinates of node

	for (Index i = 0; i < 3; i++) //node coordinates x,y,z
	{
		for (Index j = 0; j < nModes; j++) //iteration over all modes / modal coordinates
		{
			u[i] += Psi(nOffset + i, j) * coordinates[j];
		}
	}
	return u;
}

//! for definition see CObjectSuperElement
void CObjectFFRFreducedOrder::GetAccessFunctionSuperElement(AccessFunctionType accessType, const Matrix& weightingMatrix, const ArrayIndex& meshNodeNumbers, Matrix& value) const
{
	switch ((Index)accessType)
	{
	case (Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::SuperElement: //global translational velocity at mesh position derivative w.r.t. all q_t: without reference frame: [0,..., 0, w0*nodeJac0, 0, ..., 0, w1*nodeJac1, 0,...]; with reference frame: [I, -A * pLocalTilde * Glocal, A*(0,...,0, w0*nodeJac0, 0,..., 0, w1*nodeJac1, ...)]
	{
		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size()); 
		value.SetAll(0.);

		Matrix valueFF(nDim3D, GetNumberOfMeshNodes() * 3); //flexible part, full coordinates, for testing
		valueFF.SetAll(0.);

		//++++++++++++++++++++++++++++++++++++++
		//add action for flexible part:
		Matrix A;
		A = ((const CNodeODE2*)(GetCNode(rigidBodyNodeNumber)))->GetRotationMatrix();

		for (Index i = 0; i < meshNodeNumbers.NumberOfItems(); i++)
		{
			//assume that the first 3 coordinates of the node are the displacement coordinates!!!
			Matrix3D jac = A;
			if (weightingMatrix.NumberOfColumns() == 1)
			{
				jac *= weightingMatrix(i, 0);
			}
			else
			{
				for (Index j = 0; j < 3; j++)
				{
					for (Index k = 0; k < 3; k++)
					{
						jac(j, k) *= weightingMatrix(i, k); //add weighting to columns, because every column corresponds to local x,y and z direction (weigthing effects needed on local coordinates)
					}
				}
			}
			Index offset = meshNodeNumbers[i] * 3;
			valueFF.SetSubmatrix(jac, 0, offset);
		}

		//++++++++++++++++++++++++++++++++++++++
		//add action for REFERENCE FRAME NODE:
		//\partial vMarker / \partial q_t = [I, -A * pLocalTilde * Glocal, A*(w0*nodeJac0, w1*nodeJac1, ...)]

		Vector3D localPosition({ 0,0,0 });
		for (Index i = 0; i < meshNodeNumbers.NumberOfItems(); i++)
		{
			if (weightingMatrix.NumberOfColumns() == 1)
			{
				localPosition += weightingMatrix(i, 0) * GetMeshNodeLocalPosition(meshNodeNumbers[i]); //((const CNodeODE2&)cSystemData.GetCNode(cObject.GetNodeNumber(nodeNumbers[i]))).GetPosition();
			}
			else
			{
				for (Index j = 0; j < 3; j++)
				{
					localPosition[j] += weightingMatrix(i, j) * GetMeshNodeLocalPosition(meshNodeNumbers[i])[j]; //((const CNodeODE2&)cSystemData.GetCNode(cObject.GetNodeNumber(nodeNumbers[i]))).GetPosition();
				}
			}
		}

		const CNodeRigidBody* cNode = (const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber);

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::nDim3D> Glocal;

		//compute: -A*pLocalTilde*GLocal
		cNode->GetGlocal(Glocal);
		EXUmath::ApplyTransformation<3>(RigidBodyMath::Vector2SkewMatrixTemplate(-localPosition), Glocal);
		EXUmath::ApplyTransformation<3>(A, Glocal);

		//now compute remaining jacobian terms for reference frame motion:
		ConstSizeMatrix<CNodeRigidBody::nDim3D * (CNodeRigidBody::maxDisplacementCoordinates + CNodeRigidBody::maxRotationCoordinates)> posJac0;
		cNode->GetPositionJacobian(posJac0);

		value.SetSubmatrix(posJac0, 0, 0);
		value.SetSubmatrix(Glocal, 0, CNodeRigidBody::maxDisplacementCoordinates);

		value.SetSubmatrix(valueFF * parameters.modeBasis, 0, cNode->GetNumberOfODE2Coordinates());

		break;
	}
	default:
		CHECKandTHROWstring("CObjectFFRFreducedOrder:GetAccessFunctionSuperElement illegal accessType");
	}
}

//! get extended output variable types for multi-nodal objects with mesh nodes
OutputVariableType CObjectFFRFreducedOrder::GetOutputVariableTypesSuperElement(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetOutputVariableSuperElement: meshNodeNumber out of range ");
	//independent of meshNodeNumber!!!
	return (OutputVariableType)(
		(Index)OutputVariableType::Position +
		(Index)OutputVariableType::Displacement +
		(Index)OutputVariableType::Velocity +
		(Index)OutputVariableType::DisplacementLocal +
		(Index)OutputVariableType::VelocityLocal);
}

//! get extended output variables for multi-nodal objects with mesh nodes
void CObjectFFRFreducedOrder::GetOutputVariableSuperElement(OutputVariableType variableType, Index meshNodeNumber, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration));	break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration) - GetMeshNodePosition(meshNodeNumber, ConfigurationType::Reference));	break;
	case OutputVariableType::Velocity:	value.CopyFrom(GetMeshNodeVelocity(meshNodeNumber, configuration));	break;

	case OutputVariableType::DisplacementLocal:	value.CopyFrom(GetMeshNodeLocalPosition(meshNodeNumber, configuration) - GetMeshNodeLocalPosition(meshNodeNumber, ConfigurationType::Reference));	break;
	case OutputVariableType::VelocityLocal:	value.CopyFrom(GetMeshNodeLocalVelocity(meshNodeNumber, configuration));	break;
	default:
		SysError("CObjectFFRFreducedOrder::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}

}

//! return the (local) position of a mesh node according to configuration type; use Configuration.Reference to access the mesh reference position; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodeLocalPosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodeLocalPosition: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRFreducedOrder)");

	return GetMeshNodeCoordinates(meshNodeNumber, ((CNodeODE2*)GetCNode(genericNodeNumber))->GetCoordinateVector(configuration))
		+ Vector3D({ parameters.referencePositions[meshNodeNumber * 3], 
			parameters.referencePositions[meshNodeNumber * 3+1],
			parameters.referencePositions[meshNodeNumber * 3+2] });
}

//! return the (local) velocity of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodeLocalVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodeLocalVelocity: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRFreducedOrder)");

	return GetMeshNodeCoordinates(meshNodeNumber, ((CNodeODE2*)GetCNode(genericNodeNumber))->GetCoordinateVector_t(configuration));
}

//! return the (global) position of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodePosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodePosition: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRFreducedOrder)");

	Matrix3D refRot = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
	Vector3D refPos = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration);

	return refPos + refRot * GetMeshNodeLocalPosition(meshNodeNumber, configuration); //no "+1", because it is already the mesh function
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodeVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodeVelocity: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRFreducedOrder)");

	// \dot R + A * \localOmega x \localPosition
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) +
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(GetMeshNodeLocalPosition(meshNodeNumber, configuration)) +
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) * GetMeshNodeLocalVelocity(meshNodeNumber, configuration);
}






