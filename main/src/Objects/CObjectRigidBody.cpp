/** ***********************************************************************************************
* @brief        CObjectRigidBody implementation
*
* @author       Gerstmayr Johannes
* @date         2019-10-19 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodeRigidBodyEP.h"
#include "Autogenerated/CObjectRigidBody.h"
#include "Utilities/RigidBodyMath.h"

//! number of ODE2 coordinates; depends on node
Index CObjectRigidBody::GetODE2Size() const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetNumberOfDisplacementCoordinates() + ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates();
}

//! number of AE coordinates; depends on node
Index CObjectRigidBody::GetAlgebraicEquationsSize() const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetNumberOfAECoordinates();
}


//! Computational function: compute mass matrix
void CObjectRigidBody::ComputeMassMatrix(Matrix& massMatrix) const
{
	static_assert(nDisplacementCoordinates == CNodeRigidBody::maxDisplacementCoordinates); //add this code to raise compiler error, if max. number of displacement coordiantes changes in RigidBodyNode ==> requires reimplementation in this file!

	//set mass terms in first 3 diagonal entries and set remaining entries to zero (the last 4x4 entries will be overwritten when filling in inertia terms)
	massMatrix.SetScalarMatrix(GetODE2Size(), parameters.physicsMass);

	//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
	((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

	ConstSizeMatrix<9> localInertia;
	RigidBodyMath::ComputeInertiaMatrix(parameters.physicsInertia, localInertia);

	//pout << "Glocal=" << Glocal << "\n";
	//pout << "A=" << ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix() << "\n";
	//pout << "Jbar=" << localInertia << "\n";

	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> GlocalInertia;			//temporary matrix
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::maxRotationCoordinates> inertia; //final inertia term

	EXUmath::MultMatrixTransposedMatrix(Glocal, localInertia, GlocalInertia);
	EXUmath::MultMatrixMatrix(GlocalInertia, Glocal, inertia);

	Index nRotationCoordinates = ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates();
	for (Index i = 0; i < nRotationCoordinates; i++)
	{
		for (Index j = 0; j < nRotationCoordinates; j++)
			{ massMatrix(nDisplacementCoordinates + i, nDisplacementCoordinates + j) = inertia(i, j); }
	}
	//pout << "mass=" << massMatrix << "\n";
}

//! Computational function: compute right-hand-side (RHS) of second order ordinary differential equations (ODE) to "ode2rhs"
void CObjectRigidBody::ComputeODE2RHS(Vector& ode2Rhs) const
{
	ode2Rhs.SetNumberOfItems(GetODE2Size());
	ode2Rhs.SetAll(0.);

	ConstSizeMatrix<9> localInertia;
	RigidBodyMath::ComputeInertiaMatrix(parameters.physicsInertia, localInertia);

	ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
	LinkedDataVector rot_t = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters_t();
	//pout << "rot=" << rot << "\n";
	//pout << "rot_t=" << rot_t << "\n";

	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
	((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);

	//compute: Glocal^T * (omegaBar.Cross(localInertia*omegaBar))
	Vector3D omegaBar;
	EXUmath::MultMatrixVector(Glocal, rot_t, omegaBar);
	//pout << "omegaBar=" << omegaBar << "\n";

	//+++++++++++++++++++++++++++++++++++++
	//Version1 (different to Version2 (gives different forces1; difference acting in the nullspace of rot):
	Vector3D temp = omegaBar.CrossProduct(localInertia * omegaBar);
	ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces1; //forces acting on rotation coordinates
	EXUmath::MultMatrixTransposedVector(Glocal, temp, forces1);
	//pout << "forces1=" << forces1 << "\n";

	if ((((CNodeRigidBody*)GetCNode(0))->GetType() & Node::Type::RotationEulerParameters) == 0 && 
		(((CNodeRigidBody*)GetCNode(0))->GetType() & Node::Type::RotationRotationVector) == 0) //for Euler parameters or rotation vector, the following terms vanish
	{
		//compute: forces2 = Glocal^T * localInertia * Glocal_t * rot_t
		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces2;
		Vector3D temp2;

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t;
		((CNodeRigidBody*)GetCNode(0))->GetGlocal_t(Glocal_t);
		EXUmath::MultMatrixVector(Glocal_t, rot_t, temp);
		EXUmath::MultMatrixVector(localInertia, temp, temp2);
		
		EXUmath::MultMatrixTransposedVector(Glocal, temp2, forces2);
		forces1 += forces2;
		//pout << "forces2=" << forces2 << "\n";

	}

	//+++++++++++++++++++++++++++++++++++++
	//Version2:
	//RHS = -2*Gbar_t^T*Ibar*omegaBar
	//omegaBar *= 2.;
	//Vector3D temp = localInertia * omegaBar;
	//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces1; //forces acting on Euler parameter coordinates
	//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t = RigidBodyMath::EP_t2Glocal_t(rot_t);
	//EXUmath::MultMatrixTransposedVector(Glocal_t, temp, forces1);

	//++++++++++++++
	//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t = RigidBodyMath::EP_t2Glocal_t(rot_t);
	//Matrix Gbar_tT = Glocal_t;
	//Vector temp2; 
	//temp2.CopyFrom(temp);
	//Vector forces1 = Gbar_tT.GetTransposed() * temp2;

	//+++++++++++++++++++++++++++++++++++++
	//pout << "Qv = " << -1 * forces1 << "\n";

	//*******************************
	//original code H1:
	//GetBetaP(betap);
	//Matrix3D Gbar = GetGbar();
	//Vector3D omegabar = Gbar * betap; //--->Mult is faster
	//Vector3D temp = (omegabar.Cross(Iphi*omegabar));
	//Mult(Gbar.GetTp(), temp, betap);

	for (Index i = 0; i < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); i++)
	{
		ode2Rhs[i + nDisplacementCoordinates] += forces1[i]; //positive sign, because object ODEforces are put on LHS
	}

	//pout << "ode2RHS=" << ode2Rhs << "\n";
}

//! Compute algebraic equations part of rigid body
void CObjectRigidBody::ComputeAlgebraicEquations(Vector& algebraicEquations, bool useIndex2) const
{
	if (GetCNode(0)->GetNumberOfAECoordinates() != 0)
	{
		algebraicEquations.SetNumberOfItems(1);
		if (!useIndex2)
		{
			//position level constraint:

			ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
			algebraicEquations[0] = ep * ep - 1.;
		}
		else
		{
			//velocity level constraint:
			ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
			LinkedDataVector ep_t = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters_t();

			algebraicEquations[0] = 2. * (ep * ep_t);
		}
	}
	else
	{
		CHECKandTHROWstring("CObjectRigidBody::ComputeAlgebraicEquations(...): invalid call");
	}
}

//! Compute jacobians of algebraic equations part of rigid body w.r.t. ODE2
void CObjectRigidBody::ComputeJacobianAE(ResizableMatrix& jacobian, ResizableMatrix& jacobian_t, ResizableMatrix& jacobian_AE) const
{
	if (GetCNode(0)->GetNumberOfAECoordinates() != 0)
	{
		//markerData contains already the correct jacobians ==> transformed to constraint jacobian
		jacobian.SetNumberOfRowsAndColumns(((CNodeRigidBody*)GetCNode(0))->GetNumberOfAECoordinates(), GetODE2Size());
		jacobian_t.SetNumberOfRowsAndColumns(0, 0); //for safety!
		jacobian_AE.SetNumberOfRowsAndColumns(0, 0);//for safety!

		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();

		//jacobian = [0 0 0 2*ep0 2*ep1 2*ep2 2*ep3]
		for (Index i = 0; i < nDisplacementCoordinates; i++) { jacobian(0, i) = 0.; }
		for (Index i = 0; i < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); i++) 
		{ 
			jacobian(0, 3 + i) = 2.*ep[i]; 
		}
	}
	else
	{
		CHECKandTHROWstring("CObjectRigidBody::ComputeJacobianAE(...): invalid call");
	}
}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectRigidBody::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::AngularVelocity_qt + (Index)AccessFunctionType::DisplacementMassIntegral_q);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectRigidBody::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt: //global translational velocity at localPosition derivative w.r.t. qt = L-matrix = [I   -A*uLocalTilde*Glocal]
	{
		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
		((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

		ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix(localPosition); 
		uLocalTilde *= -1.;//negative sign in -A*uLocalTilde*Glocal

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> temp; //temporary matrix during computation
		EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(), temp, Glocal);

		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		//unit matrix
		value(0, 0) = 1.; value(0, 1) = 0.; value(0, 2) = 0.;
		value(1, 0) = 0.; value(1, 1) = 1.; value(1, 2) = 0.;
		value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = 1.;

		//-A*uLocalTilde*Glocal part (=L in this case
		for (Index i = 0; i < nDim3D; i++)
		{
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, nDisplacementCoordinates + j) = Glocal(i, j);
			}
		}


		break;
	}
	case AccessFunctionType::AngularVelocity_qt: //global angular velocity
	{
		//d(omega)/d(q_t): derivative of angular velocity w.r.t. all coordinates_t = [0_{3x3} G-matrix]
		//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> G;
		((CNodeRigidBody*)GetCNode(0))->GetG(G);// RigidBodyMath::EP2G(rot);

		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		for (Index i = 0; i < nDim3D; i++)
		{
			value(0, i) = 0;
			value(1, i) = 0;
			value(2, i) = 0;
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, nDisplacementCoordinates +j) = G(i,j);
			}
		}
		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());

		Real m = parameters.physicsMass;

		for (Index i = 0; i < nDim3D; i++)
		{
			for (Index j = 0; j < GetODE2Size(); j++)
			{
				if (i != j) { value(i, j) = 0.; }
				else { value(i, j) = m; } //only diagonal term!
			}
		}

		break;
	}
	default:
		SysError("CObjectRigidBody:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectRigidBody::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(localPosition, configuration)); break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	case OutputVariableType::AngularVelocityLocal: value.CopyFrom(GetAngularVelocityLocal(localPosition, configuration)); break;
	case OutputVariableType::RotationMatrix: {
		Matrix3D rot = GetRotationMatrix(localPosition, configuration);
		value.SetVector(9, rot.GetDataPointer());
		break;
	}
	case OutputVariableType::Rotation: {
		Matrix3D rotMat = GetRotationMatrix(localPosition, configuration);
		Vector3D rot = RigidBodyMath::RotationMatrix2RotXYZ(rotMat);
		value.CopyFrom(rot);
		break;
	}
	default:
		SysError("CObjectRigidBody::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//! @todo: add ConfigurationType to CObjectMassPoint::GetPosition; 
//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetPosition(configuration) + ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration) * localPosition;

}

//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return ((CNodeRigidBody*)GetCNode(0))->GetVelocity(configuration) +
		((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration) *
		((CNodeRigidBody*)GetCNode(0))->GetAngularVelocityLocal(configuration).CrossProduct(localPosition); //add omega x r
}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetPosition(configuration) - ((CNodeRigidBody*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

Matrix3D CObjectRigidBody::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration);
}

//! return configuration dependent angular velocity of rigid body; returns always a 3D Vector
Vector3D CObjectRigidBody::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocity(configuration);
}

//! return configuration dependent local (=body fixed) angular velocity of rigid body; returns always a 3D Vector
Vector3D CObjectRigidBody::GetAngularVelocityLocal(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocityLocal(configuration);
}

