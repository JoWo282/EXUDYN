/** ***********************************************************************************************
* @brief        CObjectRigidBody implementation
*
* @author       Gerstmayr Johannes
* @date         2019-10-19 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodeRigidBodyEP.h"
#include "Autogenerated/CObjectRigidBody.h"
#include "Utilities/RigidBodyMath.h"

//! number of ODE2 coordinates; depends on node
Index CObjectRigidBody::GetODE2Size() const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetNumberOfDisplacementCoordinates() + ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates();
}

//! number of AE coordinates; depends on node
Index CObjectRigidBody::GetAlgebraicEquationsSize() const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetNumberOfAECoordinates();
}


//! Computational function: compute mass matrix
void CObjectRigidBody::ComputeMassMatrix(Matrix& massMatrix) const
{
	static_assert(nDisplacementCoordinates == CNodeRigidBody::maxDisplacementCoordinates); //add this code to raise compiler error, if max. number of displacement coordiantes changes in RigidBodyNode ==> requires reimplementation in this file!

	//set mass terms in first 3 diagonal entries and set remaining entries to zero (the last 4x4 entries will be overwritten when filling in inertia terms)
	massMatrix.SetScalarMatrix(GetODE2Size(), parameters.physicsMass);

	//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
	((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

	ConstSizeMatrix<9> localInertia;
	RigidBodyMath::ComputeInertiaMatrix(parameters.physicsInertia, localInertia);

	//pout << "Glocal=" << Glocal << "\n";
	//pout << "A=" << ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix() << "\n";
	//pout << "Jbar=" << localInertia << "\n";

	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> GlocalInertia;			//temporary matrix
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::maxRotationCoordinates> inertia; //final inertia term

	EXUmath::MultMatrixTransposedMatrix(Glocal, localInertia, GlocalInertia);
	EXUmath::MultMatrixMatrix(GlocalInertia, Glocal, inertia);

	Index nRotationCoordinates = ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates();
	for (Index i = 0; i < nRotationCoordinates; i++)
	{
		for (Index j = 0; j < nRotationCoordinates; j++)
		{ 
			massMatrix(nDisplacementCoordinates + i, nDisplacementCoordinates + j) = inertia(i, j); 
		}
	}

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Terms for COM!=0
	if (!(parameters.physicsCenterOfMass == 0.)) //component-wise compare
	{
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> mRTheta; //off-diagonal mass term
		//–m * A * \tilde \bar u_{ COM } \bar G
		EXUmath::MultMatrixMatrix(RigidBodyMath::Vector2SkewMatrix((-parameters.physicsMass)*parameters.physicsCenterOfMass), Glocal, GlocalInertia);
		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(), GlocalInertia, mRTheta);

		for (Index i = 0; i < nDim3D; i++)
		{
			for (Index j = 0; j < nRotationCoordinates; j++)
			{
				massMatrix(i, nDisplacementCoordinates + j) = mRTheta(i, j);
				massMatrix(nDisplacementCoordinates + j, i) = mRTheta(i, j);
			}
		}
	}

	//pout << "mass=" << massMatrix << "\n";
}

//! Computational function: compute left-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
void CObjectRigidBody::ComputeODE2LHS(Vector& ode2Lhs) const
{
	ode2Lhs.SetNumberOfItems(GetODE2Size());
	ode2Lhs.SetAll(0.);

	ConstSizeMatrix<9> localInertia;
	RigidBodyMath::ComputeInertiaMatrix(parameters.physicsInertia, localInertia);

	//compute forces1 and forces2 on left-hand-side (M*a + forces1 + forces2)
	//compute: forces1 = Glocal^T * (omegaBar.Cross(localInertia*omegaBar))
	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
	((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);
	Vector3D omegaBar = ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocityLocal();

	//+++++++++++++++++++++++++++++++++++++
	//Version1 (different to Version2 (gives different forces1; difference acting in the nullspace of rot):
	Vector3D temp = omegaBar.CrossProduct(localInertia * omegaBar);
	ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces1; //forces acting on rotation coordinates
	EXUmath::MultMatrixTransposedVector(Glocal, temp, forces1);

	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t; //store this term for case with COM!=0
	LinkedDataVector rot_t = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters_t();//store this term for case with COM!=0
	Vector3D Glocal_tTheta_t(0); //used twice!

	//additional term, if not Euler Parameters
	if ((((CNodeRigidBody*)GetCNode(0))->GetType() & Node::Type::RotationEulerParameters) == 0 && 
		(((CNodeRigidBody*)GetCNode(0))->GetType() & Node::Type::RotationRotationVector) == 0) //for Euler parameters or rotation vector, the following terms vanish
	{
		//compute: forces2 = Glocal^T * localInertia * Glocal_t * rot_t
		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces2;
		Vector3D temp2;

		((CNodeRigidBody*)GetCNode(0))->GetGlocal_t(Glocal_t);
		EXUmath::MultMatrixVector(Glocal_t, rot_t, Glocal_tTheta_t); //Glocal_tTheta_t stored for later usage!
		EXUmath::MultMatrixVector(localInertia, Glocal_tTheta_t, temp2);
		
		EXUmath::MultMatrixTransposedVector(Glocal, temp2, forces2);
		forces1 += forces2;
		//pout << "forces2=" << forces2 << "\n";

	}

	//+++++++++++++++++++++++++++++++++++++
	//alternative Version2, for completeness:
	////compute term: 2*Gbar_t^T*Ibar*omegaBar
	//omegaBar *= 2.;
	//Vector3D temp = localInertia * omegaBar;
	//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> forces1; //forces acting on Euler parameter coordinates
	//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t = RigidBodyMath::EP_t2Glocal_t(rot_t);
	//EXUmath::MultMatrixTransposedVector(Glocal_t, temp, forces1);

	//++++++++++++++
	//ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal_t = RigidBodyMath::EP_t2Glocal_t(rot_t);
	//Matrix Gbar_tT = Glocal_t;
	//Vector temp2; 
	//temp2.CopyFrom(temp);
	//Vector forces1 = Gbar_tT.GetTransposed() * temp2;

	//+++++++++++++++++++++++++++++++++++++
	//pout << "Qv = " << -1 * forces1 << "\n";

	//*******************************
	//original code H1:
	//GetBetaP(betap);
	//Matrix3D Gbar = GetGbar();
	//Vector3D omegabar = Gbar * betap; //--->Mult is faster
	//Vector3D temp = (omegabar.Cross(Iphi*omegabar));
	//Mult(Gbar.GetTp(), temp, betap);

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Terms for COM!=0
	if (!(parameters.physicsCenterOfMass == 0.)) //component-wise compare
	{
		//add terms with Ubar=m*xBar_COM != 0; addForce is put on left-hand-side
		//additional term: -A*[omegaBar x (Ubar x omegaBar) + Ubar x (Glocal_t * rot_t) ]
		Vector3D Ubar = -parameters.physicsMass * parameters.physicsCenterOfMass;	//negative sign of -A[...]
		Vector3D addForce = omegaBar.CrossProduct(Ubar.CrossProduct(omegaBar));		//omegaBar x (U x omegaBar)

		addForce += Ubar.CrossProduct(Glocal_tTheta_t);								//U x (Glocal_t * rot_t) (=0 if EulerParameters)
		addForce = ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix() * addForce;	//A*[...]

		for (Index i = 0; i < nDim3D; i++)
		{
			ode2Lhs[i] += addForce[i]; //positive sign, because object ODEforces are put on LHS
		}
	}

	for (Index i = 0; i < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); i++)
	{
		ode2Lhs[i + nDisplacementCoordinates] += forces1[i]; //positive sign, because object ODEforces are put on LHS
	}

	//pout << "ode2Lhs=" << ode2Lhs << "\n";
}

//! Compute algebraic equations part of rigid body
void CObjectRigidBody::ComputeAlgebraicEquations(Vector& algebraicEquations, bool useIndex2) const
{
	if (GetCNode(0)->GetNumberOfAECoordinates() != 0)
	{
		algebraicEquations.SetNumberOfItems(1);
		if (!useIndex2)
		{
			//position level constraint:

			ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
			algebraicEquations[0] = ep * ep - 1.;
		}
		else
		{
			//velocity level constraint:
			ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
			LinkedDataVector ep_t = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters_t();

			algebraicEquations[0] = 2. * (ep * ep_t);
		}
	}
	else
	{
		CHECKandTHROWstring("CObjectRigidBody::ComputeAlgebraicEquations(...): invalid call");
	}
}

//! Compute jacobians of algebraic equations part of rigid body w.r.t. ODE2
void CObjectRigidBody::ComputeJacobianAE(ResizableMatrix& jacobian_ODE2, ResizableMatrix& jacobian_ODE2_t, 
	ResizableMatrix& jacobian_ODE1, ResizableMatrix& jacobian_AE) const
{
	if (GetCNode(0)->GetNumberOfAECoordinates() != 0)
	{
		jacobian_ODE2.SetNumberOfRowsAndColumns(((CNodeRigidBody*)GetCNode(0))->GetNumberOfAECoordinates(), GetODE2Size());
		jacobian_ODE2_t.SetNumberOfRowsAndColumns(0, 0); //for safety!
		jacobian_ODE1.SetNumberOfRowsAndColumns(0, 0); //for safety!
		jacobian_AE.SetNumberOfRowsAndColumns(0, 0);//for safety!

		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> ep = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();

		//jacobian = [0 0 0 2*ep0 2*ep1 2*ep2 2*ep3]
		for (Index i = 0; i < nDisplacementCoordinates; i++) { jacobian_ODE2(0, i) = 0.; }
		for (Index i = 0; i < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); i++) 
		{ 
			jacobian_ODE2(0, 3 + i) = 2.*ep[i];
		}
	}
	else
	{
		CHECKandTHROWstring("CObjectRigidBody::ComputeJacobianAE(...): invalid call");
	}
}

//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectRigidBody::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::AngularVelocity_qt + (Index)AccessFunctionType::DisplacementMassIntegral_q);
}

//! provide Jacobian at localPosition in "value" according to object access
void CObjectRigidBody::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt: //global translational velocity at localPosition derivative w.r.t. qt = L-matrix = [I   -A*uLocalTilde*Glocal]
	{
		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		//Jac = -A*uLocalTilde*Glocal
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
		((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

		ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix(-localPosition); //negative sign in -A*uLocalTilde*Glocal
		//uLocalTilde *= -1.;//moved into (-localPosition)

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> temp; //temporary matrix during computation
		EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(), temp, Glocal); //Glocal now is: A*(-uLocalTilde)*Glocal

		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		//unit matrix
		value(0, 0) = 1.; value(0, 1) = 0.; value(0, 2) = 0.;
		value(1, 0) = 0.; value(1, 1) = 1.; value(1, 2) = 0.;
		value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = 1.;

		//-A*uLocalTilde*Glocal part (=L in this case
		for (Index i = 0; i < nDim3D; i++)
		{
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, nDisplacementCoordinates + j) = Glocal(i, j);
			}
		}


		break;
	}
	case AccessFunctionType::AngularVelocity_qt: //global angular velocity
	{
		//d(omega)/d(q_t): derivative of angular velocity w.r.t. all coordinates_t = [0_{3x3} G-matrix]
		//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(0))->GetRotationParameters();
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> G;
		((CNodeRigidBody*)GetCNode(0))->GetG(G);// RigidBodyMath::EP2G(rot);

		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		for (Index i = 0; i < nDim3D; i++)
		{
			value(0, i) = 0;
			value(1, i) = 0;
			value(2, i) = 0;
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, nDisplacementCoordinates +j) = G(i,j);
			}
		}
		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());

		Real m = parameters.physicsMass;

		if (parameters.physicsCenterOfMass == 0.)
		{
			for (Index i = 0; i < nDim3D; i++)
			{
				for (Index j = 0; j < GetODE2Size(); j++)
				{
					if (i != j) { value(i, j) = 0.; }
					else { value(i, j) = m; } //only diagonal 3x3 term!
				}
			}
		}
		else
		{
			//gives m* \partial p_COM / \partial q
			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> Glocal;
			((CNodeRigidBody*)GetCNode(0))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);
			CHECKandTHROW(parameters.physicsCenterOfMass == localPosition, "CObjectRigidBody::GetAccessFunctionBody: inconsistent localPosition");


			ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix((-m)*parameters.physicsCenterOfMass); //negative sign in -A*uLocalTilde*Glocal
			//uLocalTilde *= -1.;//moved into ((-m)*parameters.physicsCenterOfMass)

			ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * nDim3D> temp; //temporary matrix during computation
			EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
			EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(), temp, Glocal); //Glocal=A*(-m*uLocalTilde)*Glocal

			//unit matrix
			value(0, 0) = m ; value(0, 1) = 0.; value(0, 2) = 0.;
			value(1, 0) = 0.; value(1, 1) = m ; value(1, 2) = 0.;
			value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = m ;

			//-A*uLocalTilde*Glocal part (=L in this case
			for (Index i = 0; i < nDim3D; i++)
			{
				for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(0))->GetNumberOfRotationCoordinates(); j++)
				{
					value(i, nDisplacementCoordinates + j) = Glocal(i, j);
				}
			}
		}

		break;
	}
	default:
		SysError("CObjectRigidBody:GetAccessFunctionBody illegal accessType");
	}
}

//! provide according output variable in "value"
void CObjectRigidBody::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(localPosition, configuration)); break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetPosition(localPosition, configuration) - GetPosition(localPosition, ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(localPosition, configuration)); break;
	case OutputVariableType::Acceleration: value.CopyFrom(GetAcceleration(localPosition, configuration)); break;

	case OutputVariableType::Rotation: {
		Matrix3D rotMat = GetRotationMatrix(localPosition, configuration);
		Vector3D rot = RigidBodyMath::RotationMatrix2RotXYZ(rotMat);
		value.CopyFrom(rot);
		break;
	}
	case OutputVariableType::AngularVelocity: value.CopyFrom(GetAngularVelocity(localPosition, configuration)); break;
	case OutputVariableType::AngularVelocityLocal: value.CopyFrom(GetAngularVelocityLocal(localPosition, configuration)); break;
	case OutputVariableType::AngularAcceleration: value.CopyFrom(GetAngularAcceleration(localPosition, configuration)); break;

	case OutputVariableType::RotationMatrix: {
		Matrix3D rot = GetRotationMatrix(localPosition, configuration);
		value.SetVector(9, rot.GetDataPointer());
		break;
	}
	default:
		SysError("CObjectRigidBody::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}

//! @todo: add ConfigurationType to CObjectMassPoint::GetPosition; 
//  return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetPosition(configuration) + ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration) * localPosition;

}

//! return the (global) position of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetPosition(configuration) - ((CNodeRigidBody*)GetCNode(0))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

//  return the (global) velocity of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return ((CNodeRigidBody*)GetCNode(0))->GetVelocity(configuration) +
		((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration) *
		((CNodeRigidBody*)GetCNode(0))->GetAngularVelocityLocal(configuration).CrossProduct(localPosition); //add omega x r
}

//  return the (global) acceleration of "localPosition" according to configuration type
Vector3D CObjectRigidBody::GetAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \ddot R + \alpha x (A * \localPosition) + \omega x (\omega x (A * \localPosition))
	Vector3D relativePosition = ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration) * localPosition;
	Vector3D omega = ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocity(configuration);
	return ((CNodeRigidBody*)GetCNode(0))->GetAcceleration(configuration) +
		((CNodeRigidBody*)GetCNode(0))->GetAngularAcceleration(configuration).CrossProduct(relativePosition) +
		omega.CrossProduct(omega.CrossProduct(relativePosition));
}

Matrix3D CObjectRigidBody::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetRotationMatrix(configuration);
}

//! return configuration dependent angular velocity of rigid body; returns always a 3D Vector
Vector3D CObjectRigidBody::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocity(configuration);
}

//! return configuration dependent local (=body fixed) angular velocity of rigid body; returns always a 3D Vector
Vector3D CObjectRigidBody::GetAngularVelocityLocal(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetAngularVelocityLocal(configuration);
}

//! return configuration dependent angular acceleration of rigid body; returns always a 3D Vector
Vector3D CObjectRigidBody::GetAngularAcceleration(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(0))->GetAngularAcceleration(configuration);
}

