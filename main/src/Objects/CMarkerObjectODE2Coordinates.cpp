/** ***********************************************************************************************
* @brief        implementation for MarkerObjectODE2Coordinates
*
* @author       Gerstmayr Johannes
* @date         2019-05-02 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: missing
                
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Utilities/RigidBodyMath.h"

#include <pybind11/pybind11.h>      //! AUTO: include pybind for dictionary access
#include <pybind11/stl.h>           //! AUTO: needed for stl-casts; otherwise py::cast with std::vector<Real> crashes!!!
namespace py = pybind11;            //! AUTO: "py" used throughout in code
#include "Autogenerated/CMarkerObjectODE2Coordinates.h"

//for consistency checks:
#include "Main/MainSystem.h"
#include "Pymodules/PybindUtilities.h"
#include "Autogenerated/MainMarkerObjectODE2Coordinates.h"

bool MainMarkerObjectODE2Coordinates::CheckPreAssembleConsistency(const MainSystem& mainSystem, STDstring& errorString) const
{
	const CMarkerObjectODE2Coordinates* cMarker = GetCMarkerObjectODE2Coordinates();

	//Check: object=body, all nodes are ODE2?

	//valid object number has been already checked in CSystem::CheckSystemIntegrity
	Index objectNumber = cMarker->GetObjectNumber();
	const CObject* cObjectPtr = mainSystem.GetMainSystemData().GetMainObjects()[objectNumber]->GetCObject();

	if (((Index)cObjectPtr->GetType() & (Index)CObjectType::Body) == 0)
	{
		errorString = "MarkerObjectODE2Coordinates: object must be a body!";
		return false;
	}

	for (Index j = 0; j < cObjectPtr->GetNumberOfNodes(); j++)
	{
		if (((Index)cObjectPtr->GetCNode(j)->GetNodeGroup() & (Index)CNodeGroup::ODE2variables) == 0)
		{
			errorString = "MarkerObjectODE2Coordinates: all nodes of marker object must have ODE2 coordinates!";
			return false;
		}
	}

	return true;
}

//! return number of coordinates of the attached object
Index CMarkerObjectODE2Coordinates::GetDimension(const CSystemData& cSystemData) const
{
	Index objectNumber = GetObjectNumber();
	return cSystemData.GetCObjects()[objectNumber]->GetODE2Size();
}

//! return the ODE2 coordinate vectors (and derivative) of the attached object
void CMarkerObjectODE2Coordinates::GetObjectODE2Coordinates(const CSystemData& cSystemData, Vector& objectCoordinates, Vector& objectCoordinates_t) const
{
	Index objectNumber = GetObjectNumber();
	const CObject& cObject = *(cSystemData.GetCObjects()[objectNumber]);
	CHECKandTHROW(((Index)cObject.GetType() & (Index)CObjectType::Body) != 0, "CMarkerObjectODE2Coordinates::GetObjectODE2Coordinates: object must be a body!");

	Index nOC = GetDimension(cSystemData);
	objectCoordinates.SetNumberOfItems(nOC);
	objectCoordinates_t.SetNumberOfItems(nOC);

	//const CObjectBody& cObjectBody = (const CObjectBody&)cObject;

	Index cnt = 0; //marks offset in objectCoordinates / _t
	//consecutively work through nodes, as coordinate assembly in CSystem.cpp
	for (Index j = 0; j < cObject.GetNumberOfNodes(); j++)
	{
		const CNodeODE2* node = (const CNodeODE2*)cObject.GetCNode(j);
		Index nc = node->GetNumberOfODE2Coordinates();
		if (nc)
		{
			LinkedDataVector p(objectCoordinates, cnt, nc);  //position level coordinates
			LinkedDataVector v(objectCoordinates_t, cnt, nc);//velocity coordinates
			p = node->GetReferenceCoordinateVector(); //set all coordinates to reference values
			p += node->GetCurrentCoordinateVector();  //add current values
			v = node->GetCurrentCoordinateVector_t(); //set all coordinates to current velocity values
			cnt += nc;
		}
	}
	//alternatively:
	//use objectLTG to set coordinates
	//BUT: reference values must be used from stored global reference values, not from nodal reference values
}


void CMarkerObjectODE2Coordinates::ComputeMarkerData(const CSystemData& cSystemData, bool computeJacobian, MarkerData& markerData) const
{
	Index n = GetDimension(cSystemData); //works already for both cases
	if (n) //access to coordinates only, not ground node/body (which has no real coordinates, but it is allows to constrain to a ground node 'coordinate' being always zero
	{
		GetObjectODE2Coordinates(cSystemData, markerData.vectorValue, markerData.vectorValue_t);
		markerData.velocityAvailable = true;

		if (computeJacobian)
		{
			//zero-vector with 1 at parameters.coordinate => this is also done for velocity markers; this might not work for non-holonomic constraints
			//this could be optimized ...; leads to large computational efforts for larger objects
			markerData.jacobian.SetScalarMatrix(n, 1.);
		}
	}
	else //ground node/object
	{
		markerData.velocityAvailable = true;
		markerData.vectorValue.SetVector({});
		markerData.vectorValue_t.SetVector({}); //set this also for ground markers, because it could be asked for in connector!!!!
		markerData.jacobian.SetNumberOfRowsAndColumns(0, 0); //this signals the connector/system not to apply any load or Lagrange multiplier
	}
}

