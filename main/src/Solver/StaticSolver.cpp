/** ***********************************************************************************************
* @brief		Implementation for static solver
* @details		Details:
* 				- a nonlinear static solver for multibody systems; system may not be kinematic, otherwise the solver will not be able to compute static solution ...
*
* @author		Gerstmayr Johannes
* @date			2018-05-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
************************************************************************************************ */

#include "System/versionCpp.h"
#include "Linalg/BasicLinalg.h" //for Resizable Vector
#include "Main/CSystem.h"
#include "Solver/TimeIntegrationSolver.h" 
//#include "Autogenerated/CMarkerBodyPosition.h"

#include <fstream>

//this interface is necessary, because the pybind11 module cannot work directly with the templated solver; Why?
bool SolverStatic::SolveSystem(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (simulationSettings.linearSolverType == LinearSolverType::EXUdense)
	{
		Index n = computationalSystem.GetSystemData().GetNumberOfComputationCoordinates();
		if (n > 1000) { PyWarning("The number of total coordinates (unknowns) is larger than 1000. Consider a sparse solver (SimulationSettings().linearSolverType) to reduce memory consumption and computation time."); }

		GeneralMatrixEXUdense jacobian; //this defines the used solver and matrix type for jacobian
		return SolveSystemTemplate(computationalSystem, simulationSettings, jacobian);
	}
	else if (simulationSettings.linearSolverType == LinearSolverType::EigenSparse)
	{
		EXUstd::AssignParallelizationParameters(simulationSettings);
		GeneralMatrixEigenSparse jacobian; //this defines the used solver and matrix type for jacobian
		return SolveSystemTemplate(computationalSystem, simulationSettings, jacobian);
	}

	PyError("SolverStatic::SolveSystem: Invalid simulationSettings.linearSolverType");

	return false; //no success/error
}

template<class TGeneralMatrix>
bool SolverStatic::SolveSystemTemplate(CSystem& computationalSystem, const SimulationSettings& simulationSettings, TGeneralMatrix& systemJacobian)
{
	if (!computationalSystem.IsSystemConsistent()) { SysError("StaticSolver: system is inconsistent and cannot be solved (call Assemble() and check error messages)"); return false; }


	computationalSystem.GetPostProcessData()->stopSimulation = false;
	computationalSystem.GetPostProcessData()->SetVisualizationMessage("Static solver started");
	computationalSystem.GetSolverData().Reset(); //e.g. set load factor to 1

	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;
	const NewtonSettings& newton = staticSolver.newton;
	const NumericalDifferentiationSettings& numDiff = newton.numericalDifferentiation;
	const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;

	STDstring fileName = solutionSettings.coordinatesSolutionFileName;
	std::ofstream file;

	computationalSystem.GetPostProcessData()->simulationFinished = false;
	computationalSystem.GetPostProcessData()->postProcessDataReady = false;
	//do not initialize, because every update is indicated by change of this counter!: computationalSystem.GetPostProcessData()->updateCounter = 1;

	Index verbose = staticSolver.verboseMode; //0 ... no output, 1 ... show short step information (error), 2 ... show also solution vector, 3 ... show also jacobian, 4 ... show also Jacobian inverse

	if (verbose >= 1) { pout << "EXUDYN V" << EXUstd::exudynVersion << "\n"; }
	if (verbose >= 1) { pout << "Static solver\n+++++++++++++\n"; }

	Index nODE2 = computationalSystem.GetSystemData().GetNumberOfCoordinatesODE2();
	Index nODE1 = computationalSystem.GetSystemData().GetNumberOfCoordinatesODE1();
	Index nAE  = computationalSystem.GetSystemData().GetNumberOfCoordinatesAE();
	Index nSys = nODE2 + nODE1 + nAE;

	//Index nData = computationalSystem.GetSystemData().GetNumberOfCoordinatesData();

	//Index startODE1 = nODE2;
	Index startAE = nODE2 + nODE1;
	//if (startODE1 == nSys) { startODE1 = 0; } //startODE1 == nSys would lead to invalid pointer in LinkedDataVector; can only happen, if nODE1==0
	if (startAE == nSys) { startAE = 0; } //startAE == nSys would lead to invalid pointer in LinkedDataVector; can only happen, if nAE==0

	if (nODE1 != 0) { SysError("Static solver cannot solve first order differential equations (ODE1)"); }


	if (!nSys)
	{
		SysError("Static solver: System size = 0");
		return false;
	}

	bool writeToFile = solutionSettings.writeSolutionToFile;
	if (fileName != "" && writeToFile)
	{
		CheckPathAndCreateDirectories(fileName);
		if (solutionSettings.appendToFile) { file.open(fileName, std::ofstream::app); }
		else { file.open(fileName, std::ofstream::out); }
		if (!file.is_open()) //failed to open file ...  e.g. invalid file name
		{
			writeToFile = false;
			SysError(STDstring("failed to open file '") + fileName + "'");
		}
		file.precision(solutionSettings.outputPrecision);
	}
	else { writeToFile = false; }

	if (writeToFile && solutionSettings.writeFileHeader)
	{
		file.precision(solutionSettings.outputPrecision);
		//Index nVel = 0;
		//Index nAcc = 0;
		//Index nLambda = 0;
		//Index nDataExported = 0;

		//if (solutionSettings.exportAlgebraicCoordinates) { nLambda = nAE; }
		//if (solutionSettings.exportDataCoordinates) { nDataExported = nData; }

		if (solutionSettings.writeFileHeader)
		{
			file.precision(solutionSettings.outputPrecision);
			bool isStatic = true; //solver type
			HSolver::WriteSolutionFileHeader(computationalSystem, simulationSettings, file, "nonlinear", isStatic);
		}
	}

	//++++++++++++++++++++++++++++
	//chose correct mass matrix according to jacobian:
	//GeneralMatrixEXUdense systemJacobian;
	bool sparse = false;
	if (systemJacobian.GetSystemMatrixType() == LinearSolverType::EigenSparse) { sparse = true; }
	
	GeneralMatrixEigenSparse matSparse;
	GeneralMatrixEXUdense matDense;
	GeneralMatrix& systemMassMatrixGM = sparse ? (GeneralMatrix&)matSparse : (GeneralMatrix&)matDense;

	systemJacobian.SetNumberOfRowsAndColumns(nSys, nSys);
	ResizableVector newtonSolution(nSys);	//temporary vector for Newton
	LinkedDataVector newtonSolutionODE2(newtonSolution, 0, nODE2); //temporary subvector for ODE2 components
	LinkedDataVector newtonSolutionAE(newtonSolution, startAE, nAE); //temporary subvector for ODE2 components
	ResizableVector systemRHS(nSys); //solution
	
	//link system vectors:
	LinkedDataVector systemODE2Rhs(systemRHS, 0, nODE2); //link ODE2 coordinates
	//LinkedDataVector ode1Rhs(systemRHS, startODE1, nODE1); //link ODE1 coordinates
	LinkedDataVector aeRhs(systemRHS, startAE, nAE); //link ODE1 coordinates

	ResizableVector tempODE2F0(nODE2);	//temporary vector for ODE2 Jacobian
	ResizableVector tempODE2F1(nODE2);	//temporary vector for ODE2 Jacobian

	ResizableVector tempAE_F0(nODE2);	//temporary vector for AE Jacobian (derivative with respect to ODE2!!!)
	ResizableVector tempAE_F1(nODE2);	//temporary vector for AE Jacobian (derivative with respect to ODE2!!!)

	TemporaryComputationData tempCompData;

	//current values = initial values
	computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords = computationalSystem.GetSystemData().GetCData().initialState.ODE2Coords;
	//these initial values are to be seen as stationary values, if needed (e.g. in special fluid problems or constant rotation speed)
	computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t = computationalSystem.GetSystemData().GetCData().initialState.ODE2Coords_t;
	computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords = computationalSystem.GetSystemData().GetCData().initialState.ODE1Coords;
	computationalSystem.GetSystemData().GetCData().currentState.AECoords = computationalSystem.GetSystemData().GetCData().initialState.AECoords;
	computationalSystem.GetSystemData().GetCData().currentState.dataCoords = computationalSystem.GetSystemData().GetCData().initialState.dataCoords;

	//link current system vectors for ODE2
	Vector& solutionODE2 = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	Vector& solutionAE = computationalSystem.GetSystemData().GetCData().currentState.AECoords;
	Vector& solutionData = computationalSystem.GetSystemData().GetCData().currentState.dataCoords;

	if (verbose >= 3) 
	{ 
		pout << "Newton: initial ODEcoords = " << solutionODE2 << "\n";
		pout << "Newton: initial AEcoords = " << solutionAE << "\n";
		pout << "Newton: initial dataCoords = " << solutionData << "\n";
	}


	//+++++++++++++++++++++++++++++++++++++++++
	//NEWTON
	bool errorOccurred = false; //error during static solver
	bool converged = false; //if false, convergence of solver failed
	bool abortStaticSolver = false; //flag to signal, that static solver needs to be stopped (e.g. in case of multiple errors)
	Real initialResiduum;
	Index totalNewtonSteps = 0; //accumulated Newton steps over all load steps

	//Real time = staticSolver.currentTime; //quasi-time for postprocessing / file output
	Real numberOfLoadSteps = (Real)staticSolver.numberOfLoadSteps; //stored as float number to do some non-integer calculations
	Real loadStepTolerance = 1e-8; //tolerance accepted by load step incrementation

	Real loadStepDuration = staticSolver.loadStepDuration;
	Real loadStepStart = staticSolver.loadStepStart; //this is the offset time for the static solver
	bool loadStepGeometric = staticSolver.loadStepGeometric; //use geometric seriew
	Real loadStepGeometricRange = staticSolver.loadStepGeometricRange; //span of the geometric series

	if (numberOfLoadSteps == 0) { SysError("number of load steps is zero"); return false; }

	if (numberOfLoadSteps > 1 && writeToFile) //write initial configuration for a series of load steps
	{
		file << computationalSystem.GetSystemData().GetCData().currentState.time;
		for (Index k = 0; k < solutionODE2.NumberOfItems(); k++) {file << "," << solutionODE2[k];}
		for (Index k = 0; k < solutionAE.NumberOfItems(); k++) {file << "," << solutionAE[k];}
		for (Index k = 0; k < solutionData.NumberOfItems(); k++) {file << "," << solutionData[k];}
		file << "\n";
	}

	Real loadStepGeometricFactor = pow(loadStepGeometricRange, 1. / numberOfLoadSteps) ; //multiplicative load step factor
	Real loadStepFactor = 1. / numberOfLoadSteps; //this is the current load step factor in range [initial value,1], which is increased at end of step; used to scale loads arithmetically/geometrically
	if (loadStepGeometric) { loadStepFactor = loadStepGeometricFactor / loadStepGeometricRange; } //initial value for geometric load step factor

	Index loadStepNumber = 0; //counter; just for file headers to be written only at first step
	
	Index discontinuousIterations;															//current number of discontinuous iteration
	Index maxDiscontinuousIterations = staticSolver.newton.maxDiscontinuousIterations;
	Real discontinuousIterationTolerance = staticSolver.newton.discontinuousIterationTolerance;	//absolute error
	Real discontinuousIterationError;
	ResizableVector previousDataCoords; //to remember data coords state of previous iteration

	computationalSystem.GetSystemData().GetCData().currentState.time = loadStepStart; //increment this by loadStepTime/numberOfLoadSteps in load steps...

	Real diagnonalODE2stabilizer = staticSolver.stabilizerODE2term; //stabilization: add M * u_Newton to system equations (=approx. mass proportional damping)
	Real currentODE2stabilizer = diagnonalODE2stabilizer;

	if (simulationSettings.pauseAfterEachStep) { computationalSystem.GetPostProcessData()->WaitForUserToContinue(); }
	SolverTimer timer;
	timer.Reset();
	timer.total = -EXUstd::GetTimeInSeconds();

	//++++++++++++++++++++++++++++++++++++++
	//LOAD STEPS
	bool staticSolverFinished = false; //successful finished load steps
	while (!staticSolverFinished && !abortStaticSolver)
	{
		if (verbose >= 1 && numberOfLoadSteps != 1) 
		{ 
			if (verbose >= 2) { pout << "\n=========================\n=========================\n";}
			pout << "LOAD STEP " << loadStepNumber << ", load factor = " << loadStepFactor << ":\n";
		}

		computationalSystem.GetSystemData().GetCData().startOfStepState = computationalSystem.GetSystemData().GetCData().currentState; //for step reduction, nonlinear iteration, python functions, etc.
		computationalSystem.GetSolverData().loadFactor = loadStepFactor; //scale loads e.g. in ODERHS(...) with loadFactor

		discontinuousIterationError = discontinuousIterationTolerance;
		discontinuousIterations = 0;

		//++++++++++++++++++++++++++++++++++++++
		//DISCONTINUOUS ITERATIONS
		while (!abortStaticSolver && discontinuousIterationError >= discontinuousIterationTolerance && discontinuousIterations++ < maxDiscontinuousIterations)
		{
			previousDataCoords.CopyFrom(computationalSystem.GetSystemData().GetCData().currentState.dataCoords); //contain the current state of discont. iterations
			computationalSystem.GetSystemData().GetCData().currentState = computationalSystem.GetSystemData().GetCData().startOfStepState; //always start the nonlinear iteration with startOfStep (start of load step)
			computationalSystem.GetSystemData().GetCData().currentState.dataCoords.CopyFrom(previousDataCoords);
			//pout << "  previousData=" << computationalSystem.GetSystemData().GetCData().currentState.dataCoords << "\n";
			//+++++++++++++++++++++++++++++++
			//initialize Newton solver
			errorOccurred = false; //error during static solver
			converged = false; //if false, convergence of solver failed

			Index newtonStep = 0; //current number of Newton steps

			initialResiduum = newton.absoluteTolerance;
			Real residual = initialResiduum;

			bool firstStep = true; //do different computations in first step
			//+++++++++++++++++++++++++++++
			//Newton solver
			while (!errorOccurred && !converged && newtonStep < newton.maxIterations && !computationalSystem.GetPostProcessData()->stopSimulation)
			{
				if (!firstStep)
				{
					newtonStep++; //every jacobian computation in full Newton corresponds to one step
					totalNewtonSteps++; //accumulated steps
					if (verbose >= 3) { pout << "  Newton: STEP " << newtonStep << ":\n"; }

					timer.totalJacobian -= EXUstd::GetTimeInSeconds();
					//compute jacobian:
					timer.jacobianODE2 -= EXUstd::GetTimeInSeconds();
					systemJacobian.SetAllZero();
					computationalSystem.NumericalJacobianODE2RHS(tempCompData, numDiff, tempODE2F0, tempODE2F1, systemJacobian);
					timer.jacobianODE2 += EXUstd::GetTimeInSeconds();

					timer.jacobianAE -= EXUstd::GetTimeInSeconds();
					computationalSystem.JacobianAE(tempCompData, newton, systemJacobian, 1., 1., false, true); //inserted into right position
					timer.jacobianAE += EXUstd::GetTimeInSeconds();
					timer.totalJacobian += EXUstd::GetTimeInSeconds();

					computationalSystem.GetSolverData().signalJacobianUpdate = false; //as jacobian has been computed, no further update is necessary

					if (currentODE2stabilizer != 0.)
					{
						timer.massMatrix -= EXUstd::GetTimeInSeconds();
						//TemporaryComputationData tempCompData;

						systemMassMatrixGM.SetNumberOfRowsAndColumns(nODE2, nODE2);
						systemMassMatrixGM.SetAllZero();
						computationalSystem.ComputeMassMatrix(tempCompData, systemMassMatrixGM);
						systemMassMatrixGM.MultiplyWithFactor(-currentODE2stabilizer);

						//pout << "Sold=" << systemMassMatrixGM << "\n";

						systemJacobian.AddSubmatrix(systemMassMatrixGM);
						timer.massMatrix += EXUstd::GetTimeInSeconds();

					}

					if (verbose >= 4) { pout << "    Jac    = \n" << systemJacobian << "\n"; }

					timer.factorization -= EXUstd::GetTimeInSeconds();
					systemJacobian.FinalizeMatrix();
					Index jacobianInvertRV = systemJacobian.Factorize(); // .Invert(); //rv of factorize = 0 if success
					timer.factorization += EXUstd::GetTimeInSeconds();

					if (jacobianInvertRV != 0)
					{
						SysError("SolverStatic::SolveSystem: Jacobian not invertible!");
						errorOccurred = true;
					}
					else
					{
						if (verbose >= 5) { pout << "    JacInv = \n" << systemJacobian << "\n"; }
						if (verbose >= 5) { pout << "    JacInv = \n" << systemJacobian << "\n"; }


						timer.newtonIncrement -= EXUstd::GetTimeInSeconds();
						//now compute descent of solution vector with jacobian
						systemJacobian.Solve(systemRHS, newtonSolution); //EXUmath::MultMatrixVector(systemJacobian, systemRHS, newtonSolution);
						//compute descent, because f_spring = k*u ==> k*u = F, all to RHS: systemRHS = F-k*u = 0 ==> u = u - Jac*systemRHS
						solutionODE2 -= newtonSolutionODE2;
						solutionAE -= newtonSolutionAE;
						timer.newtonIncrement += EXUstd::GetTimeInSeconds();

					}
				}
				if (!errorOccurred)
				{
					//now compute the new residual:
					timer.ODE2RHS -= EXUstd::GetTimeInSeconds();
					computationalSystem.ComputeSystemODE2RHS(tempCompData, systemODE2Rhs); //this is the system residual
					timer.ODE2RHS += EXUstd::GetTimeInSeconds();

					timer.AERHS -= EXUstd::GetTimeInSeconds();
					computationalSystem.ComputeAlgebraicEquations(tempCompData, aeRhs); //this is the system residual
					timer.AERHS += EXUstd::GetTimeInSeconds();

					if (currentODE2stabilizer != 0. && !firstStep) //in first step, the solutionODE2 is not available!!!
					{
						timer.massMatrix -= EXUstd::GetTimeInSeconds();

						systemMassMatrixGM.SetNumberOfRowsAndColumns(nODE2, nODE2);
						systemMassMatrixGM.SetAllZero();
						computationalSystem.ComputeMassMatrix(tempCompData, systemMassMatrixGM);

						systemMassMatrixGM.MultiplyWithFactor(-currentODE2stabilizer);

						//this could be optimized, avoiding new during static computation:
						Vector x = solutionODE2;
						x -= computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords;
						Vector stabilizer;
						//stabilizer = systemMassMatrix * x;
						systemMassMatrixGM.MultMatrixVector(x, stabilizer);

						for (Index i = 0; i < nODE2; i++)
						{
							systemODE2Rhs[i] += stabilizer[i];
						}

						timer.massMatrix += EXUstd::GetTimeInSeconds();

					}

					//+++++++++++++++++++++++++++++++++
					//add CqT*lambda terms:
					timer.reactionForces -= EXUstd::GetTimeInSeconds();
					computationalSystem.ComputeODE2ProjectedReactionForces(tempCompData, solutionAE, systemODE2Rhs);
					timer.reactionForces += EXUstd::GetTimeInSeconds();
					//+++++++++++++++++++++++++++++++++

					residual = systemRHS.GetL2Norm();
					
					if (firstStep)
					{
						initialResiduum = residual;
						firstStep = false;
						if (verbose >= 3) { pout << "Newton: initial residual = " << initialResiduum << "\n"; }
						if (verbose >= 3) { pout << "Newton: initial RHS = " << systemRHS << "\n"; }
					}

					if (verbose == 2)
					{
						pout << "    STEP " << newtonStep << ": residual = " << residual << ", rel error = " << residual / initialResiduum << "\n";
					}
					if (verbose >= 3)
					{
						pout << "    residual = " << residual << "\n";
						pout << "    RHS      = " << systemRHS << "\n";
						pout << "    solODE2  = " << solutionODE2 << "\n";
						pout << "    solAE    = " << solutionAE << "\n";
						pout << "    solData    = " << solutionData << "\n";
					}

					if (residual / initialResiduum <= newton.relativeTolerance)
					{
						converged = true;
					}
					else if (residual <= newton.absoluteTolerance)
					{
						converged = true;
						if (verbose >= 3) { pout << "convergence reached with absolute error = " << residual << "\n"; }
					}
					if (residual > initialResiduum) { initialResiduum = residual; } //for some simulations, the initial residual is small, but the jumps high
				}
			}

			if (!computationalSystem.GetPostProcessData()->stopSimulation)
			{
				if (!errorOccurred)
				{
					if (!converged)
					{
						if (verbose >= 1) { pout << "  Newton: convergence failed after max steps (" << newton.maxIterations << "); relative error = " << residual / initialResiduum << "\n"; }
						abortStaticSolver = true;
					}
					else
					{
						if (verbose >= 1) { pout << "  Newton: converged after " << newtonStep << " steps; relative error = " << residual / initialResiduum << "\n"; }

						if (writeToFile)
						{
							file << computationalSystem.GetSystemData().GetCData().currentState.time;

							for (Index k = 0; k < solutionODE2.NumberOfItems(); k++)
							{
								file << "," << solutionODE2[k];
							}
							if (solutionSettings.exportAlgebraicCoordinates)
							{
								for (Index k = 0; k < solutionAE.NumberOfItems(); k++)
								{
									file << "," << solutionAE[k];
								}
							}
							if (solutionSettings.exportDataCoordinates)
							{
								for (Index k = 0; k < solutionData.NumberOfItems(); k++)
								{
									file << "," << solutionData[k];
								}
							}
							file << "\n";

						}
					}
				}
				else
				{
					abortStaticSolver = true;
				}
			} // !stopped simulation
			else
			{
				abortStaticSolver = true;
			}
			
			timer.postNewton -= EXUstd::GetTimeInSeconds();
			discontinuousIterationError = computationalSystem.PostNewtonStep(tempCompData);
			timer.postNewton += EXUstd::GetTimeInSeconds();

			if (verbose >= 1) { pout << "  Discontinuous iteration error = " << discontinuousIterationError << "\n"; }

		} //discontinuous iteration

		//+++++++++++++++++++++++++++++
		//increment load steps and update postprocess data
		if (!abortStaticSolver)
		{
			if (loadStepFactor >= 1 - loadStepTolerance)
			{
				staticSolverFinished = true;
			}
			else
			{
				if (!loadStepGeometric)
				{
					loadStepFactor += 1. / numberOfLoadSteps;
				}
				else
				{
					if (verbose >= 1) { pout << "  loadStepFactor = " << loadStepFactor << ", loadStepGeometricFactor = " << loadStepGeometricFactor << "\n"; }
					loadStepFactor *= loadStepGeometricFactor;
				}
			}

			currentODE2stabilizer = (1-pow(loadStepFactor,2))*diagnonalODE2stabilizer;

			computationalSystem.GetSystemData().GetCData().currentState.time = loadStepStart + loadStepFactor * loadStepDuration; //increment this by loadStepTime/numberOfLoadSteps in load steps...
			computationalSystem.UpdatePostProcessData();
			loadStepNumber++; //first step = 0
		}

		if (simulationSettings.pauseAfterEachStep && !abortStaticSolver && !computationalSystem.GetPostProcessData()->stopSimulation) { computationalSystem.GetPostProcessData()->WaitForUserToContinue(); }

	} //load steps loop

	timer.total += EXUstd::GetTimeInSeconds();
	
	if (abortStaticSolver) 
	{ 
		if (computationalSystem.GetPostProcessData()->stopSimulation)
		{
			pout << "Static solver stopped by user after " << timer.total << " seconds.\n";
			computationalSystem.GetPostProcessData()->SetVisualizationMessage("Static solver stopped by user");
		}
		else if (simulationSettings.displayComputationTime) 
		{ 
			pout << "Static solver finished with ERRORS after " << timer.total << " seconds. See output for further information.\n";
			computationalSystem.GetPostProcessData()->SetVisualizationMessage("Static solver finished with errors");
		}
		
		if (writeToFile && loadStepNumber<=1) //if no header written yet ...
		{
			file << "#Exudyn static solver solution\n";
			file << "#no output written because of errors\n";
		}
	} //abort solver
	else 
	{ 
		if (simulationSettings.displayComputationTime && (verbose >= 1)) { pout << "Static solver finished after " << timer.total << " seconds.\n"; }

		computationalSystem.GetPostProcessData()->simulationFinished = true; //signal that last step should be rendered
		computationalSystem.GetPostProcessData()->SetVisualizationMessage("Static solver finished successfully");
		computationalSystem.UpdatePostProcessData();
	}
	if (simulationSettings.displayStatistics) 
	{ 
		pout << "Total Newton iterations = " << totalNewtonSteps << "\n";
		timer.Print();
	}

	if (writeToFile)
	{
		if (solutionSettings.writeFileFooter)
		{
			file << "#simulation finished=" << EXUstd::GetDateTimeString() << "\n";
			file << "#Solver Info:";
			file << " errorOccurred=" << errorOccurred;
			file << ",converged=" << converged;
			file << ",solver stopped by user=" << computationalSystem.GetPostProcessData()->stopSimulation;
			file << ",total Newton iterations=" << totalNewtonSteps;
			file << ",total load steps=" << loadStepNumber;
			file << "\n";
		}

	}

	return !abortStaticSolver; //true = success
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! helper functions for Exudyn solver
namespace HSolver {

	//! write solution file header commonly for static and dynamic solvers
	void WriteSolutionFileHeader(CSystem& computationalSystem, const SimulationSettings& simulationSettings, std::ofstream& file,
		const STDstring& solverName, bool isStatic)
	{
		const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;
		const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration; //only needed for time integration header
		const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;  //only needed for static solver header

		Index nVel1 = 0;
		Index nVel2 = 0;
		Index nAcc2 = 0;
		Index nAEexported = 0;
		Index nDataExported = 0;

		Index nODE2 = computationalSystem.GetSystemData().GetNumberOfCoordinatesODE2();
		Index nODE1 = computationalSystem.GetSystemData().GetNumberOfCoordinatesODE1();
		Index nAE = computationalSystem.GetSystemData().GetNumberOfCoordinatesAE();
		Index nData = computationalSystem.GetSystemData().GetNumberOfCoordinatesData();
		//Index nSys = nODE2 + nODE1 + nAE;

		if (solutionSettings.exportVelocities && !isStatic) { nVel2 = nODE2; nVel1 = nODE1; }
		if (solutionSettings.exportAccelerations && !isStatic) { nAcc2 = nODE2; }
		if (solutionSettings.exportAlgebraicCoordinates) { nAEexported = nAE; }
		if (solutionSettings.exportDataCoordinates) { nDataExported = nData; }

		if (solutionSettings.writeFileHeader)
		{
			file << "#Exudyn " << solverName << " ";
			if (isStatic) { file << "static "; }
			file << "solver solution file\n";
			file << "#simulation started=" << EXUstd::GetDateTimeString() << "\n";
			file << "#columns contain: time, ODE2 displacements";
			if (solutionSettings.exportVelocities) { file << ", ODE2 velocities"; }
			if (solutionSettings.exportAccelerations) { file << ", ODE2 accelerations"; }
			if (nODE1) { file << ", ODE1 coordinates"; } //currently not available, but for future file structure necessary!
			if (nVel1) { file << ", ODE1 velocities"; }
			if (solutionSettings.exportAlgebraicCoordinates) { file << ", AE coordinates"; }
			if (solutionSettings.exportDataCoordinates) { file << ", ODE2 velocities"; }
			file << "\n";

			file << "#number of system coordinates [nODE2, nODE1, nAlgebraic, nData] = [" <<
				nODE2 << "," << nODE1 << "," << nAE << "," << nData << "]\n"; //this will allow to know the system information, independently of coordinates written
			file << "#number of written coordinates [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = [" << //these are the exported coordinates line-by-line
				nODE2 << "," << nVel2 << "," << nAcc2 << "," << nODE1 << "," << nVel1 << "," << nAEexported << "," << nDataExported << "]\n"; //python convert line with v=eval(line.split('=')[1])

			file << "#total columns exported  (excl. time) = " << nODE2 + nVel2 + nAcc2 + nODE1 + nVel1 + nAEexported + nDataExported << "\n";
			if (!isStatic) { file << "#number of time steps (planned) = " << timeint.numberOfSteps << "\n"; }
			else { file << "#number of load steps (planned) = " << staticSolver.numberOfLoadSteps << "\n"; }
			file << "#\n"; //empty line for extension ...

			if (solutionSettings.solutionInformation.length())
			{
				file << "#solution information = " << solutionSettings.solutionInformation << "\n";
			}
		}

	}


	void WriteCoordinatesToFile(Real& lastSolutionWritten, const SolutionSettings& solutionSettings,
		std::ofstream& file, const CSystem& computationalSystem)
	{
		Real t = computationalSystem.GetSystemData().GetCData().currentState.time;
		Real startTime = computationalSystem.GetSystemData().GetCData().initialState.time;

		const Vector& solutionU = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
		const Vector& solutionV = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
		const Vector& solutionA = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
		const Vector& solutionLambda = computationalSystem.GetSystemData().GetCData().currentState.AECoords;
		const Vector& solutionData = computationalSystem.GetSystemData().GetCData().currentState.dataCoords;

		if (t == startTime || (t - lastSolutionWritten) >= (solutionSettings.solutionWritePeriod - 1e-10)) //1e-10 because of roundoff errors
		{

			lastSolutionWritten += solutionSettings.solutionWritePeriod;
			lastSolutionWritten = EXUstd::Maximum(lastSolutionWritten, t); //never accept smaller values ==> for adaptive solver
			file << t;

			for (Index k = 0; k < solutionU.NumberOfItems(); k++) {
				file << "," << solutionU[k];
			}
			if (solutionSettings.exportVelocities)
			{
				for (Index k = 0; k < solutionV.NumberOfItems(); k++) {
					file << "," << solutionV[k];
				}
			}
			if (solutionSettings.exportAccelerations)
			{
				for (Index k = 0; k < solutionA.NumberOfItems(); k++) {
					file << "," << solutionA[k];
				}
			}
			if (solutionSettings.exportAlgebraicCoordinates)
			{
				for (Index k = 0; k < solutionLambda.NumberOfItems(); k++) {
					file << "," << solutionLambda[k];
				}
			}
			if (solutionSettings.exportDataCoordinates)
			{
				for (Index k = 0; k < solutionData.NumberOfItems(); k++) {
					file << "," << solutionData[k];
				}
			}
			file << "\n";
		}
	}

}

