/** ***********************************************************************************************
* @brief		Implementation for (old) time integration solvers: RK1 and implicit (Newmark/generalized alpha)
* @details		Details:
 				- a solver for time integration
                - in future, this file will collect time integration solvers
*
* @author		Gerstmayr Johannes
* @date			2018-05-17 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: missing
* 				
*
************************************************************************************************ */
#include <pybind11/pybind11.h>
#include <pybind11/eval.h>

#include "Autogenerated/versionCpp.h"
#include "Linalg/BasicLinalg.h" //for Resizable Vector
#include "Main/CSystem.h"
#include "Solver/TimeIntegrationSolver.h" 
#include "Autogenerated/CMarkerBodyPosition.h"

#include <fstream>

namespace py = pybind11;

bool SolverRK1::SolveSystem(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (simulationSettings.linearSolverType == LinearSolverType::EXUdense)
	{
		Index n = computationalSystem.GetSystemData().GetNumberOfComputationCoordinates();
		if (n > 1000) { PyWarning("The number of total coordinates (unknowns) is larger than 1000. Consider a sparse solver (SimulationSettings().linearSolverType) to reduce memory consumption and computation time."); }

		GeneralMatrixEXUdense matrix; //this defines the used solver and matrix type
		return SolveSystemTemplate(computationalSystem, simulationSettings, matrix);
	}
	else if (simulationSettings.linearSolverType == LinearSolverType::EigenSparse)
	{
		EXUstd::AssignParallelizationParameters(simulationSettings);
		GeneralMatrixEigenSparse matrix; //this defines the used solver and matrix type
		return SolveSystemTemplate(computationalSystem, simulationSettings, matrix);
	}

	PyError("SolverRK1::SolveSystem: Invalid simulationSettings.linearSolverType");

	return false; //no success/error

}

template<class TGeneralMatrix>
bool SolverRK1::SolveSystemTemplate(CSystem& computationalSystem, const SimulationSettings& simulationSettings, TGeneralMatrix& massMatrix)
{
	if (!computationalSystem.IsSystemConsistent()) { SysError("Solver RungeKutta1: system is inconsistent and cannot be solved (call Assemble() and check error messages)"); return false; }

	computationalSystem.GetPostProcessData()->stopSimulation = false;
	//computationalSystem.GetPostProcessData()->visualizationTime = 0;
	computationalSystem.GetPostProcessData()->SetVisualizationMessage("Explicit solver started");
	computationalSystem.GetSolverData().Reset(); //e.g. set load factor to 1

	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration;
	const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;
	Index verbose = timeint.verboseMode;

	if (verbose >= 1) { pout << "EXUDYN V" << EXUstd::exudynVersion << "\n"; }
	if (verbose >= 1) { pout << "Time integration solver: explicit RungeKutta RK1\n++++++++++++++++++++++++++++++++++++++++++++++++\n"; }

	if (computationalSystem.GetSystemData().GetCData().initialState.AECoords.NumberOfItems() != 0)
	{ SysError("SolverRK1::SolveSystem: explicit time integration does not support algebraic coordiantes (constraints)");	}

	computationalSystem.GetPostProcessData()->simulationFinished = false;
	computationalSystem.GetPostProcessData()->postProcessDataReady = false;
	//do not initialize, because every update is indicated by change of this counter!: computationalSystem.GetPostProcessData()->updateCounter = 1;

	Real startTime = timeint.startTime;
	computationalSystem.GetSystemData().GetCData().initialState.time = startTime;
	Real tEnd = timeint.endTime;
	Index n = timeint.numberOfSteps;
	Index nc = computationalSystem.GetSystemData().GetNumberOfCoordinatesODE2();

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//initialize FILE WRITE
	STDstring fileName = solutionSettings.coordinatesSolutionFileName;
	std::ofstream file;
	bool writeToFile = solutionSettings.writeSolutionToFile;
	if (fileName != "" && writeToFile)
	{
		if (solutionSettings.appendToFile) { file.open(fileName, std::ofstream::app); }
		else { file.open(fileName, std::ofstream::out); }
		if (!file.is_open()) //failed to open file ...  e.g. invalid file name
		{
			writeToFile = false;
			SysError(STDstring("failed to open file '") + fileName + "'");
		}
		else
		{
			file.precision(solutionSettings.outputPrecision);
			bool isStatic = false; //solver type
			HSolver::WriteSolutionFileHeader(computationalSystem, simulationSettings, file, "RungeKutta1", isStatic);
		}
	}
	else { writeToFile = false; }
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	Real t = 0;
	Real stepSize = (tEnd - startTime) / (Real)n;
	Real discontinuousIterationError = 0; //for post-Newton discontinuous corrector (is not iterated in explicit time integration)

	//GeneralMatrix& systemMassMatrix = (GeneralMatrix&)massMatrix;
	massMatrix.SetNumberOfRowsAndColumns(nc, nc);

	//ResizableMatrix systemMassMatrix(nc,nc);
	ResizableVector systemRHS(nc);
	ResizableVector temp; //temporary vector used for time integration

	TemporaryComputationData tempCompData;

	//current values = initial values
	computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords = computationalSystem.GetSystemData().GetCData().initialState.ODE2Coords;
	computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t = computationalSystem.GetSystemData().GetCData().initialState.ODE2Coords_t;

	//link current system vectors for ODE2
	Vector& solutionU = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	Vector& solutionV = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
	Vector& solutionA = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
	solutionA.SetNumberOfItems(solutionU.NumberOfItems());
	solutionA.SetAll(0.); //always initialize with zero accelerations ==> could be improved with M^-1*ODE2RHS

	//constant step size explicit Euler solver
	double lastSolutionWritten = startTime;
	double startTimeCPU = EXUstd::GetTimeInSeconds();
	double lastTimePrinted = startTimeCPU;

	if (verbose >= 2) { pout << "start time integration loop\n"; }

	for (Index i=0; i<=n; i++)
    {
		t = i*stepSize + startTime;
		computationalSystem.GetSystemData().GetCData().currentState.time = t; //update time in state --> also available in Python for user-defined functions
		if (((verbose == 1) && ((EXUstd::GetTimeInSeconds() - lastTimePrinted >= 2) || i == n)) || (verbose >= 2))
		{
			lastTimePrinted += 2;
			double timeToGo = (EXUstd::GetTimeInSeconds() - startTimeCPU);
			if (timeToGo > 1 && i != 0)
			{
				timeToGo = (double)n * timeToGo / (double)i;
			}
			else { timeToGo = 0; }
			pout << "STEP" << i << ", t = " << t << " sec, timeToGo = " << timeToGo << " sec\n";
		}

		if (writeToFile) { HSolver::WriteCoordinatesToFile(lastSolutionWritten, solutionSettings, file, computationalSystem); }
		computationalSystem.UpdatePostProcessData();
		if (i == n) { break; } //just write solution in last iteration!
		if (computationalSystem.GetPostProcessData()->stopSimulation) { break; } //stop by user / OpenGL

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//compute system quantities
		massMatrix.SetAllZero();
		computationalSystem.ComputeMassMatrix(tempCompData, massMatrix);

		computationalSystem.ComputeODE2RHS(tempCompData, systemRHS);
		if (verbose >= 3) { pout << "  systemRHS=" << systemRHS << "\n"; }
		if (verbose >= 4) { pout << "  mass matrix=\n" << massMatrix << "\n"; }

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//explicit Euler: 
		//		dot u = v
		//		dot v = M^(-1)*RHS
		massMatrix.FinalizeMatrix();
		massMatrix.Factorize();
		//massMatrix.Invert(); //fsolve would be faster ...

        //integrate:
		temp.CopyFrom(solutionV);
		temp *= stepSize;

        solutionU += temp;

		//EXUmath::MultMatrixVector(massMatrix, systemRHS, temp);
		massMatrix.Solve(systemRHS, temp);

		solutionA = temp; //in order to export accelerations or use it in elements
		temp *= stepSize;
		solutionV += temp;

		if (verbose >= 3) { 
			pout << "  solutionU=\n" << solutionU << "\n";
			pout << "  solutionV=\n" << solutionV << "\n";
			pout << "  solutionA=\n" << solutionA << "\n";
		}
		discontinuousIterationError = computationalSystem.PostNewtonStep(tempCompData);
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	}
	//t = tEnd;
	//if (writeToFile) { HSolver::WriteCoordinatesToFile(t, t, lastSolutionWritten, solutionSettings, file, computationalSystem); }

	double duration = EXUstd::GetTimeInSeconds() - startTimeCPU;
	if (computationalSystem.GetPostProcessData()->stopSimulation) { pout << "Time integration stopped by user after " << duration << " seconds.\n"; }
	else if (verbose >= 1 || simulationSettings.displayComputationTime) { pout << "Time integration finished after " << duration << " seconds.\n"; }

	if (solutionSettings.writeFileFooter && writeToFile)
	{
		file << "#simulation finished=" << EXUstd::GetDateTimeString() << "\n";
	}

	computationalSystem.GetPostProcessData()->simulationFinished = true; //signal that last step should be rendered
	computationalSystem.GetPostProcessData()->SetVisualizationMessage("Explicit solver finished");

	return true;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool SolverGeneralizedAlpha::SolveSystem(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (simulationSettings.linearSolverType == LinearSolverType::EXUdense)
	{
		Index n = computationalSystem.GetSystemData().GetNumberOfComputationCoordinates();
		if (n > 1000) { PyWarning("The number of total coordinates (unknowns) is larger than 1000. Consider a sparse solver (SimulationSettings().linearSolverType) to reduce memory consumption and computation time."); }

		GeneralMatrixEXUdense matrix; //this defines the used solver and matrix type
		return SolveSystemTemplate(computationalSystem, simulationSettings, matrix);
	}
	else if (simulationSettings.linearSolverType == LinearSolverType::EigenSparse)
	{
		EXUstd::AssignParallelizationParameters(simulationSettings);
		GeneralMatrixEigenSparse matrix; //this defines the used solver and matrix type
		return SolveSystemTemplate(computationalSystem, simulationSettings, matrix);
	}

	PyError("SolverRK1::SolveSystem: Invalid simulationSettings.linearSolverType");

	return false; //no success/error

}

template<class TGeneralMatrix>
bool SolverGeneralizedAlpha::SolveSystemTemplate(CSystem& computationalSystem, const SimulationSettings& simulationSettings, TGeneralMatrix& systemJacobian)
{
	if (!computationalSystem.IsSystemConsistent()) { SysError("SolverGeneralizedAlpha: system is inconsistent and cannot be solved (call Assemble() and check error messages)"); return false; }

	computationalSystem.GetPostProcessData()->stopSimulation = false;
	computationalSystem.GetPostProcessData()->SetVisualizationMessage("Generalized-Alpha solver started");
	computationalSystem.GetSolverData().Reset(); //e.g. set load factor to 1

	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration;
	const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;
	const NewtonSettings& newton = timeint.newton;
	const NumericalDifferentiationSettings& numDiff = newton.numericalDifferentiation;
	Index verbose = timeint.verboseMode;
	Real newmarkBeta = timeint.generalizedAlpha.newmarkBeta; //0.25 ... trapezoidal rule
	Real newmarkGamma = timeint.generalizedAlpha.newmarkGamma; //0.5  ... trapezoidal rule
	Real alphaM;
	Real alphaF;
	Real spectralRadius;
	Real factJacAlgorithmic = 1.; //factor for jacobian in case of generalized-alpha due to algorithmic accelerations

	if (!timeint.generalizedAlpha.useNewmark) //use generalized-alpha
	{
		spectralRadius = timeint.generalizedAlpha.spectralRadius;
		alphaM = (2 * spectralRadius - 1) / (spectralRadius + 1);
		alphaF = spectralRadius / (spectralRadius + 1);
		newmarkGamma = 0.5 + alphaF - alphaM;
		newmarkBeta = 0.25*EXUstd::Square(newmarkGamma + 0.5);
		factJacAlgorithmic = (1. - alphaF) / (1. - alphaM);
	}
	
	
	bool useIndex2Constraints = timeint.generalizedAlpha.useIndex2Constraints; //uses time derivative of position level constraints


	if (verbose >= 1) { pout << "EXUDYN V" << EXUstd::exudynVersion << "\n"; }
	if (verbose >= 1) { pout << "Time integration: generalized-alpha\n+++++++++++++++++++++++++++++++++++\n"; }
	if (verbose >= 2) 
	{ 
		if (timeint.generalizedAlpha.useNewmark) { pout << "  NEWMARK: beta=" << newmarkBeta << ", gamma=" << newmarkGamma << "\n"; }
		else { pout << "  Generalized-alpha: " << "spectralRadius=" << spectralRadius << ", alphaM=" << alphaM << ", alphaF=" << alphaF << ", beta=" << newmarkBeta << ", gamma=" << newmarkGamma << ", factJacA=" << factJacAlgorithmic << "\n"; }
	}

	computationalSystem.GetPostProcessData()->simulationFinished = false;
	computationalSystem.GetPostProcessData()->postProcessDataReady = false;
	//do not initialize, because every update is indicated by change of this counter!: computationalSystem.GetPostProcessData()->updateCounter = 1;

	//cache some variables
	Real startTime = timeint.startTime;
	computationalSystem.GetSystemData().GetCData().initialState.time = startTime; //for later access
	Real tEnd = timeint.endTime;
	Index n = timeint.numberOfSteps;

	Real t = 0;
	Real stepSize = (tEnd - startTime) / (Real)n;

	Index nODE2 = computationalSystem.GetSystemData().GetNumberOfCoordinatesODE2();
	Index nODE1 = computationalSystem.GetSystemData().GetNumberOfCoordinatesODE1();
	Index nAE = computationalSystem.GetSystemData().GetNumberOfCoordinatesAE();
	Index nData = computationalSystem.GetSystemData().GetNumberOfCoordinatesData();
	Index nSys = nODE2 + nODE1 + nAE;


	Index startAE = nODE2 + nODE1;
	//if (startODE1 == nSys) { startODE1 = 0; } //startODE1 == nSys would lead to invalid pointer in LinkedDataVector; can only happen, if nODE1==0
	if (startAE == nSys) { startAE = 0; } //startAE == nSys would lead to invalid pointer in LinkedDataVector; can only happen, if nAE==0

	if (nODE1 != 0) { SysError("Static solver cannot solve first order differential equations (ODE1)"); }

	if (!nSys)
	{
		SysError("GeneralizedAlpha: System size = 0");
		return false;
	}

	STDstring fileName = solutionSettings.coordinatesSolutionFileName;
	std::ofstream file;

	bool writeToFile = solutionSettings.writeSolutionToFile;
	if (fileName != "" && writeToFile)
	{
		if (solutionSettings.appendToFile) { file.open(fileName, std::ofstream::app); }
		else { file.open(fileName, std::ofstream::out); }
		if (!file.is_open()) //failed to open file ...  e.g. invalid file name
		{
			writeToFile = false;
			SysError(STDstring("failed to open file '") + fileName + "'");
		}
		else
		{
			file.precision(solutionSettings.outputPrecision);
			bool isStatic = false; //solver type
			HSolver::WriteSolutionFileHeader(computationalSystem, simulationSettings, file, "generalized alpha", isStatic);
		}
	}
	else { writeToFile = false; }

	bool sparse = false;
	if (systemJacobian.GetSystemMatrixType() == LinearSolverType::EigenSparse) { sparse = true; }

	//choose according matrices (improve in future...)
	GeneralMatrixEigenSparse massMatrixSparse;
	GeneralMatrixEXUdense massMatrixDense;
	GeneralMatrix& systemMassMatrix = sparse ? (GeneralMatrix&)massMatrixSparse : (GeneralMatrix&)massMatrixDense;
	systemMassMatrix.SetNumberOfRowsAndColumns(nODE2, nODE2);

	//new:
	systemJacobian.SetNumberOfRowsAndColumns(nSys, nSys);
	//systemJacobian.SetAllZero(); //done lateron!

	//GeneralMatrixEXUdense jacobianAEGM;
	GeneralMatrixEigenSparse jacobianAEmatrixSparse;
	GeneralMatrixEXUdense jacobianAEmatrixDense;
	GeneralMatrix& jacobianAE = sparse ? (GeneralMatrix&)jacobianAEmatrixSparse : (GeneralMatrix&)jacobianAEmatrixDense;
	jacobianAE.SetNumberOfRowsAndColumns(nODE2, nAE);


	ResizableVector systemResidual(nSys);
	LinkedDataVector ode2Residuum(systemResidual, 0, nODE2); //link ODE2 coordinates
	//LinkedDataVector ode1Rhs(systemRHS, startODE1, nODE1); //link ODE1 coordinates
	LinkedDataVector aeResiduum(systemResidual, startAE, nAE); //link ODE1 coordinates

	ResizableVector newtonSolution(nSys);	//temporary vector for Newton
	LinkedDataVector newtonSolutionODE2(newtonSolution, 0, nODE2); //temporary subvector for ODE2 components
	LinkedDataVector newtonSolutionAE(newtonSolution, startAE, nAE); //temporary subvector for ODE2 components

	ResizableVector tempODE2(nODE2);	//temporary vector for ODE2 quantities; use in initial accelerations and during Newton
	//ResizableVector tempSys(nSys,0.);		//temporary vector for residual computation

	ResizableVector tempODE2F0(nODE2);	//temporary vector for ODE2 Jacobian
	ResizableVector tempODE2F1(nODE2);	//temporary vector for ODE2 Jacobian

	//ResizableVector tempAE_F0(nODE2);	//temporary vector for AE Jacobian (derivative with respect to ODE2!!!)
	//ResizableVector tempAE_F1(nODE2);	//temporary vector for AE Jacobian (derivative with respect to ODE2!!!)

	TemporaryComputationData tempCompData;

	//current values = initial values
	computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords = computationalSystem.GetSystemData().GetCData().initialState.ODE2Coords;
	computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t = computationalSystem.GetSystemData().GetCData().initialState.ODE2Coords_t;
	computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords = computationalSystem.GetSystemData().GetCData().initialState.ODE1Coords;
	computationalSystem.GetSystemData().GetCData().currentState.AECoords = computationalSystem.GetSystemData().GetCData().initialState.AECoords;

	//temp. structure to store start of discontinous iteration state:
	CSystemState startOfDiscIteration; 
	ResizableVector startOfDiscIterationAAlgorithmic(nODE2);

	//link current system vectors for ODE2
	Vector& solutionODE2 = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	Vector& solutionODE2_t = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
	Vector& solutionODE2_tt = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
	Vector& solutionAE = computationalSystem.GetSystemData().GetCData().currentState.AECoords;
	ResizableVector aAlgorithmic(nODE2);

	solutionODE2_tt.SetNumberOfItems(nODE2);
	ResizableVector u0;	//displacements at start of time step
	ResizableVector v0;	//velocities at start of time step
	ResizableVector a0(nODE2);		//accelerations at start of time step
	ResizableVector aAlgorithmic0(nODE2); //algorithmic accelerations for gen-alpha at start of time step
	ResizableVector lambda0(nAE, 0.);	//Lagrange multipliers at start of time step
	//bool isFirstStep = true; //flag to signal, that this is the first step

	//constant step size explicit Euler solver
	double lastSolutionWritten = startTime;
	double startTimeCPU = EXUstd::GetTimeInSeconds();
	double lastTimePrinted = startTimeCPU;

	SolverTimer timer; //used to analyze the time spent in certain functions
	timer.Reset();
	timer.total = -EXUstd::GetTimeInSeconds();

	//+++++++++++++++++++++++++++++++++++++++++
	//compute initial values for accelerations:
	//to be fully consistent the initial accelerations must be computed with Lagrange multipliers
	systemMassMatrix.SetAllZero();
	computationalSystem.ComputeMassMatrix(tempCompData, systemMassMatrix);
	computationalSystem.ComputeODE2RHS(tempCompData, tempODE2);
	systemMassMatrix.FinalizeMatrix(); //for sparse matrix
	if (systemMassMatrix.Factorize() != 0)
	{
		PyWarning("SolverGeneralizedAlpha::SolveSystem: Mass Matrix not invertible!\nWARNING: using zero initial accelerations\n");
		if (verbose >= 3) { pout << "mass matrix =\n" << systemMassMatrix << "\n"; }
		a0.SetAll(0.);
	}
	else
	{
		//EXUmath::MultMatrixVector(systemMassMatrix, tempODE2, a0);
		systemMassMatrix.Solve(tempODE2, a0);
	}

	//these vectors are used in time stepping from previous step
	solutionODE2_tt = a0;
	if (nAE) { solutionODE2_tt.SetAll(0.); } //otherwise very inconsistent initial conditions!
	solutionAE.SetAll(0.); //! @todo: compute correct initial conditions for Newmark method
	aAlgorithmic.CopyFrom(solutionODE2_tt);

	if (verbose >= 3) { pout << "initial accelerations = " << a0 << "\n"; }

	if (verbose >= 2) { pout << "start time integration loop\n"; }

	bool errorOccurred = false; //signals that Newton method failed and that integration method is aborted
	bool converged = true;		//convergence of Newton
	bool solutionDiverged = false; //shows that solution diverged (e.g. in first step)
	Index newtonIterationsCount = 0; //count total number of Newton iterations
	Index newtonJacobiCount = 0; //count total number of Jacobian computations and factorizations
	Index modifiedNewtonFailCount = 0;   //count number of rejections of modifiedNewtonMethod
	bool jacobianUpdateRequested = true; //flag, which signals that a jacobian update is requested (determined in previous step)
	Real discontinuousIterationError;	//error of discontinuous iterations (contact, friction, ...) outside of Newton iteration
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//TIME INTEGRATION LOOP

	Index i = 0;
	while (!errorOccurred && i <= n && !computationalSystem.GetPostProcessData()->stopSimulation)
	{
		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//changed time of time step on 13.12.2019:
		//in the first and last step, data shall be written and visualized
		t = i * stepSize + startTime; //only for writing the initial conditions
		computationalSystem.GetSystemData().GetCData().currentState.time = t; //update time in state --> also available in Python for user-defined functions
		//if (verbose >= 2) { pout << "START STEP " << i << ", t = " << t << "\n"; }
		if (writeToFile)
		{
			timer.writeSolution -= EXUstd::GetTimeInSeconds();
			HSolver::WriteCoordinatesToFile(lastSolutionWritten, solutionSettings, file, computationalSystem);
			timer.writeSolution += EXUstd::GetTimeInSeconds();
		}

		timer.visualization -= EXUstd::GetTimeInSeconds();
		computationalSystem.UpdatePostProcessData();
		timer.visualization += EXUstd::GetTimeInSeconds();
		if (i == n) { break; } //just write solution in last iteration!

		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//changed time of time step on 13.12.2019:
		//start with real computational time t
		t = (i + 1) * stepSize + startTime;
		computationalSystem.GetSystemData().GetCData().currentState.time = t; //update time in state --> also available in Python for user-defined functions

		//python function shall be already executed with correct time at end of step
		timer.python -= EXUstd::GetTimeInSeconds();
		if (timeint.preStepPyExecute.size()) //if this string is not empty, execute the commands
		{
			//py::exec(timeint.preStepPyExecute.c_str()); //will only work, if all variables of the preStepPyExecute string are defined in the global scope

			py::object scope = py::module::import("__main__").attr("__dict__"); //use this to enable access to mbs and other variables of global scope within test models suite
			py::exec(timeint.preStepPyExecute.c_str(), scope);


		}
		timer.python += EXUstd::GetTimeInSeconds();


		if (((verbose == 1) && ((EXUstd::GetTimeInSeconds() - lastTimePrinted >= 2) || i == n)) || (verbose >= 2))
		{
			timer.overhead -= EXUstd::GetTimeInSeconds();
			lastTimePrinted += 2;
			double timeToGo = (EXUstd::GetTimeInSeconds() - startTimeCPU);
			if (timeToGo > 1 && i != 0)
			{
				timeToGo = (double)(n-i) * timeToGo / (double)i;
			}
			else { timeToGo = 0; }
			if (verbose >= 3) { pout << "+++++++++++++++++++++++++++++++++++++++++\n"; }
			pout << "STEP" << i << ", t = " << t << " sec, timeToGo = " << timeToGo << " sec\n";
			timer.overhead += EXUstd::GetTimeInSeconds();
		}


		if (simulationSettings.pauseAfterEachStep) { computationalSystem.GetPostProcessData()->WaitForUserToContinue(); }

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//Post Newton iteration for one time step
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		startOfDiscIteration = computationalSystem.GetSystemData().GetCData().currentState;
		startOfDiscIterationAAlgorithmic = aAlgorithmic; //changed on 13.12.2019

		Index discontinuousIteration = 0;
		discontinuousIterationError = newton.discontinuousIterationTolerance*1.1;
		while (discontinuousIteration < newton.maxDiscontinuousIterations && discontinuousIterationError > newton.discontinuousIterationTolerance)
		{
			if (verbose >= 2) { pout << "  START discontinuous iteration " << discontinuousIteration << ":\n"; }

			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//NEWTON method for one time step
			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			errorOccurred = false;
			Real absError = -1; //current error
			converged = false;
			Real initialResiduum;

			timer.overhead -= EXUstd::GetTimeInSeconds();
			//copy ODE, ODE_T, ODE_tt and AE solution from last step or initial conditions; if modified Newton diverges ==> falls back to a0, u0, ...
			u0.CopyFrom(solutionODE2);
			v0.CopyFrom(solutionODE2_t);
			a0.CopyFrom(solutionODE2_tt);
			aAlgorithmic0.CopyFrom(aAlgorithmic); //for generalized-alpha
			lambda0.CopyFrom(solutionAE);

			solutionODE2_tt.SetAll(0.); //use zero accelerations as guess for this step
			solutionAE.SetAll(0.);		//use zero Lagrange multipliers as guess for this step ==> does not work for algebraic variables such as in sliding joint
			timer.overhead += EXUstd::GetTimeInSeconds();


			//compute residual:
			//compute mass matrix (first step: systemMassMatrix contains inverse of systemMassMatrix!!!)
			timer.massMatrix -= EXUstd::GetTimeInSeconds();
			systemMassMatrix.SetAllZero();
			computationalSystem.ComputeMassMatrix(tempCompData, systemMassMatrix);
			timer.massMatrix += EXUstd::GetTimeInSeconds();

			timer.ODE2RHS -= EXUstd::GetTimeInSeconds();
			computationalSystem.ComputeODE2RHS(tempCompData, tempODE2); //temp contains RHS (linear case: temp = F_applied - K*u - D*v)
			timer.ODE2RHS += EXUstd::GetTimeInSeconds();

			timer.AERHS -= EXUstd::GetTimeInSeconds();
			computationalSystem.ComputeAlgebraicEquations(tempCompData, aeResiduum, useIndex2Constraints); //temp contains RHS (linear case: temp = F_applied - K*u - D*v)
			timer.AERHS += EXUstd::GetTimeInSeconds();

			//EXUmath::MultMatrixVector(systemMassMatrix, solutionODE2_tt, ode2Residuum);
			//systemMassMatrix.FinalizeMatrix();
			systemMassMatrix.MultMatrix(solutionODE2_tt, ode2Residuum);
			ode2Residuum -= tempODE2; //systemResidual contains residual (linear: residual = M*a + K*u+D*v-F
			//CqT*lambda not included, because lambda0 = 0


			//if (verbose >= 3) { pout << "  systemResidual=" << systemResidual << "\n"; } //printed lateron
			if (verbose >= 4) { pout << "  mass matrix=\n" << systemMassMatrix << "\n"; }

			initialResiduum = systemResidual.GetL2Norm(); //systemResidual is linked to ode2Residuum and aeResiduum
			if (verbose >= 2) { pout << "Newton: initial residual = " << initialResiduum << "\n"; }

			if (initialResiduum <= newton.absoluteTolerance)
			{
				//converged = true;
				//if (verbose >= 2) { pout << "Newton: initial residual <= absolute tolerance = " << newton.absoluteToleranceNewton << "\n"; }
				//if initial residual is zero, use the absolute tolerance for initial residual
				initialResiduum = 100.*newton.absoluteTolerance; //Make at least one Newton step! factor 100 is for safety, if residual increases dramatically after one step; shall be reduced after 1 step
			}


			Index newtonSteps = 0; //current number of steps
			Real residual = initialResiduum;  //current residual
			Real lastResidual = initialResiduum; //to determine contractivity
			Real contractivity = 0;			  //contractivity = geometric decay of error in every step
			bool modifiedNewtonRestarted = false; //flag, which signals that modified Newton method has already been restarted
			bool fullNewtonRequested = !newton.useModifiedNewton; //in every step, the modified Newton method can switch to full Newton's method

			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//Newton iterations
			while (!errorOccurred && !converged && newtonSteps < newton.maxIterations)
			{
				newtonSteps++; //every jacobian computation in full Newton corresponds to one step
				if (verbose >= 2) { pout << "  Newton: STEP " << newtonSteps << ":\n"; }
				newtonIterationsCount++;

				//check if jacobian UPDATE needed:
				if (jacobianUpdateRequested || fullNewtonRequested || computationalSystem.GetSolverData().signalJacobianUpdate)
				{
					timer.totalJacobian -= EXUstd::GetTimeInSeconds();
					systemJacobian.SetAllZero(); //entries are not set to zero inside jacobian computation!
					//+++++++++++++++++++++++++++++
					//Tangent stiffness
					//compute jacobian (w.r.t. U ==> also add V); jacobianAE used as temporary matrix
					timer.jacobianODE2 -= EXUstd::GetTimeInSeconds();
					jacobianAE.SetNumberOfRowsAndColumns(nODE2, nODE2);
					jacobianAE.SetAllZero(); //entries are not set to zero inside jacobian computation!
					computationalSystem.NumericalJacobianODE2RHS(tempCompData, numDiff, tempODE2F0, tempODE2F1, jacobianAE); //fills in part of jacobian
					jacobianAE.MultiplyWithFactor(-EXUstd::Square(stepSize) * newmarkBeta * factJacAlgorithmic); //only ODE2 part; displacements (including those in contraints?) related to unknown accelerations by h^2*beta
					//jacobianAE *= -EXUstd::Square(stepSize) * newmarkBeta * factJacAlgorithmic; //only ODE2 part; displacements (including those in contraints?) related to unknown accelerations by h^2*beta
					systemJacobian.AddSubmatrix(jacobianAE, 0, 0);
					timer.jacobianODE2 += EXUstd::GetTimeInSeconds();

					//+++++++++++++++++++++++++++++
					//'Damping' and gyroscopic terms; jacobianAE used as temporary matrix
					timer.jacobianODE2_t -= EXUstd::GetTimeInSeconds();
					jacobianAE.SetAllZero(); //entries are not set to zero inside jacobian computation!
					computationalSystem.NumericalJacobianODE2RHS_t(tempCompData, numDiff, tempODE2F0, tempODE2F1, jacobianAE); //d(ODE2)/dq_t for damping terms
					jacobianAE.MultiplyWithFactor(-stepSize * newmarkGamma * factJacAlgorithmic);
					//jacobianAE *= -stepSize * newmarkGamma * factJacAlgorithmic;
					systemJacobian.AddSubmatrix(jacobianAE, 0, 0);
					timer.jacobianODE2_t += EXUstd::GetTimeInSeconds();

					//+++++++++++++++++++++++++++++
					//Jacobian of algebraic euqations
					//Real factorAE = EXUstd::Square(stepSize) * newmarkBeta; //Index3
					Real factorAE_ODE2 = 1;		//for position level constraints: depends, if index reduction is used
					Real factorAE_ODE2_t = stepSize * newmarkGamma * factJacAlgorithmic;  //for velocity constraints ==> same for index 2 and index 3

					if (!useIndex2Constraints) { factorAE_ODE2 = EXUstd::Square(stepSize) * newmarkBeta * factJacAlgorithmic; } //Index3:
					else { factorAE_ODE2 = stepSize * newmarkGamma * factJacAlgorithmic; } //Index2

					timer.jacobianAE -= EXUstd::GetTimeInSeconds();
					//add jacobian algebraic equations part to system jacobian:
					computationalSystem.JacobianAE(tempCompData, newton, systemJacobian, factorAE_ODE2, factorAE_ODE2_t, false, true);

					systemJacobian.AddSubmatrix(systemMassMatrix); //systemMassMatrix used from initial step or from previous step; not scaled, because this is linear in unknown accelerations
					timer.jacobianAE += EXUstd::GetTimeInSeconds();
					computationalSystem.GetSolverData().signalJacobianUpdate = false; //as jacobian has been computed, no further update is necessary

					if (verbose >= 3) { pout << "    update Jacobian: Jac    = " << systemJacobian << "\n"; }
					else if (verbose >= 2) { pout << "    update Jacobian\n"; }

					timer.factorization -= EXUstd::GetTimeInSeconds();
					systemJacobian.FinalizeMatrix();
					if (systemJacobian.Factorize() != 0)
					{
						SysError("SolverGeneralizedAlpha::SolveSystem: System Jacobian not invertible!");
						errorOccurred = true;
					}
					timer.factorization += EXUstd::GetTimeInSeconds();

					newtonJacobiCount++;
					jacobianUpdateRequested = false;
					timer.totalJacobian += EXUstd::GetTimeInSeconds();
				}

				//perform step
				if (!errorOccurred)
				{
					if (verbose >= 4) { pout << "    JacInv = " << systemJacobian << "\n"; }
					if (verbose >= 4) { pout << "systemResidual = " << systemResidual << "\n"; }

					//aeResiduum *= 1. / EXUstd::Square(stepSize) * newmarkBeta;
					//now compute descent of acceleration vector with jacobian
					timer.integrationFormula -= EXUstd::GetTimeInSeconds();
					//EXUmath::MultMatrixVector(systemJacobian, systemResidual, newtonSolution);
					//systemJacobian.MultMatrix(systemResidual, newtonSolution);
					systemJacobian.Solve(systemResidual, newtonSolution);

					solutionODE2_tt -= newtonSolutionODE2;  //compute new accelerations; newtonSolution contains the Newton correction
					solutionAE -= newtonSolutionAE;			//compute new Lagrange multipliers; newtonSolution contains the Newton correction

					if (verbose >= 4) { pout << "newtonIncrement = " << newtonSolution << "\n"; }


					aAlgorithmic.CopyFrom(solutionODE2_tt);

					if (!timeint.generalizedAlpha.useNewmark)
					{//compute algorithmic accelerations aAlgorithmic for generalized alpha method (otherwise aAlgorithmic == solutionODE2_tt)
						//aAlgorithmic = 1./(1.-alphaM)*((1.-alphaF)*solutionODE_tt + alphaF*a0 - alphaM*aAlgorithmic0);
						//Real factODEtt = (1. - alphaF) / (1. - alphaM);
						//Real factA0 = alphaF / (1. - alphaM);
						//Real factaAlgorithmic0 = -alphaM / (1. - alphaM);
						aAlgorithmic *= factJacAlgorithmic;

						tempODE2 = a0;
						tempODE2 *= alphaF / (1. - alphaM);
						aAlgorithmic += tempODE2;

						tempODE2 = aAlgorithmic0;
						tempODE2 *= -alphaM / (1. - alphaM);
						aAlgorithmic += tempODE2;
						//pout << "ODE2_tt      =" << solutionODE2_tt << "\n";
						//pout << "aAlgorithmic =" << aAlgorithmic << "\n";
						//pout << "aAlgorithmic0=" << aAlgorithmic0 << "\n";
						//pout << "a0           =" << a0 << "\n";
					}

					Real fact1 = EXUstd::Square(stepSize)*0.5*(1. - 2.*newmarkBeta);
					Real fact2 = EXUstd::Square(stepSize)*newmarkBeta;
					Real fact3 = stepSize * (1. - newmarkGamma);
					Real fact4 = stepSize * newmarkGamma;
					//now use Newmark formulas to update solutionODE2 and solutionODE2_t
					//uT = u0 + h*v0 + h^2/2*(1-2*beta)*a0 + h^2*beta*aT
					solutionODE2 = u0;
					tempODE2 = v0;
					tempODE2 *= stepSize;
					solutionODE2 += tempODE2;

					tempODE2 = a0;
					tempODE2 *= fact1;
					solutionODE2 += tempODE2;

					tempODE2.CopyFrom(aAlgorithmic);
					tempODE2 *= fact2;
					solutionODE2 += tempODE2;

					//vT = v0 + h*(1-gamma)*a0 + h*gamma*aT
					solutionODE2_t = v0;
					tempODE2 = a0;
					tempODE2 *= fact3;
					solutionODE2_t += tempODE2;

					tempODE2.CopyFrom(aAlgorithmic);
					tempODE2 *= fact4;
					solutionODE2_t += tempODE2;
					timer.integrationFormula += EXUstd::GetTimeInSeconds();

					//now compute the new residual with updated system vectors:
					timer.massMatrix -= EXUstd::GetTimeInSeconds();
					systemMassMatrix.SetAllZero();
					computationalSystem.ComputeMassMatrix(tempCompData, systemMassMatrix);
					timer.massMatrix += EXUstd::GetTimeInSeconds();

					timer.ODE2RHS -= EXUstd::GetTimeInSeconds();
					computationalSystem.ComputeODE2RHS(tempCompData, tempODE2); //tempODE2 contains RHS (linear case: tempODE2 = F_applied - K*u - D*v)
					timer.ODE2RHS += EXUstd::GetTimeInSeconds();
					timer.AERHS -= EXUstd::GetTimeInSeconds();
					computationalSystem.ComputeAlgebraicEquations(tempCompData, aeResiduum, useIndex2Constraints);
					timer.AERHS += EXUstd::GetTimeInSeconds();

					//systemMassMatrix.FinalizeMatrix(); //MultMatrix is faster? if directly applied to triplets ...
					systemMassMatrix.MultMatrix(solutionODE2_tt, ode2Residuum);
					//EXUmath::MultMatrixVector(systemMassMatrix, solutionODE2_tt, ode2Residuum);
					ode2Residuum -= tempODE2; //systemResidual contains residual (linear: residual = M*a + K*u+D*v-F

					//compute CqT*lambda:
					timer.reactionForces -= EXUstd::GetTimeInSeconds();
					computationalSystem.ComputeODE2ProjectedReactionForces(tempCompData, solutionAE, ode2Residuum); //add the forces directly!
					timer.reactionForces += EXUstd::GetTimeInSeconds();

					residual = systemResidual.GetL2Norm();

					if (verbose == 2)
					{
						pout << "    STEP " << newtonSteps << ": residual = " << residual << "\n";
					}
					if (verbose >= 3)
					{
						pout << "    solU         = " << solutionODE2 << "\n";
						pout << "    solV         = " << solutionODE2_t << "\n";
						pout << "    solA         = " << solutionODE2_tt << "\n";
						pout << "    solLambda    = " << solutionAE << "\n";
						pout << "    new residual = " << systemResidual << "\n";
					}

					if (residual / initialResiduum <= newton.relativeTolerance)
					{
						converged = true;
					}
					else if (residual <= newton.absoluteTolerance)
					{
						converged = true;
						if (verbose >= 2) { pout << "  convergence reached with absolute error = " << residual << "\n"; }
					}

					if (!converged)
					{
						Real normU = solutionODE2.GetL2NormSquared();
						Real normV = solutionODE2_t.GetL2NormSquared();
						Real normLambda = solutionAE.GetL2NormSquared();

						solutionDiverged = false;
						//check, if solution has diverged
						if (normU >= newton.maximumSolutionNorm || normV >= newton.maximumSolutionNorm ||
							std::isnan(normU) || std::isnan(normV) || std::isnan(normLambda))
						{
							if (fullNewtonRequested)
							{
								errorOccurred = true;
								if (verbose >= 1) { pout << "  solution diverged with full Newton\n"; }
								if (verbose >= 4) 
								{ 
									pout << "  Reasons for Newton divergence(maximum value=" << sqrt(newton.maximumSolutionNorm) << "): \n";
									pout << "    normU = " << sqrt(normU) << "\n";
									pout << "    normV = " << sqrt(normV) << "\n";
									pout << "    normLambda = " << sqrt(normLambda) << "\n";
								}

							}
							else
							{
								solutionDiverged = true;
								if (verbose >= 2) { pout << "  full Newton requested because of diverged solution\n"; }
							}
						}

						//bool maxModifiedNewtonStepsReached = false;
						if (!fullNewtonRequested && (newtonSteps > newton.maxModifiedNewtonIterations))
						{
							jacobianUpdateRequested = true; //make a simple Jacobian update and continue Newton iterations
						}

						bool switchToFullNewton = false;
						if (!fullNewtonRequested && (newtonSteps > newton.maxModifiedNewtonIterations + newton.maxModifiedNewtonRestartIterations))
						{
							fullNewtonRequested = true;
							modifiedNewtonFailCount++;
							switchToFullNewton = true;
						}

						//decide on modified Newton based on contractivity
						contractivity = residual / lastResidual; //last residual must always be greater than 0!!!
						if (verbose >= 2) { pout << "  contractivity = " << contractivity << "\n"; }
						if (verbose >= 2) { pout << "  last residual = " << lastResidual << "\n"; }

						lastResidual = residual;
						//in case of modified newton try with jacobian update and full newton ...
						if (newton.useModifiedNewton && (solutionDiverged || (contractivity > newton.modifiedNewtonContractivity && newtonSteps > 2))) //only check this at third step
						{
							jacobianUpdateRequested = true; //make a simple Jacobian update and continue Newton iterations

							//full newton does not consider contractivity
							//if (fullNewtonRequested && !switchToFullNewton) //if already using full Newton, bad contractivity means that a further restart will not help
							//{
							//	errorOccurred = true;
							//	if (verbose >= 1) { pout << "  Newton failed due to bad contractivity in full Newton method\n"; }
							//}
							//else 
							if (modifiedNewtonRestarted) //if modified Newton already restarted ==> use full Newton now!
							{
								fullNewtonRequested = true;
								modifiedNewtonFailCount++;
								if (verbose >= 2) { pout << "  switch to full Newton due to repeated bad contractivity\n"; }
							}

							if (!errorOccurred && (solutionDiverged || contractivity > 2 || fullNewtonRequested))  //this might indicate divergence ==> restart Newton if modified newton is used
							{
								modifiedNewtonRestarted = true;
								jacobianUpdateRequested = true;

								//lastResidual = EXUstd::Maximum(lastResidual, initialResiduum)*1.e6; //safety of 1e6 to relieve the contracticity condition of next step

								residual = initialResiduum;  //current residual
								lastResidual = initialResiduum; //to determine contractivity

								//initialize states with beginning of time step
								solutionODE2 = u0;
								solutionODE2_t = v0;
								solutionODE2_tt.SetAll(0.); //use zero accelerations as guess for next step

								//add this for generalized alpha:
								aAlgorithmic = aAlgorithmic0;
								////add this for algebraic variables such as in sliding joint:
								//solutionAE = lambda0;

								//compute residual:
								solutionAE.SetAll(0.);		//use zero Lagrange multipliers as guess for next step ==> will not work for sliding joint algebraic variable							
								timer.massMatrix -= EXUstd::GetTimeInSeconds();
								systemMassMatrix.SetAllZero();
								computationalSystem.ComputeMassMatrix(tempCompData, systemMassMatrix);
								timer.massMatrix += EXUstd::GetTimeInSeconds();
								timer.ODE2RHS -= EXUstd::GetTimeInSeconds();
								computationalSystem.ComputeODE2RHS(tempCompData, tempODE2); //temp contains RHS (linear case: temp = F_applied - K*u - D*v)
								timer.ODE2RHS += EXUstd::GetTimeInSeconds();
								timer.AERHS -= EXUstd::GetTimeInSeconds();
								computationalSystem.ComputeAlgebraicEquations(tempCompData, aeResiduum, useIndex2Constraints); //temp contains RHS (linear case: temp = F_applied - K*u - D*v)
								timer.AERHS += EXUstd::GetTimeInSeconds();
								
								systemMassMatrix.MultMatrix(solutionODE2_tt, ode2Residuum);
								//EXUmath::MultMatrixVector(systemMassMatrix, solutionODE2_tt, ode2Residuum);
								ode2Residuum -= tempODE2; //systemResidual contains residual (linear: residual = M*a + K*u+D*v-F

								if (verbose >= 2 && !solutionDiverged) { pout << "  Newton restarted and jacobian updated due to bad contractivity\n"; }
							}
						} //contractivity check
					}//converged
				} //Jacobian invert
			}//Newton iteration
			double duration = EXUstd::GetTimeInSeconds() - startTimeCPU;

			if (errorOccurred || !converged)
			{
				if (verbose >= 1) { pout << "  Newton (time step: " << i << "): convergence failed after " << newtonSteps << " steps; relative error = " << residual / initialResiduum << "\n"; }
			}
			else
			{
				if (verbose >= 2) { pout << "  Newton: convergenced after " << newtonSteps << " steps; relative error = " << residual / initialResiduum << "\n"; }
			}

			if (verbose >= 3)
			{

				pout << "  Time step " << i << ":\n";
				pout << "    STEP solU      = " << solutionODE2 << "\n";
				pout << "    STEP solV      = " << solutionODE2_t << "\n";
				pout << "    STEP solA      = " << solutionODE2_tt << "\n";
				pout << "    STEP solLambda = " << solutionAE << "\n";
			}

			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			discontinuousIterationError = computationalSystem.PostNewtonStep(tempCompData);
			discontinuousIteration++;

			//14.12.2019: changed from: if (verbose >= 0 && discontinuousIterationError > newton.discontinuousIterationTolerance)
			// ...

			if (discontinuousIterationError > newton.discontinuousIterationTolerance)
			{
				if (verbose >= 2)
				{
					pout << "  discontinuous iteration error = " << discontinuousIterationError 
						<< " (disc.it.=" << discontinuousIteration 
						<< ", error goal = " << newton.discontinuousIterationTolerance << ")";
					if (discontinuousIterationError <= newton.discontinuousIterationTolerance) 
					{ pout << " ... REACHED"; }
					pout << "\n";
				}

				//reset states to start of discontinuous iteration, EXCEPT for data variables!:
				if (discontinuousIteration < newton.maxDiscontinuousIterations)
				{
					solutionODE2 = startOfDiscIteration.ODE2Coords;
					solutionODE2_t = startOfDiscIteration.ODE2Coords_t;
					solutionODE2_tt = startOfDiscIteration.ODE2Coords_tt;
					solutionAE = startOfDiscIteration.AECoords;
					aAlgorithmic = startOfDiscIterationAAlgorithmic; //for generalized-alpha
				}
			}
		} //discontinuous (postNewton) iteration

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		i++; //increment iteration count
	}//time integration loop
	timer.total += EXUstd::GetTimeInSeconds();

	double duration = EXUstd::GetTimeInSeconds() - startTimeCPU;
	if (computationalSystem.GetPostProcessData()->stopSimulation) { pout << "Time integration stopped by user after " << duration << " seconds.\n"; }
	else
	{if (verbose >= 1 || simulationSettings.displayComputationTime) { pout << "Time integration finished after " << duration << " seconds.\n"; }}

	if (simulationSettings.displayStatistics) {timer.Print();}

	if (solutionSettings.writeFileFooter && writeToFile)
	{
		file << "#simulation finished=" << EXUstd::GetDateTimeString() << "\n";
		file << "#Solver Info:";
		file << " errorOccurred=" << errorOccurred;
		file << ",converged=" << converged;
		file << ",solutionDiverged=" << solutionDiverged;
		file << ",total time steps=" << i;
		file << ",total Newton iterations=" << newtonIterationsCount;
		file << ",total Newton jacobians=" << newtonJacobiCount;
		file << "\n";
	}

	computationalSystem.GetPostProcessData()->simulationFinished = true; //signal that last step should be rendered

	if (verbose >= 2 || simulationSettings.displayStatistics)
	{
		pout << "total number of time steps:        " << i << "\n";
		pout << "total number of Newton iterations: " << newtonIterationsCount << "\n";
		pout << "total number of Newton Jacobians:  " << newtonJacobiCount << "\n";
		if (modifiedNewtonFailCount) { pout << "full Newton steps:      " << modifiedNewtonFailCount << "\n"; }
	}

	if (!errorOccurred && !solutionDiverged && converged) { computationalSystem.GetPostProcessData()->SetVisualizationMessage("Generalized-Alpha solver finished successfully"); }
	else { computationalSystem.GetPostProcessData()->SetVisualizationMessage("Generalized-Alpha solver finished with errors"); }

	return true;

}

