/** ***********************************************************************************************
* @brief		Implentation for computational solver CSolverBase
* @details		Details:
* 				- base classes for computational solver (as compared to main solver, which interacts with Python, etc.)
*               - contains basic solver structures (Evaluation functions, jacobians, initialization, link to linear solvers, 
*				  solver statistics and output, solution files, Newton, nonlinear iteration, ...)
*
* @author		Gerstmayr Johannes
* @date			2019-12-11 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: missing
* 				
*
************************************************************************************************ */
#pragma once

#include <pybind11/pybind11.h> //for integrated python connectivity (==>put functionality into separate file ...!!!)
#include <pybind11/eval.h>

#include "Autogenerated/versionCpp.h"
#include "Linalg/BasicLinalg.h" //for Resizable Vector
#include "Main/CSystem.h"
#include "Autogenerated/CMarkerBodyPosition.h"
#include "Solver/CSolverBase.h" 

#include <fstream>

namespace py = pybind11;	//for py::object

//! initialize all data,it,conv; set/compute initial conditions (solver-specific!); initialize output files
bool CSolverBase::InitializeSolver(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//keep the following order!
	InitCSolverBase(); //reset all data, such that multiple calls to SolveSystem give same results

	PreInitializeSolverSpecific(computationalSystem, simulationSettings); //do solver specific things

	InitializeSolverOutput(computationalSystem, simulationSettings); //first needs to open files
	if (InitializeSolverPreChecks(computationalSystem, simulationSettings))
	{
		InitializeSolverData(computationalSystem, simulationSettings);
		InitializeSolverInitialConditions(computationalSystem, simulationSettings);

		PostInitializeSolverSpecific(computationalSystem, simulationSettings); //do solver specific things
		return true;
	}
	return false;
}

//! initialize output files; called from InitializeSolver(); must be done at the very beginning, as otherwise, no information is written!
void CSolverBase::InitializeSolverOutput(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration;
	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;
	const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;
	
	if (IsStaticSolver())
	{
		output.verboseMode = staticSolver.verboseMode;
		output.verboseModeFile = staticSolver.verboseModeFile; //verbose mode of file
		newton = staticSolver.newton;
	} else
	{
		output.verboseMode = timeint.verboseMode;
		output.verboseModeFile = timeint.verboseModeFile; //verbose mode of file
		newton = timeint.newton;
	}

	//timer.Reset(simulationSettings.displayComputationTime); //done in SolveSteps

	STDstring solutionFileName = solutionSettings.coordinatesSolutionFileName;
	STDstring solverFileName = solutionSettings.solverInformationFileName;

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//open solution file
	output.writeToSolutionFile = solutionSettings.writeSolutionToFile;
	if (solutionFileName != "" && output.writeToSolutionFile)
	{
		if (solutionSettings.appendToFile) { file.solutionFile.open(solutionFileName, std::ofstream::app); }
		else { file.solutionFile.open(solutionFileName, std::ofstream::out); }
		if (!file.solutionFile.is_open()) //failed to open file ...  e.g. invalid file name
		{
			output.writeToSolutionFile = false;
			SysError(STDstring("failed to open solution file '") + solutionFileName + "'", file.solverFile);
		}
		else
		{
			file.solutionFile.precision(solutionSettings.outputPrecision);
		}
	}
	else { output.writeToSolutionFile = false; }

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//open solver information file
	output.writeToSolverFile = false; //default
	if (output.verboseModeFile > 0 && solverFileName != "")
	{
		if (solutionSettings.appendToFile) { file.solverFile.open(solverFileName, std::ofstream::app); }
		else { file.solverFile.open(solverFileName, std::ofstream::out); }
		
		if (!file.solverFile.is_open()) //failed to open file ...  e.g. invalid file name
		{
			SysError(STDstring("failed to open solution file '") + solverFileName + "'", file.solverFile);
		}
		else
		{
			output.writeToSolverFile = true;
			file.solverFile.precision(solutionSettings.outputPrecision);
		}
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//open sensor files
	//for every sensor there is an according enty in sensorFileList (may be Null pointer)
	//files need to be closed at any exit point!!!
	for (auto item : computationalSystem.GetSystemData().GetCSensors())
	{
		Index cnt = 0;
		if (item->GetWriteToFileFlag() && item->GetFileName().length() != 0)
		{
			std::ofstream* sensorFile = new std::ofstream;
			file.sensorFileList.push_back(sensorFile);
			int fileMode = std::ofstream::out;
			if (solutionSettings.appendToFile) { fileMode = std::ofstream::app; }

			sensorFile->open(item->GetFileName(), fileMode);

			if (!sensorFile->is_open()) //failed to open file ...  e.g. invalid file name
			{
				SysError(STDstring("failed to open sensor file '") + item->GetFileName() + "' (sensor number " + EXUstd::ToString(cnt) + ")", file.solverFile);
				file.sensorFileList.back() = nullptr; //mark this ofstream as unwriteable
			}
			else
			{
				sensorFile->precision(solutionSettings.outputPrecision);
			}
			cnt++;
		}
		else
		{
			file.sensorFileList.push_back(nullptr);
		}
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	if (IsVerboseCheck(1))
	{
		VerboseWrite(1, STDstring("+++++++++++++++++++++++++++++++\nEXUDYN V") + EXUstd::ToString(EXUstd::exudynVersion) + " solver: " + GetSolverName() + "\n");
	}

}


//! initialize dense/sparse computation modes
bool CSolverBase::InitializeSolverPreChecks(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	computationalSystem.GetPostProcessData()->SetVisualizationMessage(STDstring(GetSolverName()) + " started");

	//some pre-checks for solver
	if (!computationalSystem.IsSystemConsistent()) { PyError("SolverGeneralizedAlpha: system is inconsistent and cannot be solved (call Assemble() and check error messages, file.solverFile)"); return false; }

	computationalSystem.GetSystemData().GetNumberOfComputationCoordinates(data.nODE2, data.nODE1, data.nAE, data.nData);
	data.nSys = data.nODE2 + data.nODE1 + data.nAE;
	data.startAE = data.nODE2 + data.nODE1;
	if (data.startAE == data.nODE2 + data.nODE1 + data.nAE) { data.startAE = 0; } //data.startAE == data.nSys would lead to invalid pointer in LinkedDataVector; can only happen, if data.nAE==0

	if (data.nODE1 != 0) { SysError("Solver cannot solve first order differential equations (ODE1) for now", file.solverFile); }

	if (data.nSys == 0)
	{
		SysError("Solver cannot solve for system size = 0", file.solverFile);
		return false;
	}
	if (data.nODE1 != 0) { SysError("Solver cannot solve first order differential equations (ODE1) for now", file.solverFile); }


	if (simulationSettings.linearSolverType == LinearSolverType::EXUdense)
	{
		Index n = computationalSystem.GetSystemData().GetNumberOfComputationCoordinates();
		if (n > 1000) 
		{ 
			PyWarning("The number of total coordinates (unknowns) is larger than 1000. Consider a sparse solver (SimulationSettings().linearSolverType) to reduce memory consumption and computation time.", file.solverFile);
		}
	}
	else if (simulationSettings.linearSolverType == LinearSolverType::EigenSparse)
	{
		EXUstd::AssignParallelizationParameters(simulationSettings);
	}
	else
	{
		PyError("CSolverBase::InitializeSolverPreChecks: Unsupported simulationSettings.linearSolverType", file.solverFile);
		data.SetLinearSolverType(LinearSolverType::None);
		return false;
	}

	//done now in InitializeSolverInitialConditions(...)
	//if (IsStaticSolver() && (simulationSettings.staticSolver.adaptiveStep && simulationSettings.staticSolver.loadStepGeometric))
	//{
	//	PyWarning("CSolverBase::InitializeSolverPreChecks: staticSolver.adaptiveStep is not possible for staticSolver.loadStepGeometric; adaptiveStep will be ignored", file.solverFile);
	//}

	computationalSystem.GetPostProcessData()->stopSimulation = false;
	computationalSystem.GetSolverData().Reset(); //e.g. set load factor to 1
	computationalSystem.GetPostProcessData()->simulationFinished = false;
	computationalSystem.GetPostProcessData()->postProcessDataReady = false;

	//do this not earlier than here, because checks need to be done prior to writing the header
	WriteSolutionFileHeader(computationalSystem, simulationSettings);
	WriteSensorsFileHeader(computationalSystem, simulationSettings);
	return true;
}


//! initialize all data,it,conv; called from InitializeSolver()
void CSolverBase::InitializeSolverData(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	conv.InitializeData();

	if (simulationSettings.linearSolverType == LinearSolverType::EXUdense)
	{
		data.SetLinearSolverType(LinearSolverType::EXUdense);
	}
	else
	{
		data.SetLinearSolverType(LinearSolverType::EigenSparse);
	}
	
	data.systemMassMatrix->SetNumberOfRowsAndColumns(data.nODE2, data.nODE2);
	data.systemJacobian->SetNumberOfRowsAndColumns(data.nSys, data.nSys);
	data.jacobianAE->SetNumberOfRowsAndColumns(data.nODE2, data.nAE);


	data.systemResidual.SetNumberOfItems(data.nSys);
	data.newtonSolution.SetNumberOfItems(data.nSys);	//temporary vector for Newton
	data.tempODE2.SetNumberOfItems(data.nODE2);			//temporary vector for ODE2 quantities; use in initial accelerations and during Newton
	data.tempODE2F0.SetNumberOfItems(data.nODE2);		//temporary vector for ODE2 Jacobian
	data.tempODE2F1.SetNumberOfItems(data.nODE2);		//temporary vector for ODE2 Jacobian

	data.tempCompData = TemporaryComputationData();		//totally reset; for safety for now!

	//temp. structure to store start of discontinous iteration state:
	//  done in CleanUpMemory(): data.startOfDiscIteration.Reset();
	data.startOfStepStateAAlgorithmic.SetNumberOfItems(data.nODE2);

	//data.u_tt0.SetNumberOfItems(data.nODE2);			//accelerations at start of time step
	//data.aAlgorithmic0.SetNumberOfItems(data.nODE2);	//algorithmic accelerations for gen-alpha at start of time step
	//data.lambda0.SetNumberOfItems(data.nAE);			//Lagrange multipliers at start of time step
	//data.lambda0.SetAll(0.);				

	it.newtonStepsCount = 0;				//count total number of Newton iterations
	it.newtonJacobiCount = 0;				//count total number of Jacobian computations and factorizations
	it.rejectedModifiedNewtonSteps = 0;		//count number of rejections of modifiedNewtonMethod
	it.discontinuousIterationsCount = 0;	//count total number of discontinuous iterations

	it.newtonSteps = 0;						//consistently initialize
	it.discontinuousIteration = 0;			//consistently initialize

	if (newton.weightTolerancePerCoordinate && data.nSys) { conv.errorCoordinateFactor = sqrt((Real)data.nSys); }
	else { conv.errorCoordinateFactor = 1.; }

	//it.timeSteps = 0;						//total time steps count (incl. step reduction)
	//it.staticSteps = 0;						//total static steps count (incl. step reduction)

}

//! set/compute initial conditions (solver-specific!); called from InitializeSolver()
void CSolverBase::InitializeSolverInitialConditions(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//cache some variables
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration; //only needed for time integration header
	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;  //only needed for static solver header

	if (!IsStaticSolver())
	{
		it.numberOfSteps = timeint.numberOfSteps;
		if (it.numberOfSteps == 0)
		{
			PyWarning("SolverInitialConditions: TimeIntegration.numberOfSteps == 0: setting number of steps to 1", file.solverFile);
			it.numberOfSteps = 1;
		}

		it.startTime = timeint.startTime;
		it.endTime = timeint.endTime;

		it.minStepSize = timeint.minimumStepSize;
		it.maxStepSize = (it.endTime - it.startTime) / (Real)(it.numberOfSteps);

		it.adaptiveStep = timeint.adaptiveStep;
	}
	else
	{
		it.numberOfSteps = staticSolver.numberOfLoadSteps;

		it.startTime = staticSolver.loadStepStart;
		it.endTime = staticSolver.loadStepStart + staticSolver.loadStepDuration;

		it.minStepSize = staticSolver.minimumStepSize;
		it.maxStepSize = staticSolver.loadStepDuration / (Real)(it.numberOfSteps);

		it.adaptiveStep = staticSolver.adaptiveStep;
		if (staticSolver.loadStepGeometric && staticSolver.adaptiveStep)
		{
			PyWarning("CSolverBase::InitializeSolverPreChecks: staticSolver.adaptiveStep is not possible for staticSolver.loadStepGeometric; adaptiveStep will be ignored", file.solverFile);
			it.adaptiveStep = false;
		}
	}

	//current values = initial values
	computationalSystem.GetSystemData().GetCData().initialState.time = it.startTime; //hereafter copied to currentState
	it.currentTime = it.startTime;
	computationalSystem.GetSystemData().GetCData().currentState = computationalSystem.GetSystemData().GetCData().initialState;

	if (!IsStaticSolver()) //not needed in static solver
	{
		//set according size of vectors, which are not initialized:
		data.aAlgorithmic.SetNumberOfItems(data.nODE2);
		computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt.SetNumberOfItems(data.nODE2);
	}

	//+++++++++++++++++++++++++++++++++++++
	//timer functions: only work in combination with FinalizeSolver
	output.lastSolutionWritten = it.startTime;
	output.lastSensorsWritten = it.startTime;
	output.lastImageRecorded = it.startTime;
	output.cpuStartTime = EXUstd::GetTimeInSeconds();
	output.cpuLastTimePrinted = output.cpuStartTime;

	//+++++++++++++++++++++++++++++++++++++++++


}

//! specific call to the start solver
bool CSolverBase::SolveSystem(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	bool success = true; //local success variable
	success = InitializeSolver(computationalSystem, simulationSettings);

	timer.Reset(simulationSettings.displayComputationTime);
	timer.total = -EXUstd::GetTimeInSeconds();
	if (success)
	{
		success = SolveSteps(computationalSystem, simulationSettings);
	}
	timer.total += EXUstd::GetTimeInSeconds();

	FinalizeSolver(computationalSystem, simulationSettings);
	output.finishedSuccessfully = success;

	return success;
}


//! write concluding information (timer statistics, messages) and close files
//! main solver part: calls multiple InitializeStep(...)/PerformStep(...); do step reduction if necessary; return true if success, false else
void CSolverBase::FinalizeSolver(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (IsVerboseCheck(1))
	{
		if (computationalSystem.GetPostProcessData()->stopSimulation)
		{
			VerboseWrite(1, STDstring("solver stopped by user after ") + EXUstd::ToString(timer.total) + " seconds.\n");
		}
		else
		{
			//if (simulationSettings.displayComputationTime) { VerboseWrite(1, STDstring("solver finished after ") + EXUstd::ToString(timer.total) + " seconds.\n"); }
			VerboseWrite(1, STDstring("solver finished after ") + EXUstd::ToString(timer.total) + " seconds.\n");
		}

		if (simulationSettings.displayComputationTime) //computation statistics
		{
			VerboseWrite(1, timer.ToString());
		}
		if (simulationSettings.displayStatistics)
		{
			VerboseWrite(1, it.ToString());
		}
	}

	if (simulationSettings.solutionSettings.writeFileFooter && output.writeToSolutionFile)
	{
		file.solutionFile << "#simulation finished=" << EXUstd::GetDateTimeString() << "\n";
		file.solutionFile << "#Solver Info:";
		file.solutionFile << " stepReductionFailed(or step failed)=" << conv.stepReductionFailed;
		file.solutionFile << ",discontinuousIterationsFailed=" << conv.discontinuousIterationsFailed;
		file.solutionFile << ",newtonSolutionDiverged=" << conv.newtonSolutionDiverged;
		file.solutionFile << ",massMatrixNotInvertible=" << conv.massMatrixNotInvertible;
		file.solutionFile << ",total time steps=" << it.currentStepIndex-1; //initial step is also counted in it.currentStepIndex
		file.solutionFile << ",total Newton iterations=" << it.newtonStepsCount;
		file.solutionFile << ",total Newton jacobians=" << it.newtonJacobiCount << "\n";
	}

	computationalSystem.GetPostProcessData()->simulationFinished = true; //signal that last step should be rendered

	//clean up memory of large matrices
	if (simulationSettings.cleanUpMemory) { data.CleanUpMemory(); }

	if (!conv.stepReductionFailed)
	{
		computationalSystem.GetPostProcessData()->SetVisualizationMessage("Solver finished successfully");
	}
	else { computationalSystem.GetPostProcessData()->SetVisualizationMessage("Solver finished with errors"); }

	//++++++++++++++++++++++++++++++++++
	//final finalize: close files (NO EARLIER!)
	if (file.solutionFile.is_open()) { file.solutionFile.close(); }
	if (file.solverFile.is_open()) { file.solverFile.close(); }

	//close sensor files:
	for (auto* item : file.sensorFileList)
	{
		if (item != nullptr)
		{
			item->close();
			delete item;
			item = nullptr;
		}
	}
	file.sensorFileList.clear();
	//pout << "sensor list length=" << file.sensorFileList.size() << "\n";
}

//! main solver part: calls multiple InitializeStep(...)/PerformStep(...); do step reduction if necessary; return true if success, false else
bool CSolverBase::SolveSteps(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (IsVerbose(2)) { Verbose(2, "\nStart steps solving loop\n"); }

	it.currentStepSize = it.maxStepSize; //initial value for step size
	it.currentStepIndex = 0;
	conv.stepReductionFailed = false;
	conv.jacobianUpdateRequested = true;	//for modified Newton, only request Newton at first step

	Index stepsSinceLastStepSizeReduction = 0;

	if (IsVerbose(2)) { Verbose(2, "\nWrite initial step to solution file and visualize ...\n"); }
	//perform initialization for initial values (write to file, show solution, ...); 
	FinishStep(computationalSystem, simulationSettings); //visualization, console output, file output, ...


	bool simulationEndTimeReached = false; //signals that end time has been reached (tEnd in time integration, loadFactor=1 in static solver)
	it.currentStepIndex++; //first step starts with stepIndex = 1
	//while (!conv.stepReductionFailed && it.currentStepIndex <= it.numberOfSteps &&
	//	!computationalSystem.GetPostProcessData()->stopSimulation)
	while (!conv.stepReductionFailed && !simulationEndTimeReached &&
			!computationalSystem.GetPostProcessData()->stopSimulation)
	{
		computationalSystem.GetSystemData().GetCData().startOfStepState = computationalSystem.GetSystemData().GetCData().currentState; //for step reduction, disc. iteration, python functions, etc.
		data.startOfStepStateAAlgorithmic.CopyFrom(data.aAlgorithmic);

		//Real t = it.currentStepIndex * it.currentStepSize + it.startTime;
		//computationalSystem.GetSystemData().GetCData().currentState.time = it.currentTime; //update time in state --> also available in Python for user-defined functions

		bool stepAccomplished = false;
		//do step size reduction
		while (!stepAccomplished && !conv.stepReductionFailed)
		{

			//python linking, visualization, output, ... for every step
			InitializeStep(computationalSystem, simulationSettings);

			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//Post Newton iteration for one time step
			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			if (newton.modifiedNewtonJacUpdatePerStep) { conv.jacobianUpdateRequested = true; }

			if (!DiscontinuousIteration(computationalSystem, simulationSettings))
			{
				//try to reduce step size

				if (it.adaptiveStep)
				{
					computationalSystem.GetSystemData().GetCData().currentState = computationalSystem.GetSystemData().GetCData().startOfStepState; //completely reset state including data variables and time

					if (!ReduceStepSize(computationalSystem, simulationSettings, 1))
					{
						conv.stepReductionFailed = true;
						if (IsVerboseCheck(1))
						{
							VerboseWrite(1, "Solve steps: step reduction reached minimum step size; stop solver\n");
						}
					}
					else
					{
						if (IsVerboseCheck(1))
						{
							VerboseWrite(1, STDstring("  Solve steps: reduce step size to ") + EXUstd::ToString(it.currentStepSize) + "\n");
						}
						stepsSinceLastStepSizeReduction = 0;
					}
				}
				else
				{
					conv.stepReductionFailed = true;
				}
			}
			else
			{
				stepAccomplished = true;
				FinishStep(computationalSystem, simulationSettings); //visualization, console output, file output, ...

				//in case of good Newton convergence, increase step size
				stepsSinceLastStepSizeReduction++;
				if ((stepsSinceLastStepSizeReduction >= 10 || (IsStaticSolver() && stepsSinceLastStepSizeReduction > 3)) &&
					it.newtonSteps + it.discontinuousIteration < 6) //small iteration numbers needed to increase step ...
				{ 
					IncreaseStepSize(computationalSystem, simulationSettings); 
					stepsSinceLastStepSizeReduction = 0;
				}
			}
		}

		it.currentStepIndex++; //increment iteration count
		if (it.currentTime >= it.endTime - 1e-10) { simulationEndTimeReached = true; } //accept small tolerance
	}//time integration loop

	return !conv.stepReductionFailed; //return success (true) or fail (false)
}

//! initialize static step / time step: do some outputs, checks, etc.
void CSolverBase::InitializeStep(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	UpdateCurrentTime(computationalSystem, simulationSettings);

	computationalSystem.GetSystemData().GetCData().currentState.time = it.currentTime; //update time in state --> also available in Python for user-defined functions

	if (IsVerbose(2)) {
		Real t = it.currentTime; // computationalSystem.GetSystemData().GetCData().GetCurrent().GetTime();
		STDstring str;
		str += "+++++++++++++++ COMPUTE STEP +++++++++++++++\n";
		if (!IsStaticSolver())
		{
			str += "STEP" + EXUstd::ToString(it.currentStepIndex) + ", t = " + EXUstd::ToString(t);
			if (it.adaptiveStep) { str += ", step size = " + EXUstd::ToString(it.currentStepSize); }
			str += "\n";
		}
		else
		{
			str += "STEP" + EXUstd::ToString(it.currentStepIndex) + ", factor = " + EXUstd::ToString(ComputeLoadFactor(simulationSettings));
			if (t != ComputeLoadFactor(simulationSettings)) { str += ", t = " + EXUstd::ToString(t); }
			if (it.adaptiveStep) { str += ", step size = " + EXUstd::ToString(it.currentStepSize); }
			str += "\n";
		}

		Verbose(2, str);
	}
	if (!IsStaticSolver())
	{
		it.endTime = simulationSettings.timeIntegration.endTime; //update time, which may be updated for long integration time
	}

	STARTTIMER(timer.python);
	if (!IsStaticSolver())
	{
		if (simulationSettings.timeIntegration.preStepPyExecute.size()) //if this string is not empty, execute the commands
		{
			//py::exec(timeint.preStepPyExecute.c_str()); //will only work, if all variables of the preStepPyExecute string are defined in the global scope

			py::object scope = py::module::import("__main__").attr("__dict__"); //use this to enable access to mbs and other variables of global scope within test models suite
			py::exec(simulationSettings.timeIntegration.preStepPyExecute.c_str(), scope);
		}
	}
	else
	{
		if (simulationSettings.staticSolver.preStepPyExecute.size()) //if this string is not empty, execute the commands
		{
			py::object scope = py::module::import("__main__").attr("__dict__"); //use this to enable access to mbs and other variables of global scope within test models suite
			py::exec(simulationSettings.staticSolver.preStepPyExecute.c_str(), scope);
		}
	}
	PyProcessExecuteQueue(); //execute incoming python tasks if available
	STOPTIMER(timer.python);
}
//! finish static step / time step; write output of results to file
void CSolverBase::FinishStep(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real t = computationalSystem.GetSystemData().GetCData().GetCurrent().GetTime();

	//output step information to console and solverFile
	bool printFile = ((output.verboseModeFile == 1) && ((EXUstd::GetTimeInSeconds() - output.cpuLastTimePrinted >= 2)
		|| it.currentTime + 1e-10>=it.endTime )) || (output.verboseModeFile >= 2);
	bool printConsole = ((output.verboseMode == 1) && ((EXUstd::GetTimeInSeconds() - output.cpuLastTimePrinted >= 2)
		|| it.currentTime + 1e-10 >= it.endTime)) || (output.verboseMode >= 2);

	if (printFile || printConsole)
	{
		STARTTIMER(timer.overhead);
		output.cpuLastTimePrinted += 2;
		Real timeToGo = 0;
		Real cpuTimeElapsed = (EXUstd::GetTimeInSeconds() - output.cpuStartTime);
		Real simTotalTime = it.endTime - it.startTime;
		Real simTimeRemaining = it.endTime - t;
		Real simTimeElapsed = t - it.startTime;

		if (cpuTimeElapsed > 1e-1 && simTimeElapsed > 1e-3*simTotalTime && it.currentStepIndex != 0)
		{
			timeToGo = simTimeRemaining * (cpuTimeElapsed / simTimeElapsed);
			//old: based on steps: timeToGo = (double)(n - it.currentStepIndex) * timeToGo / (double)i;
		}

		STDstring str = "STEP" + EXUstd::ToString(it.currentStepIndex);
		if (!IsStaticSolver()) { str += ", t = " + EXUstd::ToString(t) + " sec"; }
		else { str += ", factor = " + EXUstd::ToString(ComputeLoadFactor(simulationSettings)); }

		if (newton.stepInformation >= 1) {
			str += ", timeToGo = " + EXUstd::ToString(timeToGo); 
		}
		if (newton.stepInformation >= 2 && it.currentStepIndex != 0) {
			str += " sec, Nit/step = " + EXUstd::ToString(it.newtonStepsCount / (Real)(it.currentStepIndex));
		}
		if (newton.stepInformation >= 3 && it.currentStepIndex != 0) {
			str += " Dit/step = " + EXUstd::ToString(it.discontinuousIterationsCount / (Real)(it.currentStepIndex)) +
				" jac/step = " + EXUstd::ToString(it.newtonJacobiCount / (Real)(it.currentStepIndex));
		}
		str += "\n";
		if (printConsole) { pout << str; }
		if (printFile) { file.solverFile << str; }
		if (IsVerbose(2)) { Verbose(2, "+++++++++++++++ STEP FINISHED ++++++++++++++\n\n"); }

		STOPTIMER(timer.overhead);
	}

	if (output.writeToSolutionFile)
	{

		//modify lastSolutionWritten to include last step in output file
		if (fabs(t - it.endTime) <= 1e-10) {
			output.lastSolutionWritten = it.endTime - it.currentStepSize;
		}

		STARTTIMER(timer.writeSolution);
		WriteCoordinatesToFile(computationalSystem, simulationSettings);
		STOPTIMER(timer.writeSolution);
	}

	if (computationalSystem.GetSystemData().GetCSensors().NumberOfItems() != 0)
	{
		//modify lastSolutionWritten to include last step in output file
		if (fabs(t - it.endTime) <= 1e-10) {
			output.lastSensorsWritten = it.endTime - it.currentStepSize;
		}

		STARTTIMER(timer.writeSolution);
		WriteSensorsToFile(computationalSystem, simulationSettings);
		STOPTIMER(timer.writeSolution);
	}

	STARTTIMER(timer.visualization);

	bool recordImage = false;

	if (simulationSettings.solutionSettings.recordImagesInterval >= 0)
	{
		if (t >= output.lastImageRecorded + simulationSettings.solutionSettings.recordImagesInterval)
		{
			output.lastImageRecorded += simulationSettings.solutionSettings.recordImagesInterval; //keep this interval constant to obtain frames recorded in constant time interval
			recordImage = true;
		}
	}
	computationalSystem.UpdatePostProcessData(recordImage);

	if (simulationSettings.pauseAfterEachStep) { computationalSystem.GetPostProcessData()->WaitForUserToContinue(); }
	STOPTIMER(timer.visualization);
}

//! perform discontinuousIteration for static step / time step
bool CSolverBase::DiscontinuousIteration(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{

	conv.discontinuousIterationError = 0;		//error of discontinuous iterations (contact, friction, ...) outside of Newton iteration

	//data.startOfStepStateAAlgorithmic = data.aAlgorithmic; //changed 2019-12-29; moved to SolveSteps(...)
	CSystemState& current = computationalSystem.GetSystemData().GetCData().GetCurrent();

	bool discIterFinishedSuccessful = false; //local variable
	it.discontinuousIteration = 0;
	while (it.discontinuousIteration < newton.maxDiscontinuousIterations && !discIterFinishedSuccessful)
	{
		if (IsVerbose(2)) { Verbose(2,STDstring("  START discontinuous iteration ")+EXUstd::ToString(it.discontinuousIteration) + ":\n"); }

		if (Newton(computationalSystem, simulationSettings))
		{

			conv.discontinuousIterationError = computationalSystem.PostNewtonStep(data.tempCompData);

			if (IsVerbose(2))
			{
				STDstring str = STDstring("  discontinuous iteration error = ") + EXUstd::ToString(conv.discontinuousIterationError)
					+ " (disc.it.=" + EXUstd::ToString(it.discontinuousIteration)
					+ ", error goal = " + EXUstd::ToString(newton.discontinuousIterationTolerance);
				if (conv.discontinuousIterationError <= newton.discontinuousIterationTolerance)
				{
					str += " ... REACHED";
				}
				str += ")\n";
				Verbose(2, str);
			}
			if (IsVerbose(3)) //print more details about disc. iteration
			{
				STDstring str;
				str += "    disc.it. solU      = " + EXUstd::ToString(current.ODE2Coords) + "\n";
				if (!IsStaticSolver())
				{
					str += "    disc.it. solV      = " + EXUstd::ToString(current.ODE2Coords_t) + "\n";
					str += "    disc.it. solA      = " + EXUstd::ToString(current.ODE2Coords_tt) + "\n";
				}
				str += "    disc.it. solData   = " + EXUstd::ToString(current.dataCoords) + "\n";
				str += "    disc.it. solLambda = " + EXUstd::ToString(current.AECoords) + "\n";
				Verbose(3, str);
			}

			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			it.discontinuousIteration++; it.discontinuousIterationsCount++;

			if (conv.discontinuousIterationError > newton.discontinuousIterationTolerance)
			{
				if (it.discontinuousIteration < newton.maxDiscontinuousIterations)
				{
					//start NEW DiscontinuousIteration
					//reset states to start of discontinuous iteration, EXCEPT for data variables!:
					current.ODE2Coords = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords;
					current.ODE2Coords_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_t;
					current.ODE2Coords_tt = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_tt;
					current.AECoords = computationalSystem.GetSystemData().GetCData().startOfStepState.AECoords;
					data.aAlgorithmic = data.startOfStepStateAAlgorithmic; //for generalized-alpha
				}
				else
				{
					//MAX iterations reached --> stop
					if (!newton.ignoreMaxDiscontinuousIterations) { return false; }

					//continue solver if discontinuous iterations do not converge
					discIterFinishedSuccessful = true;
				}
			}
			else { discIterFinishedSuccessful = true; }

		}
		else
		{
			//NEWTON not successful --> terminate disc. iteration
			conv.discontinuousIterationError = newton.discontinuousIterationTolerance * 2.;
			return false;
		}
	} //discontinuous (postNewton) iteration
	return discIterFinishedSuccessful || (newton.maxDiscontinuousIterations == 0); //return success; in case that no discIter. are needed (==0), no error is returned
}

////! compute residual for Newton method (e.g. static or time step)
//bool CSolverBase::ComputeNewtonResidual(CSystem& computationalSystem, const SimulationSettings& simulationSettings) { CHECKandTHROWstring("CSolverBase::illegal call"); return 0; }
//
////! compute jacobian for newton method
//bool CSolverBase::ComputeNewtonJacobian(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
//{
//}
//! perform Newton method for given solver method
bool CSolverBase::Newton(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	STARTTIMER(timer.overhead);

	//LinkedDataVector ode2Residual(data.systemResidual, 0, data.nODE2); //link ODE2 coordinates
	//LinkedDataVector aeResidual(data.systemResidual, data.startAE, data.nAE); //link ae coordinates
	LinkedDataVector newtonSolutionODE2(data.newtonSolution, 0, data.nODE2); //temporary subvector for ODE2 components
	LinkedDataVector newtonSolutionAE(data.newtonSolution, data.startAE, data.nAE); //temporary subvector for ODE2 components

	//link current system vectors for ODE2
	Vector& solutionODE2 = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	Vector& solutionODE2_t = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
	Vector& solutionODE2_tt = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
	Vector& solutionData = computationalSystem.GetSystemData().GetCData().currentState.dataCoords;
	Vector& solutionAE = computationalSystem.GetSystemData().GetCData().currentState.AECoords;

	conv.linearSolverFailed = false;		//(errorOccurred) signals that linear solver failed ==> abort integration method or reduce step size
	conv.newtonConverged = false;			//convergence of Newton reached by tolerance criteria
	conv.newtonSolutionDiverged = false;	//shows that solution diverged (e.g. in first step)


	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//NEWTON method for one time step
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Real absError = -1; //current error
	Real initialResidual;

	//copy ODE, ODE_T, ODE_tt and AE solution from last step or initial conditions; if modified Newton diverges ==> falls back to u_tt0, u0, ...
	//data.u0.CopyFrom(solutionODE2);
	//data.lambda0.CopyFrom(solutionAE);				//initialized but never used; not part of integration scheme...!
	if (!IsStaticSolver())
	{
		//data.u_t0.CopyFrom(solutionODE2_t);
		//data.u_tt0.CopyFrom(solutionODE2_tt);
		//data.aAlgorithmic0.CopyFrom(data.aAlgorithmic); //for generalized-alpha
		solutionODE2_tt.SetAll(0.); //use zero accelerations as start guess for Newton iterations
	}

	solutionAE.SetAll(0.);		//use zero Lagrange multipliers as start guess for Newton iterations step ==> does not work for algebraic variables such as in sliding joint
	STOPTIMER(timer.overhead);

	//compute initial residual:
	data.newtonSolution.SetAll(0.); //no update yet
	ComputeNewtonUpdate(computationalSystem, simulationSettings); //better initial guess for Newton

	ComputeNewtonResidual(computationalSystem, simulationSettings);


	if (newton.newtonResidualMode == 0) {
		initialResidual = data.systemResidual.GetL2Norm() / conv.errorCoordinateFactor; //systemResidual is linked to ode2Residual and aeResidual
	}
	else if (newton.newtonResidualMode == 1) { //coordinate update as residual
		initialResidual = 2*newton.relativeTolerance; //this mode should use absoluteTolerance
	}
	else { PyError("NewtonSettings.newtonResidualMode: unsupported mode"); }

	if (initialResidual <= newton.absoluteTolerance)
	{
		initialResidual = 2.*newton.absoluteTolerance; //Make at least one Newton step and avoid division by zero! factor 2 is for safety
	}

	if (IsVerbose(2)) { Verbose(2, "Newton: initial residual = " + EXUstd::ToString(initialResidual) +
		"; goals: relTol=" + EXUstd::ToString(newton.relativeTolerance) +
		", absTol=" + EXUstd::ToString(newton.absoluteTolerance) + "\n"); }


	it.newtonSteps = 0; //current number of steps
	conv.residual = initialResidual;				//current residual
	conv.lastResidual = initialResidual;			//to determine contractivity
	conv.contractivity = 0;							//contractivity = geometric decay of error in every step
	bool modifiedNewtonRestarted = false;			//flag, which signals that modified Newton method has already been restarted
	bool fullNewtonRequested = !newton.useModifiedNewton; //in every step, the modified Newton method can switch to full Newton's method
	bool stopNewton = false;						//flag which tells that Newton shall be stopped (Jacobian singular, full Newton not converged, ?)
	conv.errorCoordinateFactor = 1.;				

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Newton iterations
	while (!conv.linearSolverFailed && !conv.newtonConverged && 
		!stopNewton && it.newtonSteps < newton.maxIterations)
	{
		if (data.nSys > 200) { PyProcessExecuteQueue(); } //do this task regularly, specifically in large scale systems

		it.newtonSteps++; it.newtonStepsCount++;
		if (IsVerbose(3)) { Verbose(3, "  Newton: STEP "  + EXUstd::ToString(it.newtonSteps) + ":\n"); }
		if (IsVerbose(4)) { Verbose(4, "    systemResidual = " + EXUstd::ToString(data.systemResidual) + "\n"); }

		//+++++++++++++++++++++++++++++
		//compute JACOBIAN if necessary
		if (conv.jacobianUpdateRequested || fullNewtonRequested || computationalSystem.GetSolverData().signalJacobianUpdate)
		{
			if (newton.useModifiedNewton && IsVerbose(2))
			{
				STDstring str = "  Update Jacobian ... (flags: jacUpdateReq=" + EXUstd::ToString(conv.jacobianUpdateRequested) +
					", fullNewtonReq=" + EXUstd::ToString(fullNewtonRequested) +
					", sigJacUpdate=" + EXUstd::ToString(computationalSystem.GetSolverData().signalJacobianUpdate) + "\n";
				Verbose(2, str);
			}
			ComputeNewtonJacobian(computationalSystem, simulationSettings);

			STARTTIMER(timer.factorization);
			data.systemJacobian->FinalizeMatrix();
			if (data.systemJacobian->Factorize() != 0)
			{
				SysError("CSolverBase::Newton: System Jacobian not invertible!"); //this error might not be recoverable
				conv.linearSolverFailed = true;
				stopNewton = true;
			}
			STOPTIMER(timer.factorization);

			it.newtonJacobiCount++;
			conv.jacobianUpdateRequested = false;
		}

		//+++++++++++++++++++++++++++++
		//perform step
		if (!conv.linearSolverFailed)
		{
			if (IsVerbose(4)) {Verbose(4, "    JacInv = " + EXUstd::ToString(*(data.systemJacobian)) + "\n"); }

			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//now compute descent of acceleration vector with jacobian

			STARTTIMER(timer.newtonIncrement);
			data.systemJacobian->Solve(data.systemResidual, data.newtonSolution);
			STOPTIMER(timer.newtonIncrement);

			ComputeNewtonUpdate(computationalSystem, simulationSettings);


			if (IsVerbose(3)) { Verbose(3, "    newtonIncrement = " + EXUstd::ToString(data.newtonSolution) + "\n    ... compute new residual\n"); }

			//++++++++++++++++++++++++++++++++++++++++++
			//compute residual from static step increment or from integration formula:
			ComputeNewtonResidual(computationalSystem, simulationSettings);
			//++++++++++++++++++++++++++++++++++++++++++

			if (newton.newtonResidualMode == 0) {
				conv.residual = data.systemResidual.GetL2Norm() / conv.errorCoordinateFactor;
			} else {
				conv.residual = newtonSolutionODE2.GetL2Norm() / conv.errorCoordinateFactor; //increment of newton ODE2 coordinates used to determine error
			}

			if (IsVerbose(2))
			{
				Verbose(2, "    NEWTON STEP " + EXUstd::ToString(it.newtonSteps) + 
					": residual = " + EXUstd::ToString(conv.residual) +
					": relTol = " + EXUstd::ToString(conv.residual / initialResidual) +
					": contr. = " + EXUstd::ToString(conv.residual / conv.lastResidual) +
					"\n");
			}
			if (IsVerbose(3))
			{
				STDstring str;
				str += "    Newton solU         = " + EXUstd::ToString(solutionODE2) + "\n";
				if (!IsStaticSolver())
				{
					str += "    Newton solV         = " + EXUstd::ToString(solutionODE2_t) + "\n";
					str += "    Newton solA         = " + EXUstd::ToString(solutionODE2_tt) + "\n";
				}
				str += "    Newton solData      = " + EXUstd::ToString(solutionData) + "\n";
				str += "    Newton solLambda    = " + EXUstd::ToString(solutionAE) + "\n";
				str += "    Newton RESIDUAL     = " + EXUstd::ToString(data.systemResidual) + "\n";
				Verbose(3, str);
			}
			if (newton.adaptInitialResidual && conv.residual > initialResidual && it.newtonSteps <= 1) {
				initialResidual = conv.residual;
				conv.lastResidual = conv.residual; //for computation of contractivity lateron
				if (IsVerbose(2)) { Verbose(2, "    update initial residual with current residual; initial residual = " + EXUstd::ToString(initialResidual) + "\n"); }
			}

			if (conv.residual / initialResidual <= newton.relativeTolerance)
			{
				conv.newtonConverged = true;
			}
			else if (conv.residual <= newton.absoluteTolerance)
			{
				conv.newtonConverged = true;
				if (IsVerbose(2)) { Verbose(2, "  Newton convergence reached with absolute error = " + EXUstd::ToString(conv.residual) + "\n"); }
			}

			if (!conv.newtonConverged)
			{
				Real normU = solutionODE2.GetL2NormSquared();
				Real normV = 0;
				if (!IsStaticSolver()) { normV = solutionODE2_t.GetL2NormSquared(); }

				Real normLambda = solutionAE.GetL2NormSquared();

				conv.newtonSolutionDiverged = false;
				//check, if solution has diverged
				if (normU >= newton.maximumSolutionNorm || normV >= newton.maximumSolutionNorm ||
					std::isnan(normU) || std::isnan(normV) || std::isnan(normLambda))
				{
					if (fullNewtonRequested)
					{
						stopNewton = true;
						if (IsVerboseCheck(1)) { VerboseWrite(1, "  solution did not converge with full Newton\n"); }
						if (IsVerbose(4))
						{
							Verbose(4, "  Reasons for Newton divergence(maximum value=" + EXUstd::ToString(sqrt(newton.maximumSolutionNorm)) + 
								"): \n    normU = " + EXUstd::ToString(sqrt(normU)) + 
								"\n    normV = " + EXUstd::ToString(sqrt(normV)) +
								"\n    normLambda = " + EXUstd::ToString(sqrt(normLambda)) + "\n");
						}

					}
					else
					{
						if (IsVerbose(2)) { Verbose(2, "    ... full Newton requested because of diverged solution\n"); }
						conv.newtonSolutionDiverged = true; //previously only set in else case
					}
				}

				//bool maxModifiedNewtonStepsReached = false;
				if (!fullNewtonRequested && (it.newtonSteps > newton.maxModifiedNewtonIterations))
				{
					conv.jacobianUpdateRequested = true; //make a simple Jacobian update and continue Newton iterations
				}

				bool switchToFullNewton = false;
				if (!fullNewtonRequested && (it.newtonSteps > newton.maxModifiedNewtonIterations + newton.maxModifiedNewtonRestartIterations*(1-(int)newton.modifiedNewtonJacUpdatePerStep)))
				{
					fullNewtonRequested = true;
					it.rejectedModifiedNewtonSteps++;
					switchToFullNewton = true;
				}

				//decide on modified Newton based on contractivity
				conv.contractivity = conv.residual / conv.lastResidual; //last residual must always be greater than 0!!!
				if (newton.useModifiedNewton)
				{
					if (IsVerbose(3)) { Verbose(3, "    contractivity = " + EXUstd::ToString(conv.contractivity) + "\n"); }
					if (IsVerbose(3)) { Verbose(3, "    last residual = " + EXUstd::ToString(conv.lastResidual) + "\n"); }
				}

				conv.lastResidual = conv.residual;
				//in case of modified newton try with jacobian update and full newton ...
				
				if (newton.useModifiedNewton && (conv.newtonSolutionDiverged || switchToFullNewton || //ADDED switchToFullNewton; but do not enter this loop in case that solely fullNewtonRequested=true
					(conv.contractivity > newton.modifiedNewtonContractivity && it.newtonSteps > 2))) //only check contractivity at third step
				{
					conv.jacobianUpdateRequested = true; //make a simple Jacobian update and continue Newton iterations

					if (modifiedNewtonRestarted && !fullNewtonRequested) //if modified Newton already restarted ==> use full Newton now!
					{
						fullNewtonRequested = true;
						it.rejectedModifiedNewtonSteps++;
						if (IsVerbose(2)) { Verbose(2, "    ... switch to full Newton due to repeated bad contractivity\n"); }
					}

					if (!stopNewton && (conv.newtonSolutionDiverged || conv.contractivity > 2 || fullNewtonRequested))  //this might indicate divergence ==> restart Newton if modified newton is used
					{
						modifiedNewtonRestarted = true;
						conv.jacobianUpdateRequested = true;

						//lastResidual = EXUstd::Maximum(lastResidual, initialResidual)*1.e6; //safety of 1e6 to relieve the contracticity condition of next step

						conv.residual = initialResidual;  //current residual
						conv.lastResidual = initialResidual; //to determine contractivity

						//initialize states with beginning of time step; dataCoords are not changed here, as they are modified only outside Newton
						solutionODE2 = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords;
						if (!IsStaticSolver())
						{
							solutionODE2_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_t;
							solutionODE2_tt.SetAll(0.); //use zero accelerations as guess for next step
							data.aAlgorithmic = data.startOfStepStateAAlgorithmic;
						}
						solutionAE.SetAll(0.); //use zero Lagrange multipliers as start guess for Newton iterations step ==> does not work for algebraic variables such as in sliding joint

						//++++++++++++++++++++++++++++++++++++++++++++++++++++++
						//compute residual (for beginning of step, which means that delta_acc=0, lambda=0):
						data.newtonSolution.SetAll(0.); //no update yet
						ComputeNewtonUpdate(computationalSystem, simulationSettings); //better initial guess for Newton
						ComputeNewtonResidual(computationalSystem, simulationSettings);

						if (IsVerbose(2) && !conv.newtonSolutionDiverged) { Verbose(2, "    ... Newton restarted to bad contractivity, divergence or iterations count\n"); }
					}
				} //contractivity check
			}//converged
		} //Jacobian invert
	}//Newton iteration
	double duration = EXUstd::GetTimeInSeconds() - output.cpuStartTime;

	if (stopNewton || !conv.newtonConverged)
	{
		if (IsVerboseCheck(1)) {
			STDstring str = "  Newton (time/load step #" + EXUstd::ToString(it.currentStepIndex) +
				"): convergence failed after " + EXUstd::ToString(it.newtonSteps) +
				" iterations; relative error = " + EXUstd::ToString(conv.residual / initialResidual);
			if (IsStaticSolver()) {str += ", load factor = " + EXUstd::ToString(computationalSystem.GetSolverData().loadFactor);}
			else { str += ", time = " + EXUstd::ToString(it.currentTime); }
			str += "\n";
			VerboseWrite(1, str);
		}
	}
	else
	{
		if (IsVerbose(2)) { Verbose(2, "  Newton: convergenced after " + EXUstd::ToString(it.newtonSteps) +
			" steps; relative error = " + EXUstd::ToString(conv.residual / initialResidual) + "\n"); }
	}

	return !(stopNewton || !conv.newtonConverged); //return success (true) or fail (false)
}









//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



//! write solution file header commonly for static and dynamic solvers
void CSolverBase::WriteSolutionFileHeader(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	
	if (!output.writeToSolutionFile) { return; }

	const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration; //only needed for time integration header
	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;  //only needed for static solver header

	bool isStatic = IsStaticSolver();

	Index nVel1 = 0;
	Index nVel2 = 0;
	Index nAcc2 = 0;
	Index nAEexported = 0;
	Index nDataExported = 0;

	Index nODE2, nODE1, nAE, nData; //values could also been taken from SolverData ...
	computationalSystem.GetSystemData().GetNumberOfComputationCoordinates(nODE2, nODE1, nAE, nData);
	Index nSys = nODE2 + nODE1 + nAE;

	if (solutionSettings.exportVelocities && !isStatic) { nVel2 = nODE2; nVel1 = nODE1; }
	if (solutionSettings.exportAccelerations && !isStatic) { nAcc2 = nODE2; }
	if (solutionSettings.exportAlgebraicCoordinates) { nAEexported = nAE; }
	if (solutionSettings.exportDataCoordinates) { nDataExported = nData; }

	std::ofstream& solFile = file.solutionFile;

	if (solutionSettings.writeFileHeader)
	{
		solFile << "#Exudyn " << GetSolverName() << " ";
		if (isStatic) { solFile << "static "; }
		solFile << "solver solution file\n";
		solFile << "#simulation started=" << EXUstd::GetDateTimeString() << "\n";
		solFile << "#columns contain: time, ODE2 displacements";
		if (solutionSettings.exportVelocities) { solFile << ", ODE2 velocities"; }
		if (solutionSettings.exportAccelerations) { solFile << ", ODE2 accelerations"; }
		if (nODE1) { solFile << ", ODE1 coordinates"; } //currently not available, but for future solFile structure necessary!
		if (nVel1) { solFile << ", ODE1 velocities"; }
		if (solutionSettings.exportAlgebraicCoordinates) { solFile << ", AE coordinates"; }
		if (solutionSettings.exportDataCoordinates) { solFile << ", ODE2 velocities"; }
		solFile << "\n";

		solFile << "#number of system coordinates [nODE2, nODE1, nAlgebraic, nData] = [" <<
			nODE2 << "," << nODE1 << "," << nAE << "," << nData << "]\n"; //this will allow to know the system information, independently of coordinates written
		solFile << "#number of written coordinates [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = [" << //these are the exported coordinates line-by-line
			nODE2 << "," << nVel2 << "," << nAcc2 << "," << nODE1 << "," << nVel1 << "," << nAEexported << "," << nDataExported << "]\n"; //python convert line with v=eval(line.split('=')[1])

		solFile << "#total columns exported  (excl. time) = " << nODE2 + nVel2 + nAcc2 + nODE1 + nVel1 + nAEexported + nDataExported << "\n";
		if (!isStatic) { solFile << "#number of time steps (planned) = " << timeint.numberOfSteps << "\n"; }
		else { solFile << "#number of load steps (planned) = " << staticSolver.numberOfLoadSteps << "\n"; }
		solFile << "#\n"; //empty line for extension ...

		if (solutionSettings.solutionInformation.length())
		{
			solFile << "#solution information = " << solutionSettings.solutionInformation << "\n";
		}
	}

}


void CSolverBase::WriteCoordinatesToFile(const CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real t = computationalSystem.GetSystemData().GetCData().currentState.time;
	Real startTime = computationalSystem.GetSystemData().GetCData().initialState.time;

	const Vector& solutionU = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	const Vector& solutionV = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
	const Vector& solutionA = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
	const Vector& solutionLambda = computationalSystem.GetSystemData().GetCData().currentState.AECoords;
	const Vector& solutionData = computationalSystem.GetSystemData().GetCData().currentState.dataCoords;

	//OLD timeIntegrationSolver: if (t == startTime || (t - lastSolutionWritten) >= (0 * solutionSettings.GetSolutionWritePeriod() - 1e-10)) //1e-10 because of roundoff errors
	if (t == startTime || (t - output.lastSolutionWritten) >= -1e-10) //1e-10 because of roundoff errors
	{

		std::ofstream& solFile = file.solutionFile;
		const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;

		output.lastSolutionWritten += solutionSettings.solutionWritePeriod;
		output.lastSolutionWritten = EXUstd::Maximum(output.lastSolutionWritten, t); //never accept smaller values ==> for adaptive solver
		solFile << t;

		for (Index k = 0; k < solutionU.NumberOfItems(); k++) {
			solFile << "," << solutionU[k];
		}
		if (solutionSettings.exportVelocities)
		{
			for (Index k = 0; k < solutionV.NumberOfItems(); k++) {
				solFile << "," << solutionV[k];
			}
		}
		if (solutionSettings.exportAccelerations)
		{
			for (Index k = 0; k < solutionA.NumberOfItems(); k++) {
				solFile << "," << solutionA[k];
			}
		}
		if (solutionSettings.exportAlgebraicCoordinates)
		{
			for (Index k = 0; k < solutionLambda.NumberOfItems(); k++) {
				solFile << "," << solutionLambda[k];
			}
		}
		if (solutionSettings.exportDataCoordinates)
		{
			for (Index k = 0; k < solutionData.NumberOfItems(); k++) {
				solFile << "," << solutionData[k];
			}
		}
		solFile << "\n";
	}
}


//! write unique sensor file header, depending on static/dynamic simulation
void CSolverBase::WriteSensorsFileHeader(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Index cnt = 0;
	for (auto item : computationalSystem.GetSystemData().GetCSensors())
	{
		if (file.sensorFileList.size() >= cnt && file.sensorFileList[cnt] != nullptr)
		{
			std::ofstream* sFile = file.sensorFileList[cnt];
			(*sFile) << "#Exudyn " << GetSolverName() << " ";
			if (IsStaticSolver()) { (*sFile) << "static "; }
			(*sFile) << "sensor output file\n";
			STDstring typeStr = GetSensorTypeString(item->GetType());

			(*sFile) << "#measure " << typeStr << " number = " << item->GetTypeDependentIndex() << "\n";
			(*sFile) << "#OutputVariableType = " << GetOutputVariableTypeString(item->GetOutputVariableType()) << "\n";

			(*sFile) << "#simulation started = " << EXUstd::GetDateTimeString() << "\n";
			(*sFile) << "#columns contain: time, comma separated sensor values (e.g, x,y,z position coordinates)\n";

			item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Initial);

			(*sFile) << "#number of sensor values = " << output.sensorValuesTemp.NumberOfItems() << "\n";
			(*sFile) << "#\n";
		}
		cnt++;
	}
}

//! write unique sensor solution file
void CSolverBase::WriteSensorsToFile(const CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real t = computationalSystem.GetSystemData().GetCData().currentState.time;
	Real startTime = computationalSystem.GetSystemData().GetCData().initialState.time;

	if (t == startTime || (t - output.lastSensorsWritten) >= -1e-10) //1e-10 because of roundoff errors
	{

		std::ofstream& solFile = file.solutionFile;
		const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;

		output.lastSensorsWritten += solutionSettings.sensorsWritePeriod;
		output.lastSensorsWritten = EXUstd::Maximum(output.lastSensorsWritten, t); //never accept smaller values ==> for adaptive solver

		Index cnt = 0;
		for (auto item : computationalSystem.GetSystemData().GetCSensors())
		{
			if (file.sensorFileList.size() >= cnt && file.sensorFileList[cnt] != nullptr)
			{
				std::ofstream* sFile = file.sensorFileList[cnt];

				(*sFile) << t;
				
				item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Current);

				for (auto value : output.sensorValuesTemp)
				{
					(*sFile) << "," << value;
				}
				(*sFile) << "\n";
			}
			cnt++;
		}
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//! return true, if file or console output is at or above the given level
void CSolverBase::VerboseWrite(Index level, const STDstring& str)
{
	STARTTIMER(timer.overhead);
	if (output.verboseMode >= level)
	{
		pout << str;
	}
	if (output.verboseModeFile >= level)
	{
		file.solverFile << str;
	}
	STOPTIMER(timer.overhead);
}
