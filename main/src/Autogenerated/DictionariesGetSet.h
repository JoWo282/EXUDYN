// AUTO:  ++++++++++++++++++++++
// AUTO:  Helper file for dictionaries get/set for system structures; generated by Johannes Gerstmayr
// AUTO:  Generated by Johannes Gerstmayr
// AUTO:  Used for SimulationSettings and VisualizationSettings
// AUTO:  last modified = 2021-08-12
// AUTO:  ++++++++++++++++++++++

  #ifndef DICTIONARIESGETSET__H
  #define DICTIONARIESGETSET__H

  #include "Linalg/BasicLinalg.h"
  #include "Main/CSystem.h"
  #include "Autogenerated/SimulationSettings.h"
  #include "Autogenerated/VisualizationSettings.h"

  #include <pybind11/pybind11.h>
  #include <pybind11/stl.h>
  #include <pybind11/stl_bind.h>
  namespace py = pybind11;

  namespace EPyUtils {
 //add namespace for access to dictionaries  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const SolutionSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.writeSolutionToFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false), which determines if (global) solution vector is written to file; standard quantities that are written are: solution is written as displacements and coordinatesODE1; for additional coordinates in the solution file, see the options below";
    structureDict["writeSolutionToFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.appendToFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, solution and solverInformation is appended to existing file (otherwise created)";
    structureDict["appendToFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.writeFileHeader;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, file header is written (turn off, e.g. for multiple runs of time integration)";
    structureDict["writeFileHeader"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.writeFileFooter;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, information at end of simulation is written: convergence, total solution time, statistics";
    structureDict["writeFileFooter"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSolutionWritePeriod();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "time span (period), determines how often the solution is written during a simulation";
    structureDict["solutionWritePeriod"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportVelocities;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add \\hac{ODE2} velocities to solution file";
    structureDict["exportVelocities"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportAccelerations;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add \\hac{ODE2} accelerations to solution file";
    structureDict["exportAccelerations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportODE1Velocities;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add coordinatesODE1\\_t to solution file";
    structureDict["exportODE1Velocities"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportAlgebraicCoordinates;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add algebraicCoordinates (=Lagrange multipliers) to solution file";
    structureDict["exportAlgebraicCoordinates"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.exportDataCoordinates;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "add DataCoordinates to solution file";
    structureDict["exportDataCoordinates"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.coordinatesSolutionFileName;
    d["type"] = "FileName";
    d["size"] = std::vector<int>{1};
    d["description"] = "filename and (relative) path of solution file containing all coordinates versus time; directory will be created if it does not exist; character encoding of string is up to your filesystem, but for compatibility, it is recommended to use letters, numbers and '\\_' only";
    structureDict["coordinatesSolutionFileName"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.sensorsAppendToFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, sensor output is appended to existing file (otherwise created)";
    structureDict["sensorsAppendToFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.sensorsWriteFileHeader;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); if true, file header is written for sensor output (turn off, e.g. for multiple runs of time integration)";
    structureDict["sensorsWriteFileHeader"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSensorsWritePeriod();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "time span (period), determines how often the sensor output is written during a simulation";
    structureDict["sensorsWritePeriod"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.solverInformationFileName;
    d["type"] = "FileName";
    d["size"] = std::vector<int>{1};
    d["description"] = "filename and (relative) path of text file showing detailed information during solving; detail level according to yourSolver.verboseModeFile; if solutionSettings.appendToFile is true, the information is appended in every solution step; directory will be created if it does not exist; character encoding of string is up to your filesystem, but for compatibility, it is recommended to use letters, numbers and '\\_' only";
    structureDict["solverInformationFileName"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.solutionInformation;
    d["type"] = "String";
    d["size"] = std::vector<int>{1};
    d["description"] = "special information added to header of solution file (e.g. parameters and settings, modes, ...); character encoding my be UTF-8, restricted to characters in \\refSection{sec:utf8}, but for compatibility, it is recommended to use ASCII characters only (95 characters, see wiki)";
    structureDict["solutionInformation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetOutputPrecision();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "precision for floating point numbers written to solution and sensor files";
    structureDict["outputPrecision"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.recordImagesInterval;
    d["type"] = "Real";
    d["size"] = std::vector<int>{1};
    d["description"] = "record frames (images) during solving: amount of time to wait until next image (frame) is recorded; set recordImages = -1. if no images shall be recorded; set, e.g., recordImages = 0.01 to record an image every 10 milliseconds (requires that the time steps / load steps are sufficiently small!); for file names, etc., see VisualizationSettings.exportImages";
    structureDict["recordImagesInterval"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(SolutionSettings& data, const py::dict& d) {
    data.writeSolutionToFile = py::cast<bool>(d["writeSolutionToFile"]);
    data.appendToFile = py::cast<bool>(d["appendToFile"]);
    data.writeFileHeader = py::cast<bool>(d["writeFileHeader"]);
    data.writeFileFooter = py::cast<bool>(d["writeFileFooter"]);
    data.solutionWritePeriod = py::cast<Real>(d["solutionWritePeriod"]);
    data.exportVelocities = py::cast<bool>(d["exportVelocities"]);
    data.exportAccelerations = py::cast<bool>(d["exportAccelerations"]);
    data.exportODE1Velocities = py::cast<bool>(d["exportODE1Velocities"]);
    data.exportAlgebraicCoordinates = py::cast<bool>(d["exportAlgebraicCoordinates"]);
    data.exportDataCoordinates = py::cast<bool>(d["exportDataCoordinates"]);
    data.coordinatesSolutionFileName = py::cast<std::string>(d["coordinatesSolutionFileName"]);
    data.sensorsAppendToFile = py::cast<bool>(d["sensorsAppendToFile"]);
    data.sensorsWriteFileHeader = py::cast<bool>(d["sensorsWriteFileHeader"]);
    data.sensorsWritePeriod = py::cast<Real>(d["sensorsWritePeriod"]);
    data.solverInformationFileName = py::cast<std::string>(d["solverInformationFileName"]);
    data.solutionInformation = py::cast<std::string>(d["solutionInformation"]);
    data.outputPrecision = py::cast<Index>(d["outputPrecision"]);
    data.recordImagesInterval = py::cast<Real>(d["recordImagesInterval"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const NumericalDifferentiationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRelativeEpsilon();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "relative differentiation parameter epsilon; the numerical differentiation parameter \\varepsilon follows from the formula (\\varepsilon = \\varepsilon_\\mathrm{relative}*max(q_{min}, |q_i + [q^{Ref}_i]|), with \\varepsilon_\\mathrm{relative}=relativeEpsilon, q_{min} = minimumCoordinateSize, q_i is the current coordinate which is differentiated, and qRef_i is the reference coordinate of the current coordinate";
    structureDict["relativeEpsilon"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMinimumCoordinateSize();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "minimum size of coordinates in relative differentiation parameter";
    structureDict["minimumCoordinateSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.doSystemWideDifferentiation;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: system wide differentiation (e.g. all \\hac{ODE2} equations w.r.t. all \\hac{ODE2} coordinates); False: only local (object) differentiation";
    structureDict["doSystemWideDifferentiation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.addReferenceCoordinatesToEpsilon;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: for the size estimation of the differentiation parameter, the reference coordinate q^{Ref}_i is added to \\hac{ODE2} coordinates --> see; False: only the current coordinate is used for size estimation of the differentiation parameter";
    structureDict["addReferenceCoordinatesToEpsilon"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(NumericalDifferentiationSettings& data, const py::dict& d) {
    data.relativeEpsilon = py::cast<Real>(d["relativeEpsilon"]);
    data.minimumCoordinateSize = py::cast<Real>(d["minimumCoordinateSize"]);
    data.doSystemWideDifferentiation = py::cast<bool>(d["doSystemWideDifferentiation"]);
    data.addReferenceCoordinatesToEpsilon = py::cast<bool>(d["addReferenceCoordinatesToEpsilon"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const DiscontinuousSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum number of discontinuous (post Newton) iterations";
    structureDict["maxIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.ignoreMaxIterations;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "continue solver if maximum number of discontinuous (post Newton) iterations is reached (ignore tolerance)";
    structureDict["ignoreMaxIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetIterationTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "absolute tolerance for discontinuous (post Newton) iterations; the errors represent absolute residuals and can be quite high";
    structureDict["iterationTolerance"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(DiscontinuousSettings& data, const py::dict& d) {
    data.maxIterations = py::cast<Index>(d["maxIterations"]);
    data.ignoreMaxIterations = py::cast<bool>(d["ignoreMaxIterations"]);
    data.iterationTolerance = py::cast<Real>(d["iterationTolerance"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const NewtonSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["numericalDifferentiation"] = GetDictionaryWithTypeInfo(data.numericalDifferentiation);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useNumericalDifferentiation;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false = perform direct computation of jacobian, true = use numerical differentiation for jacobian";
    structureDict["useNumericalDifferentiation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useNewtonSolver;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false = linear computation, true = use Newton solver for nonlinear solution";
    structureDict["useNewtonSolver"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRelativeTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "relative tolerance of residual for Newton (general goal of Newton is to decrease the residual by this factor)";
    structureDict["relativeTolerance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAbsoluteTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "absolute tolerance of residual for Newton (needed e.g. if residual is fulfilled right at beginning); condition: sqrt(q*q)/numberOfCoordinates <= absoluteTolerance";
    structureDict["absoluteTolerance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.weightTolerancePerCoordinate;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false = compute error as L2-Norm of residual; true = compute error as (L2-Norm of residual) / (sqrt(number of coordinates)), which can help to use common tolerance independent of system size";
    structureDict["weightTolerancePerCoordinate"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNewtonResidualMode();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "0 ... use residual for computation of error (standard); 1 ... use \\hac{ODE2} and \\hac{ODE1} newton increment for error (set relTol and absTol to same values!) ==> may be advantageous if residual is zero, e.g., in kinematic analysis; TAKE CARE with this flag";
    structureDict["newtonResidualMode"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.adaptInitialResidual;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag (true/false); false = standard; True: if initialResidual is very small (or zero), it may increas dramatically in first step; to achieve relativeTolerance, the initialResidual will by updated by a higher residual within the first Newton iteration";
    structureDict["adaptInitialResidual"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetModifiedNewtonContractivity();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum contractivity (=reduction of error in every Newton iteration) accepted by modified Newton; if contractivity is greater, a Jacobian update is computed";
    structureDict["modifiedNewtonContractivity"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useModifiedNewton;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: compute Jacobian only at first step; no Jacobian updates per step; False: Jacobian computed in every step";
    structureDict["useModifiedNewton"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.modifiedNewtonJacUpdatePerStep;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: compute Jacobian at every time step, but not in every iteration (except for bad convergence ==> switch to full Newton)";
    structureDict["modifiedNewtonJacUpdatePerStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum number of iterations (including modified + restart Newton steps); after that iterations, the static/dynamic solver stops with error";
    structureDict["maxIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxModifiedNewtonIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum number of iterations for modified Newton (without Jacobian update); after that number of iterations, the modified Newton method gets a jacobian update and is further iterated";
    structureDict["maxModifiedNewtonIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaxModifiedNewtonRestartIterations();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum number of iterations for modified Newton after aJacobian update; after that number of iterations, the full Newton method is started for this step";
    structureDict["maxModifiedNewtonRestartIterations"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaximumSolutionNorm();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "this is the maximum allowed value for solutionU.L2NormSquared() which is the square of the square norm (value=u_1^2+u_2^2+...), and solutionV/A...; if the norm of solution vectors are larger, Newton method is stopped; the default value is chosen such that it would still work for single precision numbers (float)";
    structureDict["maximumSolutionNorm"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(NewtonSettings& data, const py::dict& d) {
    SetDictionary(data.numericalDifferentiation, py::cast<py::dict>(d["numericalDifferentiation"]));
    data.useNumericalDifferentiation = py::cast<bool>(d["useNumericalDifferentiation"]);
    data.useNewtonSolver = py::cast<bool>(d["useNewtonSolver"]);
    data.relativeTolerance = py::cast<Real>(d["relativeTolerance"]);
    data.absoluteTolerance = py::cast<Real>(d["absoluteTolerance"]);
    data.weightTolerancePerCoordinate = py::cast<bool>(d["weightTolerancePerCoordinate"]);
    data.newtonResidualMode = py::cast<Index>(d["newtonResidualMode"]);
    data.adaptInitialResidual = py::cast<bool>(d["adaptInitialResidual"]);
    data.modifiedNewtonContractivity = py::cast<Real>(d["modifiedNewtonContractivity"]);
    data.useModifiedNewton = py::cast<bool>(d["useModifiedNewton"]);
    data.modifiedNewtonJacUpdatePerStep = py::cast<bool>(d["modifiedNewtonJacUpdatePerStep"]);
    data.maxIterations = py::cast<Index>(d["maxIterations"]);
    data.maxModifiedNewtonIterations = py::cast<Index>(d["maxModifiedNewtonIterations"]);
    data.maxModifiedNewtonRestartIterations = py::cast<Index>(d["maxModifiedNewtonRestartIterations"]);
    data.maximumSolutionNorm = py::cast<Real>(d["maximumSolutionNorm"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const GeneralizedAlphaSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNewmarkBeta();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "value beta for Newmark method; default value beta = \\frac 1 4 corresponds to (undamped) trapezoidal rule";
    structureDict["newmarkBeta"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNewmarkGamma();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "value gamma for Newmark method; default value gamma = \\frac 1 2 corresponds to (undamped) trapezoidal rule";
    structureDict["newmarkGamma"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useIndex2Constraints;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "set useIndex2Constraints = true in order to use index2 (velocity level constraints) formulation";
    structureDict["useIndex2Constraints"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useNewmark;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, use Newmark method with beta and gamma instead of generalized-Alpha";
    structureDict["useNewmark"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSpectralRadius();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "spectral radius for Generalized-alpha solver; set this value to 1 for no damping or to 0 < spectralRadius < 1 for damping of high-frequency dynamics; for position-level constraints (index 3), spectralRadius must be < 1";
    structureDict["spectralRadius"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.computeInitialAccelerations;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: compute initial accelerations from system EOM in acceleration form; NOTE that initial accelerations that are following from user functions in constraints are not considered for now! False: use zero accelerations";
    structureDict["computeInitialAccelerations"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(GeneralizedAlphaSettings& data, const py::dict& d) {
    data.newmarkBeta = py::cast<Real>(d["newmarkBeta"]);
    data.newmarkGamma = py::cast<Real>(d["newmarkGamma"]);
    data.useIndex2Constraints = py::cast<bool>(d["useIndex2Constraints"]);
    data.useNewmark = py::cast<bool>(d["useNewmark"]);
    data.spectralRadius = py::cast<Real>(d["spectralRadius"]);
    data.computeInitialAccelerations = py::cast<bool>(d["computeInitialAccelerations"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const ExplicitIntegrationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.eliminateConstraints;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: make explicit solver work for simple CoordinateConstraints, which are eliminated for ground constraints (e.g. fixed nodes in finite element models). False: incompatible constraints are ignored (BE CAREFUL)!";
    structureDict["eliminateConstraints"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useLieGroupIntegration;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: use Lie group integration for rigid body nodes; must be turned on for Lie group nodes, but also improves integration of other rigid body nodes. Only available for RK44 integrator.";
    structureDict["useLieGroupIntegration"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.dynamicSolverType;
    d["type"] = "DynamicSolverType";
    d["size"] = std::vector<int>{1};
    d["description"] = "selection of explicit solver type (DOPRI5, ExplicitEuler, ExplicitMidpoint, RK44, RK67, ...), for detailed description see DynamicSolverType, \\refSection{sec:DynamicSolverType}, but only referring to explicit solvers.";
    structureDict["dynamicSolverType"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(ExplicitIntegrationSettings& data, const py::dict& d) {
    data.eliminateConstraints = py::cast<bool>(d["eliminateConstraints"]);
    data.useLieGroupIntegration = py::cast<bool>(d["useLieGroupIntegration"]);
    data.dynamicSolverType = py::cast<DynamicSolverType>(d["dynamicSolverType"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const TimeIntegrationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["newton"] = GetDictionaryWithTypeInfo(data.newton);
    structureDict["discontinuous"] = GetDictionaryWithTypeInfo(data.discontinuous);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStartTime();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "t_{start}: start time of time integration (usually set to zero)";
    structureDict["startTime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetEndTime();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "t_{end}: end time of time integration";
    structureDict["endTime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNumberOfSteps();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "n_{steps}: number of steps in time integration; (maximum) stepSize h is computed from h = \\frac{t_{end} - t_{start}}{n_{steps}}; for automatic stepsize control, this stepSize is the maximum steps size, h_{max} = h";
    structureDict["numberOfSteps"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.adaptiveStep;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: the step size may be reduced if step fails; no automatic stepsize control";
    structureDict["adaptiveStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepRecoverySteps();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Number of steps needed after which steps will be increased after previous step reduction due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepRecoverySteps"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepIncrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "Multiplicative factor (MUST BE > 1) for step size to increase after previous step reduction due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepIncrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepDecrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "Multiplicative factor (MUST BE: 0 < factor < 1) for step size to decrese due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepDecrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.automaticStepSize;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: for specific integrators with error control (e.g., DOPRI5), compute automatic step size based on error estimation; False: constant step size (step may be reduced if adaptiveStep=True); the maximum stepSize reads h = h_{max} = \\frac{t_{end} - t_{start}}{n_{steps}}";
    structureDict["automaticStepSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMinimumStepSize();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "h_{min}: if automaticStepSize=True or adaptiveStep=True: lower limit of time step size, before integrator stops with adaptiveStep; lower limit of automaticStepSize control (continues but raises warning)";
    structureDict["minimumStepSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetInitialStepSize();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "h_{init}: if automaticStepSize=True, initial step size; if initialStepSize==0, max. stepSize, which is (endTime-startTime)/numberOfSteps, is used as initial guess; a good choice of initialStepSize may help the solver to start up faster.";
    structureDict["initialStepSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAbsoluteTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "a_{tol}: if automaticStepSize=True, absolute tolerance for the error control; must fulfill a_{tol} > 0; see \\refSection{sec:ExplicitSolver}";
    structureDict["absoluteTolerance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRelativeTolerance();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "r_{tol}: if automaticStepSize=True, relative tolerance for the error control; must fulfill r_{tol} \\ge 0; see \\refSection{sec:ExplicitSolver}";
    structureDict["relativeTolerance"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStepSizeSafety();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "r_{sfty}: if automaticStepSize=True, a safety factor added to estimated optimal step size, in order to prevent from many rejected steps, see \\refSection{sec:ExplicitSolver}. Make this factor smaller if many steps are rejected.";
    structureDict["stepSizeSafety"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStepSizeMaxIncrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "f_{maxInc}: if automaticStepSize=True, maximum increase of step size per step, see \\refSection{sec:ExplicitSolver}; make this factor smaller (but > 1) if too many rejected steps";
    structureDict["stepSizeMaxIncrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.preStepPyExecute;
    d["type"] = "String";
    d["size"] = std::vector<int>{1};
    d["description"] = "DEPRECATED, use mbs.SetPreStepUserFunction(...); Python code to be executed prior to every step and after last step, e.g. for postprocessing";
    structureDict["preStepPyExecute"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.simulateInRealtime;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: simulate in realtime; the solver waits for computation of the next step until the CPU time reached the simulation time; if the simulation is slower than realtime, it simply continues";
    structureDict["simulateInRealtime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRealtimeFactor();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "if simulateInRealtime=True, this factor is used to make the simulation slower than realtime (factor < 1) or faster than realtime (factor > 1)";
    structureDict["realtimeFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetVerboseMode();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "0 ... no output, 1 ... show short step information every 2 seconds (error), 2 ... show every step information, 3 ... show also solution vector, 4 ... show also mass matrix and jacobian (implicit methods), 5 ... show also Jacobian inverse (implicit methods)";
    structureDict["verboseMode"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetVerboseModeFile();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "same behaviour as verboseMode, but outputs all solver information to file";
    structureDict["verboseModeFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStepInformation();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "0 ... only current step time, 1 ... show time to go, 2 ... show newton iterations (Nit) per step, 3 ... show discontinuous iterations (Dit) and newton jacobians (jac) per step";
    structureDict["stepInformation"] = d;

    structureDict["generalizedAlpha"] = GetDictionaryWithTypeInfo(data.generalizedAlpha);
    structureDict["explicitIntegration"] = GetDictionaryWithTypeInfo(data.explicitIntegration);
    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(TimeIntegrationSettings& data, const py::dict& d) {
    SetDictionary(data.newton, py::cast<py::dict>(d["newton"]));
    SetDictionary(data.discontinuous, py::cast<py::dict>(d["discontinuous"]));
    data.startTime = py::cast<Real>(d["startTime"]);
    data.endTime = py::cast<Real>(d["endTime"]);
    data.numberOfSteps = py::cast<Index>(d["numberOfSteps"]);
    data.adaptiveStep = py::cast<bool>(d["adaptiveStep"]);
    data.adaptiveStepRecoverySteps = py::cast<Index>(d["adaptiveStepRecoverySteps"]);
    data.adaptiveStepIncrease = py::cast<Real>(d["adaptiveStepIncrease"]);
    data.adaptiveStepDecrease = py::cast<Real>(d["adaptiveStepDecrease"]);
    data.automaticStepSize = py::cast<bool>(d["automaticStepSize"]);
    data.minimumStepSize = py::cast<Real>(d["minimumStepSize"]);
    data.initialStepSize = py::cast<Real>(d["initialStepSize"]);
    data.absoluteTolerance = py::cast<Real>(d["absoluteTolerance"]);
    data.relativeTolerance = py::cast<Real>(d["relativeTolerance"]);
    data.stepSizeSafety = py::cast<Real>(d["stepSizeSafety"]);
    data.stepSizeMaxIncrease = py::cast<Real>(d["stepSizeMaxIncrease"]);
    data.preStepPyExecute = py::cast<std::string>(d["preStepPyExecute"]);
    data.simulateInRealtime = py::cast<bool>(d["simulateInRealtime"]);
    data.realtimeFactor = py::cast<Real>(d["realtimeFactor"]);
    data.verboseMode = py::cast<Index>(d["verboseMode"]);
    data.verboseModeFile = py::cast<Index>(d["verboseModeFile"]);
    data.stepInformation = py::cast<Index>(d["stepInformation"]);
    SetDictionary(data.generalizedAlpha, py::cast<py::dict>(d["generalizedAlpha"]));
    SetDictionary(data.explicitIntegration, py::cast<py::dict>(d["explicitIntegration"]));
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const StaticSolverSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["newton"] = GetDictionaryWithTypeInfo(data.newton);
    structureDict["discontinuous"] = GetDictionaryWithTypeInfo(data.discontinuous);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNumberOfLoadSteps();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of load steps; if numberOfLoadSteps=1, no load steps are used and full forces are applied at once";
    structureDict["numberOfLoadSteps"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLoadStepDuration();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "quasi-time for all load steps (added to current time in load steps)";
    structureDict["loadStepDuration"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLoadStepStart();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "a quasi time, which can be used for the output (first column) as well as for time-dependent forces; quasi-time is increased in every step i by loadStepDuration/numberOfLoadSteps; loadStepTime = loadStepStart + i*loadStepDuration/numberOfLoadSteps, but loadStepStart untouched ==> increment by user";
    structureDict["loadStepStart"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.loadStepGeometric;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if loadStepGeometric=false, the load steps are incremental (arithmetic series, e.g. 0.1,0.2,0.3,...); if true, the load steps are increased in a geometric series, e.g. for n=8 numberOfLoadSteps and d = 1000 loadStepGeometricRange, it follows: 1000^{1/8}/1000=0.00237, 1000^{2/8}/1000=0.00562, 1000^{3/8}/1000=0.0133, ..., 1000^{7/8}/1000=0.422, 1000^{8/8}/1000=1";
    structureDict["loadStepGeometric"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLoadStepGeometricRange();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "if loadStepGeometric=true, the load steps are increased in a geometric series, see loadStepGeometric";
    structureDict["loadStepGeometricRange"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useLoadFactor;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: compute a load factor \\in [0,1] from static step time; all loads are scaled by the load factor; False: loads are always scaled with 1 -- use this option if time dependent loads use a userFunction";
    structureDict["useLoadFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStabilizerODE2term();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "add mass-proportional stabilizer term in \\hac{ODE2} part of jacobian for stabilization (scaled ), e.g. of badly conditioned problems; the diagnoal terms are scaled with stabilizer = (1-loadStepFactor^2), and go to zero at the end of all load steps: loadStepFactor=1 -> stabilizer = 0";
    structureDict["stabilizerODE2term"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.adaptiveStep;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: use step reduction if step fails; False: fixed step size";
    structureDict["adaptiveStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepRecoverySteps();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "Number of steps needed after which steps will be increased after previous step reduction due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepRecoverySteps"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepIncrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "Multiplicative factor (MUST BE > 1) for step size to increase after previous step reduction due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepIncrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAdaptiveStepDecrease();
    d["type"] = "UReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "Multiplicative factor (MUST BE: 0 < factor < 1) for step size to decrese due to discontinuousIteration or Newton errors";
    structureDict["adaptiveStepDecrease"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMinimumStepSize();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "lower limit of step size, before nonlinear solver stops";
    structureDict["minimumStepSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetVerboseMode();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "0 ... no output, 1 ... show errors and load steps, 2 ... show short Newton step information (error), 3 ... show also solution vector, 4 ... show also jacobian, 5 ... show also Jacobian inverse";
    structureDict["verboseMode"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetVerboseModeFile();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "same behaviour as verboseMode, but outputs all solver information to file";
    structureDict["verboseModeFile"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStepInformation();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "0 ... only current step time, 1 ... show time to go, 2 ... show newton iterations (Nit) per step, 3 ... show discontinuous iterations (Dit) and newton jacobians (jac) per step";
    structureDict["stepInformation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.preStepPyExecute;
    d["type"] = "String";
    d["size"] = std::vector<int>{1};
    d["description"] = "DEPRECATED, use mbs.SetPreStepUserFunction(...); Python code to be executed prior to every load step and after last step, e.g. for postprocessing";
    structureDict["preStepPyExecute"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(StaticSolverSettings& data, const py::dict& d) {
    SetDictionary(data.newton, py::cast<py::dict>(d["newton"]));
    SetDictionary(data.discontinuous, py::cast<py::dict>(d["discontinuous"]));
    data.numberOfLoadSteps = py::cast<Index>(d["numberOfLoadSteps"]);
    data.loadStepDuration = py::cast<Real>(d["loadStepDuration"]);
    data.loadStepStart = py::cast<Real>(d["loadStepStart"]);
    data.loadStepGeometric = py::cast<bool>(d["loadStepGeometric"]);
    data.loadStepGeometricRange = py::cast<Real>(d["loadStepGeometricRange"]);
    data.useLoadFactor = py::cast<bool>(d["useLoadFactor"]);
    data.stabilizerODE2term = py::cast<Real>(d["stabilizerODE2term"]);
    data.adaptiveStep = py::cast<bool>(d["adaptiveStep"]);
    data.adaptiveStepRecoverySteps = py::cast<Index>(d["adaptiveStepRecoverySteps"]);
    data.adaptiveStepIncrease = py::cast<Real>(d["adaptiveStepIncrease"]);
    data.adaptiveStepDecrease = py::cast<Real>(d["adaptiveStepDecrease"]);
    data.minimumStepSize = py::cast<Real>(d["minimumStepSize"]);
    data.verboseMode = py::cast<Index>(d["verboseMode"]);
    data.verboseModeFile = py::cast<Index>(d["verboseModeFile"]);
    data.stepInformation = py::cast<Index>(d["stepInformation"]);
    data.preStepPyExecute = py::cast<std::string>(d["preStepPyExecute"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const LinearSolverSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetPivotTreshold();
    d["type"] = "PReal";
    d["size"] = std::vector<int>{1};
    d["description"] = "treshold for dense linear solver, can be used to detect close to singular solutions, setting this to, e.g., 1e-12; solver then reports on equations that are causing close to singularity";
    structureDict["pivotTreshold"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.ignoreRedundantConstraints;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "[ONLY implemented for dense matrices] False: standard way, fails if redundant equations or singular matrices occur; True: if redundant constraints appear, the solver tries to resolve them by setting according Lagrange multipliers to zero; in case of redundant constraints, this may help, but it may lead to erroneous behaviour";
    structureDict["ignoreRedundantConstraints"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.ignoreSingularJacobian;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "[ONLY implemented for dense matrices] False: standard way, fails if jacobian is singular; True: if singularities appear in jacobian (e.g. no equation attributed to a node, redundant equations, zero mass matrix, zero eigenvalue for static problem, etc.), the jacobian inverse is resolved such that according solution variables are set to zero; this may help, but it MAY LEAD TO ERRONEOUS BEHAVIOUR; for static problems, this may suppress static motion or resolve problems in case of instabilities, but should in general be considered with care!";
    structureDict["ignoreSingularJacobian"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showCausingItems;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "False: no output, if solver fails; True: if redundant equations appear, they are resolved such that according solution variables are set to zero; in case of redundant constraints, this may help, but it may lead to erroneous behaviour; for static problems, this may suppress static motion or resolve problems in case of instabilities, but should in general be considered with care!";
    structureDict["showCausingItems"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(LinearSolverSettings& data, const py::dict& d) {
    data.pivotTreshold = py::cast<Real>(d["pivotTreshold"]);
    data.ignoreRedundantConstraints = py::cast<bool>(d["ignoreRedundantConstraints"]);
    data.ignoreSingularJacobian = py::cast<bool>(d["ignoreSingularJacobian"]);
    data.showCausingItems = py::cast<bool>(d["showCausingItems"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const SimulationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["timeIntegration"] = GetDictionaryWithTypeInfo(data.timeIntegration);
    structureDict["solutionSettings"] = GetDictionaryWithTypeInfo(data.solutionSettings);
    structureDict["staticSolver"] = GetDictionaryWithTypeInfo(data.staticSolver);
    structureDict["linearSolverSettings"] = GetDictionaryWithTypeInfo(data.linearSolverSettings);
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.linearSolverType;
    d["type"] = "LinearSolverType";
    d["size"] = std::vector<int>{1};
    d["description"] = "selection of numerical linear solver: exu.LinearSolverType.EXUdense (dense matrix inverse), exu.LinearSolverType.EigenSparse (sparse matrix LU-factorization), ... (enumeration type)";
    structureDict["linearSolverType"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.cleanUpMemory;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: solvers will free memory at exit (recommended for large systems); False: keep allocated memory for repeated computations to increase performance";
    structureDict["cleanUpMemory"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.displayStatistics;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "display general computation information at end of time step (steps, iterations, function calls, step rejections, ...";
    structureDict["displayStatistics"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.displayComputationTime;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "display computation time statistics at end of solving";
    structureDict["displayComputationTime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.pauseAfterEachStep;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "pause after every time step or static load step(user press SPACE)";
    structureDict["pauseAfterEachStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetOutputPrecision();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "precision for floating point numbers written to console; e.g. values written by solver";
    structureDict["outputPrecision"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetNumberOfThreads();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of threads used for parallel computation (1 == scalar processing); not yet implemented (status: Nov 2019)";
    structureDict["numberOfThreads"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(SimulationSettings& data, const py::dict& d) {
    SetDictionary(data.timeIntegration, py::cast<py::dict>(d["timeIntegration"]));
    SetDictionary(data.solutionSettings, py::cast<py::dict>(d["solutionSettings"]));
    SetDictionary(data.staticSolver, py::cast<py::dict>(d["staticSolver"]));
    SetDictionary(data.linearSolverSettings, py::cast<py::dict>(d["linearSolverSettings"]));
    data.linearSolverType = py::cast<LinearSolverType>(d["linearSolverType"]);
    data.cleanUpMemory = py::cast<bool>(d["cleanUpMemory"]);
    data.displayStatistics = py::cast<bool>(d["displayStatistics"]);
    data.displayComputationTime = py::cast<bool>(d["displayComputationTime"]);
    data.pauseAfterEachStep = py::cast<bool>(d["pauseAfterEachStep"]);
    data.outputPrecision = py::cast<Index>(d["outputPrecision"]);
    data.numberOfThreads = py::cast<Index>(d["numberOfThreads"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsGeneral& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.graphicsUpdateInterval;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "interval of graphics update during simulation in seconds; 0.1 = 10 frames per second; low numbers might slow down computation speed";
    structureDict["graphicsUpdateInterval"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.autoFitScene;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "automatically fit scene within first second after StartRenderer()";
    structureDict["autoFitScene"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.textSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "general text size (font size) in pixels if not overwritten; if useWindowsMonitorScaleFactor=True, the the textSize is multplied with the windows monitor scaling factor for larger texts on on high resolution monitors; for bitmap fonts, the maximum size of any font (standard/large/huge) is limited to 256 (which is not recommended, especially if you do not have a powerful graphics card)";
    structureDict["textSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTextColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "general text color (default); used for system texts in render window";
    structureDict["textColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useWindowsMonitorScaleFactor;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "the windows monitor scaling is used for increased visibility of texts on high resolution monitors; based on GLFW glfwGetWindowContentScale";
    structureDict["useWindowsMonitorScaleFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useBitmapText;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, texts are displayed using pre-defined bitmaps for the text; may increase the complexity of your scene, e.g., if many (>10000) node numbers shown";
    structureDict["useBitmapText"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.minSceneSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "minimum scene size for initial scene size and for autoFitScene, to avoid division by zero; SET GREATER THAN ZERO";
    structureDict["minSceneSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetBackgroundColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "red, green, blue and alpha values for background color of render window (white=[1,1,1,1]; black = [0,0,0,1])";
    structureDict["backgroundColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetBackgroundColorBottom();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "red, green, blue and alpha values for bottom background color in case that useGradientBackground = True";
    structureDict["backgroundColorBottom"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useGradientBackground;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = use vertical gradient for background; ";
    structureDict["useGradientBackground"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.coordinateSystemSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "size of coordinate system relative to font size";
    structureDict["coordinateSystemSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawCoordinateSystem;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "false = no coordinate system shown";
    structureDict["drawCoordinateSystem"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawWorldBasis;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = draw world basis coordinate system at (0,0,0)";
    structureDict["drawWorldBasis"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.worldBasisSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "size of world basis coordinate system";
    structureDict["worldBasisSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetShowHelpOnStartup();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "seconds to show help message on startup (0=deactivate)";
    structureDict["showHelpOnStartup"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showComputationInfo;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = show (hide) all computation information including EXUDYN and version";
    structureDict["showComputationInfo"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showSolutionInformation;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = show solution information (from simulationSettings.solution)";
    structureDict["showSolutionInformation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showSolverInformation;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = solver name and further information shown in render window";
    structureDict["showSolverInformation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showSolverTime;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = solver current time shown in render window";
    structureDict["showSolverTime"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.renderWindowString;
    d["type"] = "String";
    d["size"] = std::vector<int>{1};
    d["description"] = "string shown in render window (use this, e.g., for debugging, etc.; written below EXUDYN, similar to solutionInformation in SimulationSettings.solutionSettings)";
    structureDict["renderWindowString"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.pointSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global point size (absolute)";
    structureDict["pointSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetCircleTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "global number of segments for circles; if smaller than 2, 2 segments are used (flat)";
    structureDict["circleTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetCylinderTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "global number of segments for cylinders; if smaller than 2, 2 segments are used (flat)";
    structureDict["cylinderTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSphereTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "global number of segments for spheres; if smaller than 2, 2 segments are used (flat)";
    structureDict["sphereTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAxesTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "global number of segments for drawing axes cylinders and cones (reduce this number, e.g. to 4, if many axes are drawn)";
    structureDict["axesTiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.threadSafeGraphicsUpdate;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = updating of visualization is threadsafe, but slower for complicated models; deactivate this to speed up computation, but activate for generation of animations; may be improved in future by adding a safe visualizationUpdate state";
    structureDict["threadSafeGraphicsUpdate"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.useMultiThreadedRendering;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "true = rendering is done in separate thread; false = no separate thread, which may be more stable but has lagging interaction for large models (do not interact with models during simulation); set this parameter before call to exudyn.StartRenderer(); MAC OS: uses always false, because MAC OS does not support multi threaded GLFW";
    structureDict["useMultiThreadedRendering"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsGeneral& data, const py::dict& d) {
    data.graphicsUpdateInterval = py::cast<float>(d["graphicsUpdateInterval"]);
    data.autoFitScene = py::cast<bool>(d["autoFitScene"]);
    data.textSize = py::cast<float>(d["textSize"]);
    data.textColor = py::cast<std::array<float,4>>(d["textColor"]);
    data.useWindowsMonitorScaleFactor = py::cast<bool>(d["useWindowsMonitorScaleFactor"]);
    data.useBitmapText = py::cast<bool>(d["useBitmapText"]);
    data.minSceneSize = py::cast<float>(d["minSceneSize"]);
    data.backgroundColor = py::cast<std::array<float,4>>(d["backgroundColor"]);
    data.backgroundColorBottom = py::cast<std::array<float,4>>(d["backgroundColorBottom"]);
    data.useGradientBackground = py::cast<bool>(d["useGradientBackground"]);
    data.coordinateSystemSize = py::cast<float>(d["coordinateSystemSize"]);
    data.drawCoordinateSystem = py::cast<bool>(d["drawCoordinateSystem"]);
    data.drawWorldBasis = py::cast<bool>(d["drawWorldBasis"]);
    data.worldBasisSize = py::cast<float>(d["worldBasisSize"]);
    data.showHelpOnStartup = py::cast<Index>(d["showHelpOnStartup"]);
    data.showComputationInfo = py::cast<bool>(d["showComputationInfo"]);
    data.showSolutionInformation = py::cast<bool>(d["showSolutionInformation"]);
    data.showSolverInformation = py::cast<bool>(d["showSolverInformation"]);
    data.showSolverTime = py::cast<bool>(d["showSolverTime"]);
    data.renderWindowString = py::cast<std::string>(d["renderWindowString"]);
    data.pointSize = py::cast<float>(d["pointSize"]);
    data.circleTiling = py::cast<Index>(d["circleTiling"]);
    data.cylinderTiling = py::cast<Index>(d["cylinderTiling"]);
    data.sphereTiling = py::cast<Index>(d["sphereTiling"]);
    data.axesTiling = py::cast<Index>(d["axesTiling"]);
    data.threadSafeGraphicsUpdate = py::cast<bool>(d["threadSafeGraphicsUpdate"]);
    data.useMultiThreadedRendering = py::cast<bool>(d["useMultiThreadedRendering"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsContour& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.outputVariableComponent;
    d["type"] = "Int";
    d["size"] = std::vector<int>{1};
    d["description"] = "select the component of the chosen output variable; e.g., for displacements, 3 components are available: 0 == x, 1 == y, 2 == z component; for stresses, 6 components are available, see OutputVariableType description; to draw the norm of a outputVariable, set component to -1; if a certain component is not available by certain objects or nodes, no value is drawn (using default color)";
    structureDict["outputVariableComponent"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.outputVariable;
    d["type"] = "OutputVariableType";
    d["size"] = std::vector<int>{1};
    d["description"] = "selected contour plot output variable type; select OutputVariableType.\\_None to deactivate contour plotting.";
    structureDict["outputVariable"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.minValue;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "minimum value for contour plot; set manually, if automaticRange == False";
    structureDict["minValue"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.maxValue;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "maximum value for contour plot; set manually, if automaticRange == False";
    structureDict["maxValue"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.automaticRange;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, the contour plot value range is chosen automatically to the maximum range";
    structureDict["automaticRange"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.reduceRange;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, the contour plot value range is also reduced; better for static computation; in dynamic computation set this option to false, it can reduce visualization artifacts; you should also set minVal to max(float) and maxVal to min(float)";
    structureDict["reduceRange"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showColorBar;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show the colour bar with minimum and maximum values for the contour plot";
    structureDict["showColorBar"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetColorBarTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of tiles (segements) shown in the colorbar for the contour plot";
    structureDict["colorBarTiling"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsContour& data, const py::dict& d) {
    data.outputVariableComponent = py::cast<int>(d["outputVariableComponent"]);
    data.outputVariable = py::cast<OutputVariableType>(d["outputVariable"]);
    data.minValue = py::cast<float>(d["minValue"]);
    data.maxValue = py::cast<float>(d["maxValue"]);
    data.automaticRange = py::cast<bool>(d["automaticRange"]);
    data.reduceRange = py::cast<bool>(d["reduceRange"]);
    data.showColorBar = py::cast<bool>(d["showColorBar"]);
    data.colorBarTiling = py::cast<Index>(d["colorBarTiling"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsNodes& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the nodes are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the node number is shown";
    structureDict["showNumbers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawNodesAsPoint;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "simplified/faster drawing of nodes; uses general->pointSize as drawing size; if drawNodesAsPoint==True, the basis of the node will be drawn with lines";
    structureDict["drawNodesAsPoint"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showBasis;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show basis (three axes) of coordinate system in 3D nodes";
    structureDict["showBasis"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.basisSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "size of basis for nodes";
    structureDict["basisSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "tiling for node if drawn as sphere; used to lower the amount of triangles to draw each node; if drawn as circle, this value is multiplied with 4";
    structureDict["tiling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global node size; if -1.f, node size is relative to openGL.initialMaxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "default cRGB olor for nodes; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetShowNodalSlopes();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw nodal slope vectors, e.g. in ANCF beam finite elements";
    structureDict["showNodalSlopes"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsNodes& data, const py::dict& d) {
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
    data.drawNodesAsPoint = py::cast<bool>(d["drawNodesAsPoint"]);
    data.showBasis = py::cast<bool>(d["showBasis"]);
    data.basisSize = py::cast<float>(d["basisSize"]);
    data.tiling = py::cast<Index>(d["tiling"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
    data.showNodalSlopes = py::cast<Index>(d["showNodalSlopes"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsBeams& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetAxialTiling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of segments to discretise the beams axis";
    structureDict["axialTiling"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsBeams& data, const py::dict& d) {
    data.axialTiling = py::cast<Index>(d["axialTiling"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsBodies& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the bodies are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the body(=object) number is shown";
    structureDict["showNumbers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultSize();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{3};
    d["description"] = "global body size of xyz-cube";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "default cRGB olor for bodies; 4th value is ";
    structureDict["defaultColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.deformationScaleFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global deformation scale factor; also applies to nodes, if drawn; used for scaled drawing of (linear) finite elements, beams, etc.";
    structureDict["deformationScaleFactor"] = d;

    structureDict["beams"] = GetDictionaryWithTypeInfo(data.beams);
    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsBodies& data, const py::dict& d) {
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
    data.defaultSize = py::cast<std::array<float,3>>(d["defaultSize"]);
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
    data.deformationScaleFactor = py::cast<float>(d["deformationScaleFactor"]);
    SetDictionary(data.beams, py::cast<py::dict>(d["beams"]));
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsConnectors& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the connectors are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the connector(=object) number is shown";
    structureDict["showNumbers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global connector size; if -1.f, connector size is relative to maxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showJointAxes;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether contact joint axes of 3D joints are shown";
    structureDict["showJointAxes"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.jointAxesLength;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global joint axes length";
    structureDict["jointAxesLength"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.jointAxesRadius;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global joint axes radius";
    structureDict["jointAxesRadius"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showContact;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether contact points, lines, etc. are shown";
    structureDict["showContact"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSpringNumberOfWindings();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "number of windings for springs drawn as helical spring";
    structureDict["springNumberOfWindings"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.contactPointsDefaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global contact points size; if -1.f, connector size is relative to maxSceneSize";
    structureDict["contactPointsDefaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "default cRGB olor for connectors; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsConnectors& data, const py::dict& d) {
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.showJointAxes = py::cast<bool>(d["showJointAxes"]);
    data.jointAxesLength = py::cast<float>(d["jointAxesLength"]);
    data.jointAxesRadius = py::cast<float>(d["jointAxesRadius"]);
    data.showContact = py::cast<bool>(d["showContact"]);
    data.springNumberOfWindings = py::cast<Index>(d["springNumberOfWindings"]);
    data.contactPointsDefaultSize = py::cast<float>(d["contactPointsDefaultSize"]);
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsMarkers& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the markers are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the marker numbers are shown";
    structureDict["showNumbers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawSimplified;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw markers with simplified symbols";
    structureDict["drawSimplified"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global marker size; if -1.f, marker size is relative to maxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "default cRGB olor for markers; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsMarkers& data, const py::dict& d) {
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
    data.drawSimplified = py::cast<bool>(d["drawSimplified"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsLoads& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the loads are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the load numbers are shown";
    structureDict["showNumbers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global load size; if -1.f, load size is relative to maxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultRadius;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global radius of load axis if drawn in 3D";
    structureDict["defaultRadius"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.fixedLoadSize;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "if true, the load is drawn with a fixed vector length in direction of the load vector, independently of the load size";
    structureDict["fixedLoadSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawSimplified;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw markers with simplified symbols";
    structureDict["drawSimplified"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.loadSizeFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "if fixedLoadSize=false, then this scaling factor is used to draw the load vector";
    structureDict["loadSizeFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "default cRGB olor for loads; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsLoads& data, const py::dict& d) {
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.defaultRadius = py::cast<float>(d["defaultRadius"]);
    data.fixedLoadSize = py::cast<bool>(d["fixedLoadSize"]);
    data.drawSimplified = py::cast<bool>(d["drawSimplified"]);
    data.loadSizeFactor = py::cast<float>(d["loadSizeFactor"]);
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsSensors& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.show;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the sensors are shown";
    structureDict["show"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showNumbers;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "flag to decide, whether the sensor numbers are shown";
    structureDict["showNumbers"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawSimplified;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw sensors with simplified symbols";
    structureDict["drawSimplified"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.defaultSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "global sensor size; if -1.f, sensor size is relative to maxSceneSize";
    structureDict["defaultSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetDefaultColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "default cRGB olor for sensors; 4th value is alpha-transparency";
    structureDict["defaultColor"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsSensors& data, const py::dict& d) {
    data.show = py::cast<bool>(d["show"]);
    data.showNumbers = py::cast<bool>(d["showNumbers"]);
    data.drawSimplified = py::cast<bool>(d["drawSimplified"]);
    data.defaultSize = py::cast<float>(d["defaultSize"]);
    data.defaultColor = py::cast<std::array<float,4>>(d["defaultColor"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsWindow& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetRenderWindowSize();
    d["type"] = "IndexArray";
    d["size"] = std::vector<int>{2};
    d["description"] = "initial size of OpenGL render window in pixel";
    structureDict["renderWindowSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetStartupTimeout();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "OpenGL render window startup timeout in ms (change might be necessary if CPU is very slow)";
    structureDict["startupTimeout"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.alwaysOnTop;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: OpenGL render window will be always on top of all other windows";
    structureDict["alwaysOnTop"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.maximize;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: OpenGL render window will be maximized at startup";
    structureDict["maximize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showWindow;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: OpenGL render window is shown on startup; False: window will be iconified at startup (e.g. if you are starting multiple computations automatically)";
    structureDict["showWindow"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showMouseCoordinates;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: show OpenGL coordinates and distance to last left mouse button pressed position; switched on/off with key 'F3'";
    structureDict["showMouseCoordinates"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.ignoreKeys;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: ignore keyboard input except escape and 'F2' keys; used for interactive mode, e.g., to perform kinematic analysis; This flag can be switched with key 'F2'";
    structureDict["ignoreKeys"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsWindow& data, const py::dict& d) {
    data.renderWindowSize = py::cast<std::array<Index,2>>(d["renderWindowSize"]);
    data.startupTimeout = py::cast<Index>(d["startupTimeout"]);
    data.alwaysOnTop = py::cast<bool>(d["alwaysOnTop"]);
    data.maximize = py::cast<bool>(d["maximize"]);
    data.showWindow = py::cast<bool>(d["showWindow"]);
    data.showMouseCoordinates = py::cast<bool>(d["showMouseCoordinates"]);
    data.ignoreKeys = py::cast<bool>(d["ignoreKeys"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsOpenGL& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetInitialCenterPoint();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{3};
    d["description"] = "centerpoint of scene (3D) at renderer startup; overwritten if autoFitScene = True";
    structureDict["initialCenterPoint"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.initialZoom;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "initial zoom of scene; overwritten/ignored if autoFitScene = True";
    structureDict["initialZoom"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.initialMaxSceneSize;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "initial maximum scene size (auto: diagonal of cube with maximum scene coordinates); used for 'zoom all' functionality and for visibility of objects; overwritten if autoFitScene = True";
    structureDict["initialMaxSceneSize"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.initialModelRotation;
    d["type"] = "Matrix";
    d["size"] = std::vector<int>{3,3};
    d["description"] = "initial model rotation matrix for OpenGl; in python use e.g.: initialModelRotation=[[1,0,0],[0,1,0],[0,0,1]]";
    structureDict["initialModelRotation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMultiSampling();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "multi sampling turned off (<=1) or turned on to given values (2, 4, 8 or 16); increases the graphics buffers and might crash due to graphics card memory limitations; only works if supported by hardware; if it does not work, try to change 3D graphics hardware settings!";
    structureDict["multiSampling"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lineWidth;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "width of lines used for representation of lines, circles, points, etc.";
    structureDict["lineWidth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lineSmooth;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw lines smooth";
    structureDict["lineSmooth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.textLineWidth;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "width of lines used for representation of text";
    structureDict["textLineWidth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.textLineSmooth;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draw lines for representation of text smooth";
    structureDict["textLineSmooth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showFaces;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show faces of triangles, etc.; using the options showFaces=false and showFaceEdges=true gives are wire frame representation";
    structureDict["showFaces"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.facesTransparent;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: show faces transparent independent of transparency (A)-value in color of objects; allow to show otherwise hidden node/marker/object numbers";
    structureDict["facesTransparent"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.showFaceEdges;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "show edges of faces; using the options showFaces=false and showFaceEdges=true gives are wire frame representation";
    structureDict["showFaceEdges"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.shadeModelSmooth;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: turn on smoothing for shaders, which uses vertex normals to smooth surfaces";
    structureDict["shadeModelSmooth"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaterialAmbientAndDiffuse();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "4f ambient color of material";
    structureDict["materialAmbientAndDiffuse"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.materialShininess;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "shininess of material";
    structureDict["materialShininess"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetMaterialSpecular();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "4f specular color of material";
    structureDict["materialSpecular"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.enableLighting;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "generally enable lighting (otherwise, colors of objects are used); OpenGL: glEnable(GL\\_LIGHTING)";
    structureDict["enableLighting"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lightModelLocalViewer;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "select local viewer for light; maps to OpenGL glLightModeli(GL\\_LIGHT\\_MODEL\\_LOCAL\\_VIEWER,...)";
    structureDict["lightModelLocalViewer"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.lightModelTwoSide;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "enlighten also backside of object; maps to OpenGL glLightModeli(GL\\_LIGHT\\_MODEL\\_TWO\\_SIDE,...)";
    structureDict["lightModelTwoSide"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLightModelAmbient();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "global ambient light; maps to OpenGL glLightModeli(GL\\_LIGHT\\_MODEL\\_AMBIENT,[r,g,b,a])";
    structureDict["lightModelAmbient"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.enableLight0;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "turn on/off light0";
    structureDict["enableLight0"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLight0position();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "4f position vector of GL\\_LIGHT0; 4th value should be 0 for lights like sun, but 1 for directional lights (and for attenuation factor being calculated); see opengl manuals";
    structureDict["light0position"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0ambient;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "ambient value of GL\\_LIGHT0";
    structureDict["light0ambient"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0diffuse;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "diffuse value of GL\\_LIGHT0";
    structureDict["light0diffuse"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0specular;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "specular value of GL\\_LIGHT0";
    structureDict["light0specular"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0constantAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "constant attenuation coefficient of GL\\_LIGHT0, this is a constant factor that attenuates the light source; attenuation factor = 1/(kx +kl*d + kq*d*d); (kc,kl,kq)=(1,0,0) means no attenuation; only used for lights, where last component of light position is 1";
    structureDict["light0constantAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0linearAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "linear attenuation coefficient of GL\\_LIGHT0, this is a linear factor for attenuation of the light source with distance";
    structureDict["light0linearAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light0quadraticAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "quadratic attenuation coefficient of GL\\_LIGHT0, this is a quadratic factor for attenuation of the light source with distance";
    structureDict["light0quadraticAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.enableLight1;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "turn on/off light1";
    structureDict["enableLight1"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetLight1position();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "4f position vector of GL\\_LIGHT0; 4th value should be 0 for lights like sun, but 1 for directional lights (and for attenuation factor being calculated); see opengl manuals";
    structureDict["light1position"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1ambient;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "ambient value of GL\\_LIGHT1";
    structureDict["light1ambient"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1diffuse;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "diffuse value of GL\\_LIGHT1";
    structureDict["light1diffuse"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1specular;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "specular value of GL\\_LIGHT1";
    structureDict["light1specular"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1constantAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "constant attenuation coefficient of GL\\_LIGHT1, this is a constant factor that attenuates the light source; attenuation factor = 1/(kx +kl*d + kq*d*d); only used for lights, where last component of light position is 1";
    structureDict["light1constantAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1linearAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "linear attenuation coefficient of GL\\_LIGHT1, this is a linear factor for attenuation of the light source with distance";
    structureDict["light1linearAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.light1quadraticAttenuation;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "quadratic attenuation coefficient of GL\\_LIGHT1, this is a quadratic factor for attenuation of the light source with distance";
    structureDict["light1quadraticAttenuation"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawFaceNormals;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draws triangle normals, e.g. at center of triangles; used for debugging of faces";
    structureDict["drawFaceNormals"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawVertexNormals;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "draws vertex normals; used for debugging";
    structureDict["drawVertexNormals"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.drawNormalsLength;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "length of normals; used for debugging";
    structureDict["drawNormalsLength"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsOpenGL& data, const py::dict& d) {
    data.initialCenterPoint = py::cast<std::array<float,3>>(d["initialCenterPoint"]);
    data.initialZoom = py::cast<float>(d["initialZoom"]);
    data.initialMaxSceneSize = py::cast<float>(d["initialMaxSceneSize"]);
    data.initialModelRotation = py::cast<StdArray33F>(d["initialModelRotation"]);
    data.multiSampling = py::cast<Index>(d["multiSampling"]);
    data.lineWidth = py::cast<float>(d["lineWidth"]);
    data.lineSmooth = py::cast<bool>(d["lineSmooth"]);
    data.textLineWidth = py::cast<float>(d["textLineWidth"]);
    data.textLineSmooth = py::cast<bool>(d["textLineSmooth"]);
    data.showFaces = py::cast<bool>(d["showFaces"]);
    data.facesTransparent = py::cast<bool>(d["facesTransparent"]);
    data.showFaceEdges = py::cast<bool>(d["showFaceEdges"]);
    data.shadeModelSmooth = py::cast<bool>(d["shadeModelSmooth"]);
    data.materialAmbientAndDiffuse = py::cast<std::array<float,4>>(d["materialAmbientAndDiffuse"]);
    data.materialShininess = py::cast<float>(d["materialShininess"]);
    data.materialSpecular = py::cast<std::array<float,4>>(d["materialSpecular"]);
    data.enableLighting = py::cast<bool>(d["enableLighting"]);
    data.lightModelLocalViewer = py::cast<bool>(d["lightModelLocalViewer"]);
    data.lightModelTwoSide = py::cast<bool>(d["lightModelTwoSide"]);
    data.lightModelAmbient = py::cast<std::array<float,4>>(d["lightModelAmbient"]);
    data.enableLight0 = py::cast<bool>(d["enableLight0"]);
    data.light0position = py::cast<std::array<float,4>>(d["light0position"]);
    data.light0ambient = py::cast<float>(d["light0ambient"]);
    data.light0diffuse = py::cast<float>(d["light0diffuse"]);
    data.light0specular = py::cast<float>(d["light0specular"]);
    data.light0constantAttenuation = py::cast<float>(d["light0constantAttenuation"]);
    data.light0linearAttenuation = py::cast<float>(d["light0linearAttenuation"]);
    data.light0quadraticAttenuation = py::cast<float>(d["light0quadraticAttenuation"]);
    data.enableLight1 = py::cast<bool>(d["enableLight1"]);
    data.light1position = py::cast<std::array<float,4>>(d["light1position"]);
    data.light1ambient = py::cast<float>(d["light1ambient"]);
    data.light1diffuse = py::cast<float>(d["light1diffuse"]);
    data.light1specular = py::cast<float>(d["light1specular"]);
    data.light1constantAttenuation = py::cast<float>(d["light1constantAttenuation"]);
    data.light1linearAttenuation = py::cast<float>(d["light1linearAttenuation"]);
    data.light1quadraticAttenuation = py::cast<float>(d["light1quadraticAttenuation"]);
    data.drawFaceNormals = py::cast<bool>(d["drawFaceNormals"]);
    data.drawVertexNormals = py::cast<bool>(d["drawVertexNormals"]);
    data.drawNormalsLength = py::cast<float>(d["drawNormalsLength"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsExportImages& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSaveImageTimeOut();
    d["type"] = "PInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "timeout in milliseconds for saving a frame as image to disk; this is the amount of time waited for redrawing; increase for very complex scenes";
    structureDict["saveImageTimeOut"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.saveImageFileName;
    d["type"] = "FileName";
    d["size"] = std::vector<int>{1};
    d["description"] = "filename (without extension!) and (relative) path for image file(s) with consecutive numbering (e.g., frame0000.tga, frame0001.tga,...); ; directory will be created if it does not exist";
    structureDict["saveImageFileName"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetSaveImageFileCounter();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "current value of the counter which is used to consecutively save frames (images) with consecutive numbers";
    structureDict["saveImageFileCounter"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.saveImageSingleFile;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: only save single files with given filename, not adding numbering; False: add numbering to files, see saveImageFileName";
    structureDict["saveImageSingleFile"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsExportImages& data, const py::dict& d) {
    data.saveImageTimeOut = py::cast<Index>(d["saveImageTimeOut"]);
    data.saveImageFileName = py::cast<std::string>(d["saveImageFileName"]);
    data.saveImageFileCounter = py::cast<Index>(d["saveImageFileCounter"]);
    data.saveImageSingleFile = py::cast<bool>(d["saveImageSingleFile"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VSettingsInteractive& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.keypressRotationStep;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "rotation increment per keypress in degree (full rotation = 360 degree)";
    structureDict["keypressRotationStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.mouseMoveRotationFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "rotation increment per 1 pixel mouse movement in degree";
    structureDict["mouseMoveRotationFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.keypressTranslationStep;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "translation increment per keypress relative to window size";
    structureDict["keypressTranslationStep"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.zoomStepFactor;
    d["type"] = "float";
    d["size"] = std::vector<int>{1};
    d["description"] = "change of zoom per keypress (keypad +/-) or mouse wheel increment";
    structureDict["zoomStepFactor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.highlightItemIndex;
    d["type"] = "Int";
    d["size"] = std::vector<int>{1};
    d["description"] = "index of item that shall be highlighted (e.g., need to find item due to errors); if set -1, no item is highlighted";
    structureDict["highlightItemIndex"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.highlightItemType;
    d["type"] = "ItemType";
    d["size"] = std::vector<int>{1};
    d["description"] = "item type (Node, Object, ...) that shall be highlighted (e.g., need to find item due to errors)";
    structureDict["highlightItemType"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetHighlightMbsNumber();
    d["type"] = "UInt";
    d["size"] = std::vector<int>{1};
    d["description"] = "index of main system (mbs) for which the item shall be highlighted; number is related to the ID in SystemContainer (first mbs = 0, second = 1, ...)";
    structureDict["highlightMbsNumber"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetHighlightColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "cRGB color for highlighted item; 4th value is alpha-transparency";
    structureDict["highlightColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.PyGetHighlightOtherColor();
    d["type"] = "Vector";
    d["size"] = std::vector<int>{4};
    d["description"] = "cRGB color for other items (which are not highlighted); 4th value is alpha-transparency";
    structureDict["highlightOtherColor"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.selectionLeftMouse;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: left mouse click on items and show basic information";
    structureDict["selectionLeftMouse"] = d;

    d = py::dict(); //reset local dict
    d["itemIdentifier"] = std::string(""); //identifier for item
    d["value"] = data.selectionRightMouse;
    d["type"] = "bool";
    d["size"] = std::vector<int>{1};
    d["description"] = "True: right mouse click on items and show dictionary (read only!)";
    structureDict["selectionRightMouse"] = d;

    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VSettingsInteractive& data, const py::dict& d) {
    data.keypressRotationStep = py::cast<float>(d["keypressRotationStep"]);
    data.mouseMoveRotationFactor = py::cast<float>(d["mouseMoveRotationFactor"]);
    data.keypressTranslationStep = py::cast<float>(d["keypressTranslationStep"]);
    data.zoomStepFactor = py::cast<float>(d["zoomStepFactor"]);
    data.highlightItemIndex = py::cast<int>(d["highlightItemIndex"]);
    data.highlightItemType = py::cast<ItemType>(d["highlightItemType"]);
    data.highlightMbsNumber = py::cast<Index>(d["highlightMbsNumber"]);
    data.highlightColor = py::cast<std::array<float,4>>(d["highlightColor"]);
    data.highlightOtherColor = py::cast<std::array<float,4>>(d["highlightOtherColor"]);
    data.selectionLeftMouse = py::cast<bool>(d["selectionLeftMouse"]);
    data.selectionRightMouse = py::cast<bool>(d["selectionRightMouse"]);
  }
  //! AUTO: read access to structure; converting into dictionary
  py::dict GetDictionaryWithTypeInfo(const VisualizationSettings& data) {
    auto structureDict = py::dict();
    auto d = py::dict(); //local dict
    structureDict["general"] = GetDictionaryWithTypeInfo(data.general);
    structureDict["contour"] = GetDictionaryWithTypeInfo(data.contour);
    structureDict["nodes"] = GetDictionaryWithTypeInfo(data.nodes);
    structureDict["bodies"] = GetDictionaryWithTypeInfo(data.bodies);
    structureDict["connectors"] = GetDictionaryWithTypeInfo(data.connectors);
    structureDict["markers"] = GetDictionaryWithTypeInfo(data.markers);
    structureDict["loads"] = GetDictionaryWithTypeInfo(data.loads);
    structureDict["sensors"] = GetDictionaryWithTypeInfo(data.sensors);
    structureDict["window"] = GetDictionaryWithTypeInfo(data.window);
    structureDict["openGL"] = GetDictionaryWithTypeInfo(data.openGL);
    structureDict["interactive"] = GetDictionaryWithTypeInfo(data.interactive);
    structureDict["exportImages"] = GetDictionaryWithTypeInfo(data.exportImages);
    return structureDict;
  }
  //! AUTO: write access to data structure; converting dictionary d into structure
  void SetDictionary(VisualizationSettings& data, const py::dict& d) {
    SetDictionary(data.general, py::cast<py::dict>(d["general"]));
    SetDictionary(data.contour, py::cast<py::dict>(d["contour"]));
    SetDictionary(data.nodes, py::cast<py::dict>(d["nodes"]));
    SetDictionary(data.bodies, py::cast<py::dict>(d["bodies"]));
    SetDictionary(data.connectors, py::cast<py::dict>(d["connectors"]));
    SetDictionary(data.markers, py::cast<py::dict>(d["markers"]));
    SetDictionary(data.loads, py::cast<py::dict>(d["loads"]));
    SetDictionary(data.sensors, py::cast<py::dict>(d["sensors"]));
    SetDictionary(data.window, py::cast<py::dict>(d["window"]));
    SetDictionary(data.openGL, py::cast<py::dict>(d["openGL"]));
    SetDictionary(data.interactive, py::cast<py::dict>(d["interactive"]));
    SetDictionary(data.exportImages, py::cast<py::dict>(d["exportImages"]));
  }
} //namespace EPyUtils 


#endif //#ifdef include once...
