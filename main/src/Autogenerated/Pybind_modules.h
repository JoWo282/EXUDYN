// AUTO:  ++++++++++++++++++++++
// AUTO:  pybind11 module includes; generated by Johannes Gerstmayr
// AUTO:  last modified = 2020-05-08
// AUTO:  ++++++++++++++++++++++

    //++++++++++++++++++++++++++++++++
    py::class_<SolutionSettings>(m, "SolutionSettings") // AUTO: 
        .def(py::init<>())
        .def_readwrite("writeSolutionToFile", &SolutionSettings::writeSolutionToFile)
        .def_readwrite("appendToFile", &SolutionSettings::appendToFile)
        .def_readwrite("writeFileHeader", &SolutionSettings::writeFileHeader)
        .def_readwrite("writeFileFooter", &SolutionSettings::writeFileFooter)
        .def_readwrite("solutionWritePeriod", &SolutionSettings::solutionWritePeriod)
        .def_readwrite("sensorsAppendToFile", &SolutionSettings::sensorsAppendToFile)
        .def_readwrite("sensorsWriteFileHeader", &SolutionSettings::sensorsWriteFileHeader)
        .def_readwrite("sensorsWritePeriod", &SolutionSettings::sensorsWritePeriod)
        .def_readwrite("exportVelocities", &SolutionSettings::exportVelocities)
        .def_readwrite("exportAccelerations", &SolutionSettings::exportAccelerations)
        .def_readwrite("exportAlgebraicCoordinates", &SolutionSettings::exportAlgebraicCoordinates)
        .def_readwrite("exportDataCoordinates", &SolutionSettings::exportDataCoordinates)
        .def_readwrite("coordinatesSolutionFileName", &SolutionSettings::coordinatesSolutionFileName)
        .def_readwrite("solverInformationFileName", &SolutionSettings::solverInformationFileName)
        .def_readwrite("solutionInformation", &SolutionSettings::solutionInformation)
        .def_readwrite("outputPrecision", &SolutionSettings::outputPrecision)
        .def_readwrite("recordImagesInterval", &SolutionSettings::recordImagesInterval)
        // AUTO: access functions for SolutionSettings
        .def("__repr__", [](const SolutionSettings &item) { return "<SolutionSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<NumericalDifferentiationSettings>(m, "NumericalDifferentiationSettings") // AUTO: 
        .def(py::init<>())
        .def_readwrite("relativeEpsilon", &NumericalDifferentiationSettings::relativeEpsilon)
        .def_readwrite("minimumCoordinateSize", &NumericalDifferentiationSettings::minimumCoordinateSize)
        .def_readwrite("doSystemWideDifferentiation", &NumericalDifferentiationSettings::doSystemWideDifferentiation)
        .def_readwrite("addReferenceCoordinatesToEpsilon", &NumericalDifferentiationSettings::addReferenceCoordinatesToEpsilon)
        // AUTO: access functions for NumericalDifferentiationSettings
        .def("__repr__", [](const NumericalDifferentiationSettings &item) { return "<NumericalDifferentiationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<NewtonSettings>(m, "NewtonSettings") // AUTO: 
        .def(py::init<>())
        .def_readwrite("numericalDifferentiation", &NewtonSettings::numericalDifferentiation)
        .def_readwrite("useNumericalDifferentiation", &NewtonSettings::useNumericalDifferentiation)
        .def_readwrite("useNewtonSolver", &NewtonSettings::useNewtonSolver)
        .def_readwrite("relativeTolerance", &NewtonSettings::relativeTolerance)
        .def_readwrite("absoluteTolerance", &NewtonSettings::absoluteTolerance)
        .def_readwrite("weightTolerancePerCoordinate", &NewtonSettings::weightTolerancePerCoordinate)
        .def_readwrite("newtonResidualMode", &NewtonSettings::newtonResidualMode)
        .def_readwrite("adaptInitialResidual", &NewtonSettings::adaptInitialResidual)
        .def_readwrite("modifiedNewtonContractivity", &NewtonSettings::modifiedNewtonContractivity)
        .def_readwrite("useModifiedNewton", &NewtonSettings::useModifiedNewton)
        .def_readwrite("modifiedNewtonJacUpdatePerStep", &NewtonSettings::modifiedNewtonJacUpdatePerStep)
        .def_readwrite("maxIterations", &NewtonSettings::maxIterations)
        .def_readwrite("maxModifiedNewtonIterations", &NewtonSettings::maxModifiedNewtonIterations)
        .def_readwrite("maxModifiedNewtonRestartIterations", &NewtonSettings::maxModifiedNewtonRestartIterations)
        .def_readwrite("maximumSolutionNorm", &NewtonSettings::maximumSolutionNorm)
        .def_readwrite("maxDiscontinuousIterations", &NewtonSettings::maxDiscontinuousIterations)
        .def_readwrite("ignoreMaxDiscontinuousIterations", &NewtonSettings::ignoreMaxDiscontinuousIterations)
        .def_readwrite("discontinuousIterationTolerance", &NewtonSettings::discontinuousIterationTolerance)
        .def_readwrite("stepInformation", &NewtonSettings::stepInformation)
        // AUTO: access functions for NewtonSettings
        .def("__repr__", [](const NewtonSettings &item) { return "<NewtonSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<GeneralizedAlphaSettings>(m, "GeneralizedAlphaSettings") // AUTO: 
        .def(py::init<>())
        .def_readwrite("newmarkBeta", &GeneralizedAlphaSettings::newmarkBeta)
        .def_readwrite("newmarkGamma", &GeneralizedAlphaSettings::newmarkGamma)
        .def_readwrite("useIndex2Constraints", &GeneralizedAlphaSettings::useIndex2Constraints)
        .def_readwrite("useNewmark", &GeneralizedAlphaSettings::useNewmark)
        .def_readwrite("spectralRadius", &GeneralizedAlphaSettings::spectralRadius)
        .def_readwrite("computeInitialAccelerations", &GeneralizedAlphaSettings::computeInitialAccelerations)
        // AUTO: access functions for GeneralizedAlphaSettings
        .def("__repr__", [](const GeneralizedAlphaSettings &item) { return "<GeneralizedAlphaSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<TimeIntegrationSettings>(m, "TimeIntegrationSettings") // AUTO: 
        .def(py::init<>())
        .def_readwrite("newton", &TimeIntegrationSettings::newton)
        .def_readwrite("startTime", &TimeIntegrationSettings::startTime)
        .def_readwrite("endTime", &TimeIntegrationSettings::endTime)
        .def_readwrite("numberOfSteps", &TimeIntegrationSettings::numberOfSteps)
        .def_readwrite("adaptiveStep", &TimeIntegrationSettings::adaptiveStep)
        .def_readwrite("minimumStepSize", &TimeIntegrationSettings::minimumStepSize)
        .def_readwrite("verboseMode", &TimeIntegrationSettings::verboseMode)
        .def_readwrite("verboseModeFile", &TimeIntegrationSettings::verboseModeFile)
        .def_readwrite("generalizedAlpha", &TimeIntegrationSettings::generalizedAlpha)
        .def_readwrite("preStepPyExecute", &TimeIntegrationSettings::preStepPyExecute)
        // AUTO: access functions for TimeIntegrationSettings
        .def("__repr__", [](const TimeIntegrationSettings &item) { return "<TimeIntegrationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<StaticSolverSettings>(m, "StaticSolverSettings") // AUTO: 
        .def(py::init<>())
        .def_readwrite("newton", &StaticSolverSettings::newton)
        .def_readwrite("numberOfLoadSteps", &StaticSolverSettings::numberOfLoadSteps)
        .def_readwrite("loadStepDuration", &StaticSolverSettings::loadStepDuration)
        .def_readwrite("loadStepStart", &StaticSolverSettings::loadStepStart)
        .def_readwrite("loadStepGeometric", &StaticSolverSettings::loadStepGeometric)
        .def_readwrite("loadStepGeometricRange", &StaticSolverSettings::loadStepGeometricRange)
        .def_readwrite("useLoadFactor", &StaticSolverSettings::useLoadFactor)
        .def_readwrite("stabilizerODE2term", &StaticSolverSettings::stabilizerODE2term)
        .def_readwrite("adaptiveStep", &StaticSolverSettings::adaptiveStep)
        .def_readwrite("minimumStepSize", &StaticSolverSettings::minimumStepSize)
        .def_readwrite("verboseMode", &StaticSolverSettings::verboseMode)
        .def_readwrite("verboseModeFile", &StaticSolverSettings::verboseModeFile)
        .def_readwrite("preStepPyExecute", &StaticSolverSettings::preStepPyExecute)
        // AUTO: access functions for StaticSolverSettings
        .def("__repr__", [](const StaticSolverSettings &item) { return "<StaticSolverSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SimulationSettings>(m, "SimulationSettings") // AUTO: 
        .def(py::init<>())
        .def_readwrite("timeIntegration", &SimulationSettings::timeIntegration)
        .def_readwrite("solutionSettings", &SimulationSettings::solutionSettings)
        .def_readwrite("staticSolver", &SimulationSettings::staticSolver)
        .def_readwrite("linearSolverType", &SimulationSettings::linearSolverType)
        .def_readwrite("cleanUpMemory", &SimulationSettings::cleanUpMemory)
        .def_readwrite("displayStatistics", &SimulationSettings::displayStatistics)
        .def_readwrite("displayComputationTime", &SimulationSettings::displayComputationTime)
        .def_readwrite("pauseAfterEachStep", &SimulationSettings::pauseAfterEachStep)
        .def_readwrite("outputPrecision", &SimulationSettings::outputPrecision)
        .def_readwrite("numberOfThreads", &SimulationSettings::numberOfThreads)
        // AUTO: access functions for SimulationSettings
        .def("__repr__", [](const SimulationSettings &item) { return "<SimulationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionaryWithTypeInfo", [](const SimulationSettings &item) { return EPyUtils::GetDictionaryWithTypeInfo(item); }) //!< AUTO: add read as dictionary with type information access
        .def("SetDictionary", [](SimulationSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsGeneral>(m, "VSettingsGeneral") // AUTO: 
        .def(py::init<>())
        .def_readwrite("graphicsUpdateInterval", &VSettingsGeneral::graphicsUpdateInterval)
        .def_readwrite("autoFitScene", &VSettingsGeneral::autoFitScene)
        .def_readwrite("textSize", &VSettingsGeneral::textSize)
        .def_readwrite("minSceneSize", &VSettingsGeneral::minSceneSize)
        .def_property("backgroundColor", &VSettingsGeneral::PyGetBackgroundColor, &VSettingsGeneral::PySetBackgroundColor)
        .def_readwrite("coordinateSystemSize", &VSettingsGeneral::coordinateSystemSize)
        .def_readwrite("drawCoordinateSystem", &VSettingsGeneral::drawCoordinateSystem)
        .def_readwrite("showComputationInfo", &VSettingsGeneral::showComputationInfo)
        .def_readwrite("pointSize", &VSettingsGeneral::pointSize)
        .def_readwrite("circleTiling", &VSettingsGeneral::circleTiling)
        .def_readwrite("cylinderTiling", &VSettingsGeneral::cylinderTiling)
        .def_readwrite("sphereTiling", &VSettingsGeneral::sphereTiling)
        .def_readwrite("axesTiling", &VSettingsGeneral::axesTiling)
        // AUTO: access functions for VSettingsGeneral
        .def("__repr__", [](const VSettingsGeneral &item) { return "<VSettingsGeneral:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsWindow>(m, "VSettingsWindow") // AUTO: 
        .def(py::init<>())
        .def_property("renderWindowSize", &VSettingsWindow::PyGetRenderWindowSize, &VSettingsWindow::PySetRenderWindowSize)
        .def_readwrite("startupTimeout", &VSettingsWindow::startupTimeout)
        .def_readwrite("alwaysOnTop", &VSettingsWindow::alwaysOnTop)
        .def_readwrite("maximize", &VSettingsWindow::maximize)
        .def_readwrite("showWindow", &VSettingsWindow::showWindow)
        .def_readwrite("keypressRotationStep", &VSettingsWindow::keypressRotationStep)
        .def_readwrite("mouseMoveRotationFactor", &VSettingsWindow::mouseMoveRotationFactor)
        .def_readwrite("keypressTranslationStep", &VSettingsWindow::keypressTranslationStep)
        .def_readwrite("zoomStepFactor", &VSettingsWindow::zoomStepFactor)
        // AUTO: access functions for VSettingsWindow
        .def("__repr__", [](const VSettingsWindow &item) { return "<VSettingsWindow:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsOpenGL>(m, "VSettingsOpenGL") // AUTO: 
        .def(py::init<>())
        .def_property("initialCenterPoint", &VSettingsOpenGL::PyGetInitialCenterPoint, &VSettingsOpenGL::PySetInitialCenterPoint)
        .def_readwrite("initialZoom", &VSettingsOpenGL::initialZoom)
        .def_readwrite("initialMaxSceneSize", &VSettingsOpenGL::initialMaxSceneSize)
        .def_readwrite("initialModelRotation", &VSettingsOpenGL::initialModelRotation)
        .def_readwrite("multiSampling", &VSettingsOpenGL::multiSampling)
        .def_readwrite("lineWidth", &VSettingsOpenGL::lineWidth)
        .def_readwrite("lineSmooth", &VSettingsOpenGL::lineSmooth)
        .def_readwrite("textLineWidth", &VSettingsOpenGL::textLineWidth)
        .def_readwrite("textLineSmooth", &VSettingsOpenGL::textLineSmooth)
        .def_readwrite("showFaces", &VSettingsOpenGL::showFaces)
        .def_readwrite("showFaceEdges", &VSettingsOpenGL::showFaceEdges)
        .def_readwrite("shadeModelSmooth", &VSettingsOpenGL::shadeModelSmooth)
        .def_property("materialSpecular", &VSettingsOpenGL::PyGetMaterialSpecular, &VSettingsOpenGL::PySetMaterialSpecular)
        .def_readwrite("materialShininess", &VSettingsOpenGL::materialShininess)
        .def_readwrite("enableLight0", &VSettingsOpenGL::enableLight0)
        .def_property("light0position", &VSettingsOpenGL::PyGetLight0position, &VSettingsOpenGL::PySetLight0position)
        .def_readwrite("light0ambient", &VSettingsOpenGL::light0ambient)
        .def_readwrite("light0diffuse", &VSettingsOpenGL::light0diffuse)
        .def_readwrite("light0specular", &VSettingsOpenGL::light0specular)
        .def_readwrite("enableLight1", &VSettingsOpenGL::enableLight1)
        .def_property("light1position", &VSettingsOpenGL::PyGetLight1position, &VSettingsOpenGL::PySetLight1position)
        .def_readwrite("light1ambient", &VSettingsOpenGL::light1ambient)
        .def_readwrite("light1diffuse", &VSettingsOpenGL::light1diffuse)
        .def_readwrite("light1specular", &VSettingsOpenGL::light1specular)
        .def_readwrite("drawFaceNormals", &VSettingsOpenGL::drawFaceNormals)
        .def_readwrite("drawVertexNormals", &VSettingsOpenGL::drawVertexNormals)
        .def_readwrite("drawNormalsLength", &VSettingsOpenGL::drawNormalsLength)
        // AUTO: access functions for VSettingsOpenGL
        .def("__repr__", [](const VSettingsOpenGL &item) { return "<VSettingsOpenGL:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsContour>(m, "VSettingsContour") // AUTO: 
        .def(py::init<>())
        .def_readwrite("outputVariableComponent", &VSettingsContour::outputVariableComponent)
        .def_readwrite("outputVariable", &VSettingsContour::outputVariable)
        .def_readwrite("minValue", &VSettingsContour::minValue)
        .def_readwrite("maxValue", &VSettingsContour::maxValue)
        .def_readwrite("automaticRange", &VSettingsContour::automaticRange)
        .def_readwrite("showColorBar", &VSettingsContour::showColorBar)
        .def_readwrite("colorBarTiling", &VSettingsContour::colorBarTiling)
        // AUTO: access functions for VSettingsContour
        .def("__repr__", [](const VSettingsContour &item) { return "<VSettingsContour:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsExportImages>(m, "VSettingsExportImages") // AUTO: 
        .def(py::init<>())
        .def_readwrite("saveImageTimeOut", &VSettingsExportImages::saveImageTimeOut)
        .def_readwrite("saveImageFileName", &VSettingsExportImages::saveImageFileName)
        .def_readwrite("saveImageFileCounter", &VSettingsExportImages::saveImageFileCounter)
        .def_readwrite("saveImageSingleFile", &VSettingsExportImages::saveImageSingleFile)
        // AUTO: access functions for VSettingsExportImages
        .def("__repr__", [](const VSettingsExportImages &item) { return "<VSettingsExportImages:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsNodes>(m, "VSettingsNodes") // AUTO: 
        .def(py::init<>())
        .def_readwrite("show", &VSettingsNodes::show)
        .def_readwrite("showNumbers", &VSettingsNodes::showNumbers)
        .def_readwrite("drawNodesAsPoint", &VSettingsNodes::drawNodesAsPoint)
        .def_readwrite("showBasis", &VSettingsNodes::showBasis)
        .def_readwrite("basisSize", &VSettingsNodes::basisSize)
        .def_readwrite("tiling", &VSettingsNodes::tiling)
        .def_readwrite("defaultSize", &VSettingsNodes::defaultSize)
        .def_property("defaultColor", &VSettingsNodes::PyGetDefaultColor, &VSettingsNodes::PySetDefaultColor)
        .def_readwrite("showNodalSlopes", &VSettingsNodes::showNodalSlopes)
        // AUTO: access functions for VSettingsNodes
        .def("__repr__", [](const VSettingsNodes &item) { return "<VSettingsNodes:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsBeams>(m, "VSettingsBeams") // AUTO: 
        .def(py::init<>())
        .def_readwrite("axialTiling", &VSettingsBeams::axialTiling)
        // AUTO: access functions for VSettingsBeams
        .def("__repr__", [](const VSettingsBeams &item) { return "<VSettingsBeams:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsBodies>(m, "VSettingsBodies") // AUTO: 
        .def(py::init<>())
        .def_readwrite("show", &VSettingsBodies::show)
        .def_readwrite("showNumbers", &VSettingsBodies::showNumbers)
        .def_property("defaultSize", &VSettingsBodies::PyGetDefaultSize, &VSettingsBodies::PySetDefaultSize)
        .def_property("defaultColor", &VSettingsBodies::PyGetDefaultColor, &VSettingsBodies::PySetDefaultColor)
        .def_readwrite("deformationScaleFactor", &VSettingsBodies::deformationScaleFactor)
        .def_readwrite("beams", &VSettingsBodies::beams)
        // AUTO: access functions for VSettingsBodies
        .def("__repr__", [](const VSettingsBodies &item) { return "<VSettingsBodies:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsConnectors>(m, "VSettingsConnectors") // AUTO: 
        .def(py::init<>())
        .def_readwrite("show", &VSettingsConnectors::show)
        .def_readwrite("showNumbers", &VSettingsConnectors::showNumbers)
        .def_readwrite("defaultSize", &VSettingsConnectors::defaultSize)
        .def_readwrite("showJointAxes", &VSettingsConnectors::showJointAxes)
        .def_readwrite("jointAxesLength", &VSettingsConnectors::jointAxesLength)
        .def_readwrite("jointAxesRadius", &VSettingsConnectors::jointAxesRadius)
        .def_readwrite("showContact", &VSettingsConnectors::showContact)
        .def_readwrite("springNumberOfWindings", &VSettingsConnectors::springNumberOfWindings)
        .def_readwrite("contactPointsDefaultSize", &VSettingsConnectors::contactPointsDefaultSize)
        .def_property("defaultColor", &VSettingsConnectors::PyGetDefaultColor, &VSettingsConnectors::PySetDefaultColor)
        // AUTO: access functions for VSettingsConnectors
        .def("__repr__", [](const VSettingsConnectors &item) { return "<VSettingsConnectors:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsMarkers>(m, "VSettingsMarkers") // AUTO: 
        .def(py::init<>())
        .def_readwrite("show", &VSettingsMarkers::show)
        .def_readwrite("showNumbers", &VSettingsMarkers::showNumbers)
        .def_readwrite("drawSimplified", &VSettingsMarkers::drawSimplified)
        .def_readwrite("defaultSize", &VSettingsMarkers::defaultSize)
        .def_property("defaultColor", &VSettingsMarkers::PyGetDefaultColor, &VSettingsMarkers::PySetDefaultColor)
        // AUTO: access functions for VSettingsMarkers
        .def("__repr__", [](const VSettingsMarkers &item) { return "<VSettingsMarkers:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsLoads>(m, "VSettingsLoads") // AUTO: 
        .def(py::init<>())
        .def_readwrite("show", &VSettingsLoads::show)
        .def_readwrite("showNumbers", &VSettingsLoads::showNumbers)
        .def_readwrite("defaultSize", &VSettingsLoads::defaultSize)
        .def_readwrite("defaultRadius", &VSettingsLoads::defaultRadius)
        .def_readwrite("fixedLoadSize", &VSettingsLoads::fixedLoadSize)
        .def_readwrite("drawSimplified", &VSettingsLoads::drawSimplified)
        .def_readwrite("loadSizeFactor", &VSettingsLoads::loadSizeFactor)
        .def_property("defaultColor", &VSettingsLoads::PyGetDefaultColor, &VSettingsLoads::PySetDefaultColor)
        // AUTO: access functions for VSettingsLoads
        .def("__repr__", [](const VSettingsLoads &item) { return "<VSettingsLoads:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VSettingsSensors>(m, "VSettingsSensors") // AUTO: 
        .def(py::init<>())
        .def_readwrite("show", &VSettingsSensors::show)
        .def_readwrite("showNumbers", &VSettingsSensors::showNumbers)
        .def_readwrite("drawSimplified", &VSettingsSensors::drawSimplified)
        .def_readwrite("defaultSize", &VSettingsSensors::defaultSize)
        .def_property("defaultColor", &VSettingsSensors::PyGetDefaultColor, &VSettingsSensors::PySetDefaultColor)
        // AUTO: access functions for VSettingsSensors
        .def("__repr__", [](const VSettingsSensors &item) { return "<VSettingsSensors:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<VisualizationSettings>(m, "VisualizationSettings") // AUTO: 
        .def(py::init<>())
        .def_readwrite("general", &VisualizationSettings::general)
        .def_readwrite("window", &VisualizationSettings::window)
        .def_readwrite("openGL", &VisualizationSettings::openGL)
        .def_readwrite("contour", &VisualizationSettings::contour)
        .def_readwrite("exportImages", &VisualizationSettings::exportImages)
        .def_readwrite("nodes", &VisualizationSettings::nodes)
        .def_readwrite("bodies", &VisualizationSettings::bodies)
        .def_readwrite("connectors", &VisualizationSettings::connectors)
        .def_readwrite("markers", &VisualizationSettings::markers)
        .def_readwrite("loads", &VisualizationSettings::loads)
        .def_readwrite("sensors", &VisualizationSettings::sensors)
        // AUTO: access functions for VisualizationSettings
        .def("__repr__", [](const VisualizationSettings &item) { return "<VisualizationSettings:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        .def("GetDictionaryWithTypeInfo", [](const VisualizationSettings &item) { return EPyUtils::GetDictionaryWithTypeInfo(item); }) //!< AUTO: add read as dictionary with type information access
        .def("SetDictionary", [](VisualizationSettings &item, const py::dict& d) { return EPyUtils::SetDictionary(item, d); }) //!< AUTO: add write from dictionary access
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<CSolverTimer>(m, "CSolverTimer") // AUTO: 
        .def(py::init<>())
        .def_readwrite("useTimer", &CSolverTimer::useTimer)
        .def_readwrite("total", &CSolverTimer::total)
        .def_readwrite("factorization", &CSolverTimer::factorization)
        .def_readwrite("newtonIncrement", &CSolverTimer::newtonIncrement)
        .def_readwrite("integrationFormula", &CSolverTimer::integrationFormula)
        .def_readwrite("ODE2RHS", &CSolverTimer::ODE2RHS)
        .def_readwrite("AERHS", &CSolverTimer::AERHS)
        .def_readwrite("totalJacobian", &CSolverTimer::totalJacobian)
        .def_readwrite("jacobianODE2", &CSolverTimer::jacobianODE2)
        .def_readwrite("jacobianODE2_t", &CSolverTimer::jacobianODE2_t)
        .def_readwrite("jacobianAE", &CSolverTimer::jacobianAE)
        .def_readwrite("massMatrix", &CSolverTimer::massMatrix)
        .def_readwrite("reactionForces", &CSolverTimer::reactionForces)
        .def_readwrite("postNewton", &CSolverTimer::postNewton)
        .def_readwrite("writeSolution", &CSolverTimer::writeSolution)
        .def_readwrite("overhead", &CSolverTimer::overhead)
        .def_readwrite("python", &CSolverTimer::python)
        .def_readwrite("visualization", &CSolverTimer::visualization)
        // AUTO: access functions for CSolverTimer
        .def("Reset", &CSolverTimer::Reset, "reset solver timings to initial state by assigning default values; useSolverTimer sets the useTimer flag")
        .def("Sum", &CSolverTimer::Sum, py::return_value_policy::copy, "compute sum of all timers (except for those counted multiple, e.g., jacobians")
        .def("StartTimer", &CSolverTimer::StartTimer, "start timer function for a given variable; subtracts current CPU time from value")
        .def("StopTimer", &CSolverTimer::StopTimer, "stop timer function for a given variable; adds current CPU time to value")
        .def("ToString", &CSolverTimer::ToString, py::return_value_policy::copy, "converts the current timings to a string")
        .def("__repr__", [](const CSolverTimer &item) { return "<CSolverTimer:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverLocalData>(m, "SolverLocalData") // AUTO: 
        .def(py::init<>())
        .def_readwrite("nODE2", &SolverLocalData::nODE2)
        .def_readwrite("nODE1", &SolverLocalData::nODE1)
        .def_readwrite("nAE", &SolverLocalData::nAE)
        .def_readwrite("nData", &SolverLocalData::nData)
        .def_readwrite("nSys", &SolverLocalData::nSys)
        .def_readwrite("startAE", &SolverLocalData::startAE)
        .def_readwrite("systemResidual", &SolverLocalData::systemResidual)
        .def_readwrite("newtonSolution", &SolverLocalData::newtonSolution)
        .def_readwrite("tempODE2", &SolverLocalData::tempODE2)
        .def_readwrite("temp2ODE2", &SolverLocalData::temp2ODE2)
        .def_readwrite("tempODE2F0", &SolverLocalData::tempODE2F0)
        .def_readwrite("tempODE2F1", &SolverLocalData::tempODE2F1)
        .def_readwrite("startOfStepStateAAlgorithmic", &SolverLocalData::startOfStepStateAAlgorithmic)
        .def_readwrite("aAlgorithmic", &SolverLocalData::aAlgorithmic)
        // AUTO: access functions for SolverLocalData
        .def("CleanUpMemory", &SolverLocalData::CleanUpMemory, "if desired, temporary data is cleaned up to safe memory")
        .def("SetLinearSolverType", &SolverLocalData::SetLinearSolverType, "set linear solver type and matrix version: links system matrices to according dense/sparse versions")
        .def("GetLinearSolverType", &SolverLocalData::GetLinearSolverType, py::return_value_policy::copy, "return current linear solver type (dense/sparse)")
        .def("__repr__", [](const SolverLocalData &item) { return "<SolverLocalData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverIterationData>(m, "SolverIterationData") // AUTO: 
        .def(py::init<>())
        .def_readwrite("maxStepSize", &SolverIterationData::maxStepSize)
        .def_readwrite("minStepSize", &SolverIterationData::minStepSize)
        .def_readwrite("currentStepSize", &SolverIterationData::currentStepSize)
        .def_readwrite("numberOfSteps", &SolverIterationData::numberOfSteps)
        .def_readwrite("currentStepIndex", &SolverIterationData::currentStepIndex)
        .def_readwrite("adaptiveStep", &SolverIterationData::adaptiveStep)
        .def_readwrite("currentTime", &SolverIterationData::currentTime)
        .def_readwrite("startTime", &SolverIterationData::startTime)
        .def_readwrite("endTime", &SolverIterationData::endTime)
        .def_readwrite("discontinuousIteration", &SolverIterationData::discontinuousIteration)
        .def_readwrite("newtonSteps", &SolverIterationData::newtonSteps)
        .def_readwrite("newtonStepsCount", &SolverIterationData::newtonStepsCount)
        .def_readwrite("newtonJacobiCount", &SolverIterationData::newtonJacobiCount)
        .def_readwrite("rejectedModifiedNewtonSteps", &SolverIterationData::rejectedModifiedNewtonSteps)
        .def_readwrite("discontinuousIterationsCount", &SolverIterationData::discontinuousIterationsCount)
        // AUTO: access functions for SolverIterationData
        .def("ToString", &SolverIterationData::ToString, py::return_value_policy::copy, "convert iteration statistics to string; used for displayStatistics option")
        .def("__repr__", [](const SolverIterationData &item) { return "<SolverIterationData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverConvergenceData>(m, "SolverConvergenceData") // AUTO: 
        .def(py::init<>())
        .def_readwrite("stepReductionFailed", &SolverConvergenceData::stepReductionFailed)
        .def_readwrite("discontinuousIterationsFailed", &SolverConvergenceData::discontinuousIterationsFailed)
        .def_readwrite("linearSolverFailed", &SolverConvergenceData::linearSolverFailed)
        .def_readwrite("newtonConverged", &SolverConvergenceData::newtonConverged)
        .def_readwrite("newtonSolutionDiverged", &SolverConvergenceData::newtonSolutionDiverged)
        .def_readwrite("jacobianUpdateRequested", &SolverConvergenceData::jacobianUpdateRequested)
        .def_readwrite("massMatrixNotInvertible", &SolverConvergenceData::massMatrixNotInvertible)
        .def_readwrite("discontinuousIterationError", &SolverConvergenceData::discontinuousIterationError)
        .def_readwrite("residual", &SolverConvergenceData::residual)
        .def_readwrite("lastResidual", &SolverConvergenceData::lastResidual)
        .def_readwrite("contractivity", &SolverConvergenceData::contractivity)
        .def_readwrite("errorCoordinateFactor", &SolverConvergenceData::errorCoordinateFactor)
        // AUTO: access functions for SolverConvergenceData
        .def("InitializeData", &SolverConvergenceData::InitializeData, "initialize SolverConvergenceData by assigning default values")
        .def("__repr__", [](const SolverConvergenceData &item) { return "<SolverConvergenceData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverOutputData>(m, "SolverOutputData") // AUTO: 
        .def(py::init<>())
        .def_readwrite("finishedSuccessfully", &SolverOutputData::finishedSuccessfully)
        .def_readwrite("verboseMode", &SolverOutputData::verboseMode)
        .def_readwrite("verboseModeFile", &SolverOutputData::verboseModeFile)
        .def_readwrite("writeToSolutionFile", &SolverOutputData::writeToSolutionFile)
        .def_readwrite("writeToSolverFile", &SolverOutputData::writeToSolverFile)
        .def_readwrite("sensorValuesTemp", &SolverOutputData::sensorValuesTemp)
        .def_readwrite("lastSolutionWritten", &SolverOutputData::lastSolutionWritten)
        .def_readwrite("lastSensorsWritten", &SolverOutputData::lastSensorsWritten)
        .def_readwrite("lastImageRecorded", &SolverOutputData::lastImageRecorded)
        .def_readwrite("cpuStartTime", &SolverOutputData::cpuStartTime)
        .def_readwrite("cpuLastTimePrinted", &SolverOutputData::cpuLastTimePrinted)
        // AUTO: access functions for SolverOutputData
        .def("InitializeData", &SolverOutputData::InitializeData, "initialize SolverOutputData by assigning default values")
        .def("__repr__", [](const SolverOutputData &item) { return "<SolverOutputData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<SolverFileData>(m, "SolverFileData") // AUTO: 
        .def(py::init<>())
        // AUTO: access functions for SolverFileData
        .def("__repr__", [](const SolverFileData &item) { return "<SolverFileData:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<MainSolverStatic>(m, "MainSolverStatic") // AUTO: 
        .def(py::init<>())
        .def_property("timer", &MainSolverStatic::PyGetTimer, &MainSolverStatic::PySetTimer)
        .def_property("it", &MainSolverStatic::PyGetIt, &MainSolverStatic::PySetIt)
        .def_property("conv", &MainSolverStatic::PyGetConv, &MainSolverStatic::PySetConv)
        .def_property("output", &MainSolverStatic::PyGetOutput, &MainSolverStatic::PySetOutput)
        .def_property("newton", &MainSolverStatic::PyGetNewton, &MainSolverStatic::PySetNewton)
        .def_property("loadStepGeometricFactor", &MainSolverStatic::PyGetLoadStepGeometricFactor, &MainSolverStatic::PySetLoadStepGeometricFactor)
        // AUTO: access functions for MainSolverStatic
        .def("CheckInitialized", &MainSolverStatic::CheckInitialized, py::return_value_policy::copy, "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError", py::arg("mainSystem"))
        .def("ComputeLoadFactor", &MainSolverStatic::ComputeLoadFactor, py::return_value_policy::copy, "for static solver, this is a factor in interval [0,1]; MUST be overwritten", py::arg("simulationSettings"))
        .def("GetSolverName", &MainSolverStatic::GetSolverName, py::return_value_policy::copy, "get solver name - needed for output file header and visualization window")
        .def("IsStaticSolver", &MainSolverStatic::IsStaticSolver, py::return_value_policy::copy, "return true, if static solver; needs to be overwritten in derived class")
        .def("GetSimulationEndTime", &MainSolverStatic::GetSimulationEndTime, py::return_value_policy::copy, "compute simulation end time (depends on static or time integration solver)", py::arg("simulationSettings"))
        .def("ReduceStepSize", &MainSolverStatic::ReduceStepSize, py::return_value_policy::copy, "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("severity"))
        .def("IncreaseStepSize", &MainSolverStatic::IncreaseStepSize, "increase step size if convergence is good", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolver", &MainSolverStatic::InitializeSolver, py::return_value_policy::copy, "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PreInitializeSolverSpecific", &MainSolverStatic::PreInitializeSolverSpecific, "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverOutput", &MainSolverStatic::InitializeSolverOutput, "initialize output files; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverPreChecks", &MainSolverStatic::InitializeSolverPreChecks, py::return_value_policy::copy, "check if system is solvable; initialize dense/sparse computation modes", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverData", &MainSolverStatic::InitializeSolverData, "initialize all data,it,conv; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverInitialConditions", &MainSolverStatic::InitializeSolverInitialConditions, "set/compute initial conditions (solver-specific!); called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostInitializeSolverSpecific", &MainSolverStatic::PostInitializeSolverSpecific, "post-initialize for solver specific tasks; called at the end of InitializeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSystem", &MainSolverStatic::SolveSystem, py::return_value_policy::copy, "solve System: InitializeSolver, SolveSteps, FinalizeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinalizeSolver", &MainSolverStatic::FinalizeSolver, "write concluding information (timer statistics, messages) and close files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSteps", &MainSolverStatic::SolveSteps, py::return_value_policy::copy, "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("UpdateCurrentTime", &MainSolverStatic::UpdateCurrentTime, "update currentTime (and load factor); MUST be overwritten in special solver class", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeStep", &MainSolverStatic::InitializeStep, "initialize static step / time step; python-functions; do some outputs, checks, etc.", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinishStep", &MainSolverStatic::FinishStep, "finish static step / time step; write output of results to file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("DiscontinuousIteration", &MainSolverStatic::DiscontinuousIteration, py::return_value_policy::copy, "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("Newton", &MainSolverStatic::Newton, py::return_value_policy::copy, "perform Newton method for given solver method", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonResidual", &MainSolverStatic::ComputeNewtonResidual, "compute residual for Newton method (e.g. static or time step); store result in systemResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonUpdate", &MainSolverStatic::ComputeNewtonUpdate, "compute update for currentState from newtonSolution (decrement from residual and jacobian)", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonJacobian", &MainSolverStatic::ComputeNewtonJacobian, "compute jacobian for newton method of given solver method; store result in systemJacobian", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteSolutionFileHeader", &MainSolverStatic::WriteSolutionFileHeader, "write unique file header, depending on static/ dynamic simulation", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteCoordinatesToFile", &MainSolverStatic::WriteCoordinatesToFile, "write unique coordinates solution file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IsVerboseCheck", &MainSolverStatic::IsVerboseCheck, py::return_value_policy::copy, "return true, if file or console output is at or above the given level", py::arg("level"))
        .def("VerboseWrite", &MainSolverStatic::VerboseWrite, "write to console and/or file in case of level", py::arg("level"), py::arg("str"))
        .def("GetODE2size", &MainSolverStatic::GetODE2size, py::return_value_policy::reference, "number of ODE2 equations in solver")
        .def("GetODE1size", &MainSolverStatic::GetODE1size, py::return_value_policy::reference, "number of ODE1 equations in solver (not yet implemented)")
        .def("GetAEsize", &MainSolverStatic::GetAEsize, py::return_value_policy::reference, "number of algebraic equations in solver")
        .def("GetDataSize", &MainSolverStatic::GetDataSize, py::return_value_policy::reference, "number of data (history) variables in solver")
        .def("GetSystemJacobian", &MainSolverStatic::GetSystemJacobian, py::return_value_policy::copy, "get locally stored / last computed system jacobian of solver")
        .def("GetSystemMassMatrix", &MainSolverStatic::GetSystemMassMatrix, py::return_value_policy::copy, "get locally stored / last computed mass matrix of solver")
        .def("GetSystemResidual", &MainSolverStatic::GetSystemResidual, py::return_value_policy::copy, "get locally stored / last computed system residual")
        .def("GetNewtonSolution", &MainSolverStatic::GetNewtonSolution, py::return_value_policy::copy, "get locally stored / last computed solution (=increment) of Newton")
        .def("SetSystemJacobian", &MainSolverStatic::SetSystemJacobian, "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE", py::arg("systemJacobian"))
        .def("SetSystemMassMatrix", &MainSolverStatic::SetSystemMassMatrix, "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE", py::arg("systemMassMatrix"))
        .def("SetSystemResidual", &MainSolverStatic::SetSystemResidual, "set locally stored system residual; must have size nODE2+nODE1+nAE", py::arg("systemResidual"))
        .def("ComputeMassMatrix", &MainSolverStatic::ComputeMassMatrix, "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeJacobianODE2RHS", &MainSolverStatic::ComputeJacobianODE2RHS, "set systemJacobian to zero and add jacobian (multiplied with factor) of ODE2RHS to systemJacobian in cSolver", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeJacobianODE2RHS_t", &MainSolverStatic::ComputeJacobianODE2RHS_t, "add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeJacobianAE", &MainSolverStatic::ComputeJacobianAE, "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. ODE2 coordinates and w.r.t. ODE2_t (velocity) coordinates; if velocityLevel == true, the constraints are evaluated at velocity level", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 1., py::arg("velocityLevel") = false)
        .def("ComputeODE2RHS", &MainSolverStatic::ComputeODE2RHS, "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)", py::arg("mainSystem"))
        .def("ComputeAlgebraicEquations", &MainSolverStatic::ComputeAlgebraicEquations, "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)", py::arg("mainSystem"), py::arg("velocityLevel") = false)
        .def("__repr__", [](const MainSolverStatic &item) { return "<MainSolverStatic:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
    //++++++++++++++++++++++++++++++++
    py::class_<MainSolverImplicitSecondOrder>(m, "MainSolverImplicitSecondOrder") // AUTO: 
        .def(py::init<>())
        .def_property("timer", &MainSolverImplicitSecondOrder::PyGetTimer, &MainSolverImplicitSecondOrder::PySetTimer)
        .def_property("it", &MainSolverImplicitSecondOrder::PyGetIt, &MainSolverImplicitSecondOrder::PySetIt)
        .def_property("conv", &MainSolverImplicitSecondOrder::PyGetConv, &MainSolverImplicitSecondOrder::PySetConv)
        .def_property("output", &MainSolverImplicitSecondOrder::PyGetOutput, &MainSolverImplicitSecondOrder::PySetOutput)
        .def_property("newton", &MainSolverImplicitSecondOrder::PyGetNewton, &MainSolverImplicitSecondOrder::PySetNewton)
        .def_property("newmarkBeta", &MainSolverImplicitSecondOrder::PyGetNewmarkBeta, &MainSolverImplicitSecondOrder::PySetNewmarkBeta)
        .def_property("newmarkGamma", &MainSolverImplicitSecondOrder::PyGetNewmarkGamma, &MainSolverImplicitSecondOrder::PySetNewmarkGamma)
        .def_property("alphaM", &MainSolverImplicitSecondOrder::PyGetAlphaM, &MainSolverImplicitSecondOrder::PySetAlphaM)
        .def_property("alphaF", &MainSolverImplicitSecondOrder::PyGetAlphaF, &MainSolverImplicitSecondOrder::PySetAlphaF)
        .def_property("spectralRadius", &MainSolverImplicitSecondOrder::PyGetSpectralRadius, &MainSolverImplicitSecondOrder::PySetSpectralRadius)
        .def_property("factJacAlgorithmic", &MainSolverImplicitSecondOrder::PyGetFactJacAlgorithmic, &MainSolverImplicitSecondOrder::PySetFactJacAlgorithmic)
        // AUTO: access functions for MainSolverImplicitSecondOrder
        .def("CheckInitialized", &MainSolverImplicitSecondOrder::CheckInitialized, py::return_value_policy::copy, "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError", py::arg("mainSystem"))
        .def("ComputeLoadFactor", &MainSolverImplicitSecondOrder::ComputeLoadFactor, py::return_value_policy::copy, "for static solver, this is a factor in interval [0,1]; MUST be overwritten", py::arg("simulationSettings"))
        .def("GetAAlgorithmic", &MainSolverImplicitSecondOrder::GetAAlgorithmic, py::return_value_policy::copy, "get locally stored / last computed algorithmic accelerations")
        .def("GetStartOfStepStateAAlgorithmic", &MainSolverImplicitSecondOrder::GetStartOfStepStateAAlgorithmic, py::return_value_policy::copy, "get locally stored / last computed algorithmic accelerations at start of step")
        .def("SetUserFunctionUpdateCurrentTime", &MainSolverImplicitSecondOrder::SetUserFunctionUpdateCurrentTime, "set user function")
        .def("SetUserFunctionInitializeStep", &MainSolverImplicitSecondOrder::SetUserFunctionInitializeStep, "set user function")
        .def("SetUserFunctionFinishStep", &MainSolverImplicitSecondOrder::SetUserFunctionFinishStep, "set user function")
        .def("SetUserFunctionDiscontinuousIteration", &MainSolverImplicitSecondOrder::SetUserFunctionDiscontinuousIteration, "set user function")
        .def("SetUserFunctionNewton", &MainSolverImplicitSecondOrder::SetUserFunctionNewton, "set user function")
        .def("SetUserFunctionComputeNewtonUpdate", &MainSolverImplicitSecondOrder::SetUserFunctionComputeNewtonUpdate, "set user function")
        .def("SetUserFunctionComputeNewtonResidual", &MainSolverImplicitSecondOrder::SetUserFunctionComputeNewtonResidual, "set user function")
        .def("SetUserFunctionComputeNewtonJacobian", &MainSolverImplicitSecondOrder::SetUserFunctionComputeNewtonJacobian, "set user function")
        .def("GetSolverName", &MainSolverImplicitSecondOrder::GetSolverName, py::return_value_policy::copy, "get solver name - needed for output file header and visualization window")
        .def("IsStaticSolver", &MainSolverImplicitSecondOrder::IsStaticSolver, py::return_value_policy::copy, "return true, if static solver; needs to be overwritten in derived class")
        .def("GetSimulationEndTime", &MainSolverImplicitSecondOrder::GetSimulationEndTime, py::return_value_policy::copy, "compute simulation end time (depends on static or time integration solver)", py::arg("simulationSettings"))
        .def("ReduceStepSize", &MainSolverImplicitSecondOrder::ReduceStepSize, py::return_value_policy::copy, "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful", py::arg("mainSystem"), py::arg("simulationSettings"), py::arg("severity"))
        .def("IncreaseStepSize", &MainSolverImplicitSecondOrder::IncreaseStepSize, "increase step size if convergence is good", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolver", &MainSolverImplicitSecondOrder::InitializeSolver, py::return_value_policy::copy, "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PreInitializeSolverSpecific", &MainSolverImplicitSecondOrder::PreInitializeSolverSpecific, "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverOutput", &MainSolverImplicitSecondOrder::InitializeSolverOutput, "initialize output files; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverPreChecks", &MainSolverImplicitSecondOrder::InitializeSolverPreChecks, py::return_value_policy::copy, "check if system is solvable; initialize dense/sparse computation modes", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverData", &MainSolverImplicitSecondOrder::InitializeSolverData, "initialize all data,it,conv; called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeSolverInitialConditions", &MainSolverImplicitSecondOrder::InitializeSolverInitialConditions, "set/compute initial conditions (solver-specific!); called from InitializeSolver()", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("PostInitializeSolverSpecific", &MainSolverImplicitSecondOrder::PostInitializeSolverSpecific, "post-initialize for solver specific tasks; called at the end of InitializeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSystem", &MainSolverImplicitSecondOrder::SolveSystem, py::return_value_policy::copy, "solve System: InitializeSolver, SolveSteps, FinalizeSolver", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinalizeSolver", &MainSolverImplicitSecondOrder::FinalizeSolver, "write concluding information (timer statistics, messages) and close files", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("SolveSteps", &MainSolverImplicitSecondOrder::SolveSteps, py::return_value_policy::copy, "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("UpdateCurrentTime", &MainSolverImplicitSecondOrder::UpdateCurrentTime, "update currentTime (and load factor); MUST be overwritten in special solver class", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("InitializeStep", &MainSolverImplicitSecondOrder::InitializeStep, "initialize static step / time step; python-functions; do some outputs, checks, etc.", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("FinishStep", &MainSolverImplicitSecondOrder::FinishStep, "finish static step / time step; write output of results to file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("DiscontinuousIteration", &MainSolverImplicitSecondOrder::DiscontinuousIteration, py::return_value_policy::copy, "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("Newton", &MainSolverImplicitSecondOrder::Newton, py::return_value_policy::copy, "perform Newton method for given solver method", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonResidual", &MainSolverImplicitSecondOrder::ComputeNewtonResidual, "compute residual for Newton method (e.g. static or time step); store result in systemResidual", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonUpdate", &MainSolverImplicitSecondOrder::ComputeNewtonUpdate, "compute update for currentState from newtonSolution (decrement from residual and jacobian)", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("ComputeNewtonJacobian", &MainSolverImplicitSecondOrder::ComputeNewtonJacobian, "compute jacobian for newton method of given solver method; store result in systemJacobian", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteSolutionFileHeader", &MainSolverImplicitSecondOrder::WriteSolutionFileHeader, "write unique file header, depending on static/ dynamic simulation", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("WriteCoordinatesToFile", &MainSolverImplicitSecondOrder::WriteCoordinatesToFile, "write unique coordinates solution file", py::arg("mainSystem"), py::arg("simulationSettings"))
        .def("IsVerboseCheck", &MainSolverImplicitSecondOrder::IsVerboseCheck, py::return_value_policy::copy, "return true, if file or console output is at or above the given level", py::arg("level"))
        .def("VerboseWrite", &MainSolverImplicitSecondOrder::VerboseWrite, "write to console and/or file in case of level", py::arg("level"), py::arg("str"))
        .def("GetODE2size", &MainSolverImplicitSecondOrder::GetODE2size, py::return_value_policy::reference, "number of ODE2 equations in solver")
        .def("GetODE1size", &MainSolverImplicitSecondOrder::GetODE1size, py::return_value_policy::reference, "number of ODE1 equations in solver (not yet implemented)")
        .def("GetAEsize", &MainSolverImplicitSecondOrder::GetAEsize, py::return_value_policy::reference, "number of algebraic equations in solver")
        .def("GetDataSize", &MainSolverImplicitSecondOrder::GetDataSize, py::return_value_policy::reference, "number of data (history) variables in solver")
        .def("GetSystemJacobian", &MainSolverImplicitSecondOrder::GetSystemJacobian, py::return_value_policy::copy, "get locally stored / last computed system jacobian of solver")
        .def("GetSystemMassMatrix", &MainSolverImplicitSecondOrder::GetSystemMassMatrix, py::return_value_policy::copy, "get locally stored / last computed mass matrix of solver")
        .def("GetSystemResidual", &MainSolverImplicitSecondOrder::GetSystemResidual, py::return_value_policy::copy, "get locally stored / last computed system residual")
        .def("GetNewtonSolution", &MainSolverImplicitSecondOrder::GetNewtonSolution, py::return_value_policy::copy, "get locally stored / last computed solution (=increment) of Newton")
        .def("SetSystemJacobian", &MainSolverImplicitSecondOrder::SetSystemJacobian, "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE", py::arg("systemJacobian"))
        .def("SetSystemMassMatrix", &MainSolverImplicitSecondOrder::SetSystemMassMatrix, "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE", py::arg("systemMassMatrix"))
        .def("SetSystemResidual", &MainSolverImplicitSecondOrder::SetSystemResidual, "set locally stored system residual; must have size nODE2+nODE1+nAE", py::arg("systemResidual"))
        .def("ComputeMassMatrix", &MainSolverImplicitSecondOrder::ComputeMassMatrix, "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeJacobianODE2RHS", &MainSolverImplicitSecondOrder::ComputeJacobianODE2RHS, "set systemJacobian to zero and add jacobian (multiplied with factor) of ODE2RHS to systemJacobian in cSolver", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeJacobianODE2RHS_t", &MainSolverImplicitSecondOrder::ComputeJacobianODE2RHS_t, "add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver", py::arg("mainSystem"), py::arg("scalarFactor") = 1.)
        .def("ComputeJacobianAE", &MainSolverImplicitSecondOrder::ComputeJacobianAE, "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. ODE2 coordinates and w.r.t. ODE2_t (velocity) coordinates; if velocityLevel == true, the constraints are evaluated at velocity level", py::arg("mainSystem"), py::arg("scalarFactor_ODE2") = 1., py::arg("scalarFactor_ODE2_t") = 1., py::arg("velocityLevel") = false)
        .def("ComputeODE2RHS", &MainSolverImplicitSecondOrder::ComputeODE2RHS, "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)", py::arg("mainSystem"))
        .def("ComputeAlgebraicEquations", &MainSolverImplicitSecondOrder::ComputeAlgebraicEquations, "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)", py::arg("mainSystem"), py::arg("velocityLevel") = false)
        .def("__repr__", [](const MainSolverImplicitSecondOrder &item) { return "<MainSolverImplicitSecondOrder:\n" + EXUstd::ToString(item) + " >"; } ) //!< AUTO: add representation for object based on ostream operator
        ; // AUTO: end of class definition!!!

    //++++++++++++++++++++++++++++++++
