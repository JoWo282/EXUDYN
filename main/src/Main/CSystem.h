/** ***********************************************************************************************
* @class        CSystem
* @brief		
* @details		Details:
 				- a computational system, containing data and functions to be solved with a solver
*
* @author		Gerstmayr Johannes
* @date			2018-05-17 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: missing
* 				
*
* *** Example code ***
*
************************************************************************************************ */
#pragma once

#include <atomic>
#include "Main/CSystemData.h"
#include "Autogenerated/SimulationSettings.h" 
#include "Linalg/LinearSolver.h" //for GeneralMatrixEXUdense

class MainSystem;
class System;

//! @brief class for temporary data during computation (time integration, static solver, etc.)
//! use multiple instances for parallelization
//! only contains resizable data structures for reuse in different objects
class TemporaryComputationData
{
public:
	ResizableMatrix localMass;          //!< body mass matrix
	ResizableVector localODE2RHS;       //!< body ODE2RHS vector
	ResizableVector localAE;			//!< object (local) algebraic equations evaluation

	ResizableMatrix localJacobian;      //!< local (object)-jacobian during numerical/automatic differentiation
	ResizableMatrix localJacobian_t;    //!< local velocity (object)-jacobian during numerical/automatic differentiation

	ResizableVector generalizedLoad;    //!< generalized load vector added to ODE2 right-hand-side
	ResizableMatrix loadJacobian;       //!< Jacobian for application of load
	ResizableMatrix localJacobianAE;    //!< local constraint Jacobian during constraint jacobian computation
	ResizableMatrix localJacobianAE_t;  //!< local constraint Jacobian (w.r.t. ODE_t part) during constraint jacobian computation
	ResizableMatrix localJacobianAE_AE; //!< local constraint Jacobian w.r.t. algebraic variables; during constraint jacobian computation
	ResizableMatrix localJacobianODE2;  //!< local (object) Jacobian during jacobian computation

	ResizableVector numericalJacobianf0;	//!< temporary vector for numerical differentiation
	ResizableVector numericalJacobianf1;	//!< temporary vector for numerical differentiation

	ArrayIndex ltg;						//!< local to global coordinate mapping; ArrayIndex is also resizable

	MarkerDataStructure markerDataStructure;
};

//! @brief class that contains relevant data for postprocessing:
//! - postProcessState
//! - flag to show that results have been updated
class PostProcessData
{
private:
	std::string visualizationMessage;	//!< any additional text message shown in renderer window; this variable is private, because it cannot be accessed safely in multithreading

public:
	std::atomic_flag accessState;		//!< flag, which is locked / released to access data
	bool postProcessDataReady;			//!< signals, that data can be plotted (CSystem must be consistent, state is a current state of the CSystem, ...); usually same as CSystem::systemIsConsistent
	uint64_t updateCounter;				//!< updateCounter is increased upon every update of state; can be used to judge graphics update; for 1 billion steps/second counter goes for 585 years before overflow
	uint64_t recordImageCounter;				//!< updateCounter is increased upon every update of state; can be used to judge graphics update; for 1 billion steps/second counter goes for 585 years before overflow
	bool simulationFinished;			//!< shows that computation has been finished ==> visualize last step
	bool stopSimulation;				//!< renderer or GUI sends signal that simulation shall be interrupted
	bool simulationPaused;				//!< true: simulation sends renderer or GUI that simulation is paused, waiting for user-input (SPACE)
	Real visualizationTime;				//!< this value is set as soon as the computation date is generated from visualization; needed to synchronize text message and visualization state
	bool visualizationIsRunning;		//!< flag, which is set true, if visualization is running (used, e.g. for WaitForUserToContinue())

	PostProcessData()
	{
		visualizationTime = 0;
		simulationFinished = false;
		stopSimulation = false;
		updateCounter = 1;				// must be larger than recordImageCounter, in order to avoid hang up in first UpdatePostProcessData(...) in CSystem
		recordImageCounter = 0;
		postProcessDataReady = false;
		visualizationIsRunning = false; 
	}

	//! this function is used to only send a signal that the scene shall be redrawn because the visualization state has been updated
	void SendRedrawSignal();

	//! send flag to GUI / renderer which signals that simulation is interrupted until user interaction
	void WaitForUserToContinue();

	//! set a visualization message into openGL window
	void SetVisualizationMessage(std::string message)
	{
		accessState.test_and_set(std::memory_order_acquire); //lock PostProcessData
		visualizationMessage = message;
		accessState.clear(std::memory_order_release); //clear PostProcessData
	}

	//! get the current visualization message string
	std::string GetVisualizationMessage()
	{
		accessState.test_and_set(std::memory_order_acquire); //lock PostProcessData
		std::string message = visualizationMessage; //copy message
		accessState.clear(std::memory_order_release); //clear PostProcessData
		//now safely return message:
		return message;
	}
};

//! @brief data which is updated during different computation tasks, e.g. load factor, load steps, time steps, solver accuracy, ...
class SolverData
{
public:
	Real loadFactor;			//!< load factor, mainly used for static computation; should be set to 1, otherwise all loads are reduced by this factor
	bool signalJacobianUpdate;  //!< false: default, do nothing; true: jacobian (of static computation or time integration) shall be updated, e.g. due to system change - if constraints are turned off, ...; this flag is regularly reset within a jacobian computation

	SolverData()
	{
		Reset();
	}

	//! reset all data for a new (static/dynamic) computation
	void Reset()
	{
		loadFactor = 1;
		signalJacobianUpdate = false;
	}
};

//call to pointer to member function (std::invoke) did not work
////memberfunction pointers follow idea of https://isocpp.org/wiki/faq/pointers-to-members
//typedef  void (CSystem::*CSystemDifferentiableFunction)(TemporaryComputationData& temp, Vector& ode2Rhs);

class CSystem
{
protected:
    CSystemData cSystemData;			//!< contains all system-relevant data; Nodes, Objects, etc. 
	PostProcessData postProcessData;	//!< data needed for post-processing
	SolverData solverData;				//!< data updated by specific solvers 


	bool systemIsConsistent;				//!< variable is set after check of system consistency ==> in order to draw or compute system; usually set after Assemble()

public:

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // ACCESS FUNCTIONS for member variables
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    CSystemData& GetSystemData() { return cSystemData; }
    const CSystemData& GetSystemData() const { return cSystemData; }

	//! return pointer to data in order to be linked to visualization class
	PostProcessData* GetPostProcessData() { return &postProcessData; }

	//! return pointer to data in order to be linked to visualization class
	const PostProcessData* GetPostProcessData() const { return &postProcessData; }

	//! this function is used to copy the current state to the visualization state and to send a signal that the PostProcessData has been updated
	void UpdatePostProcessData(bool recordImage = false);

	SolverData& GetSolverData() { return solverData; }
	const SolverData& GetSolverData() const { return solverData; }
	// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	// CSystem management functions
	// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	//! return true, if system is assembled, initialized and ready to be computed; special draw functions can be applied (visualization state exists)
	bool IsSystemConsistent() const { return systemIsConsistent; }

	//! Set true, if system is assembled, initialized and ready to be computed; special draw functions can be applied (visualization state exists)
	void SetSystemIsConsistent(bool flag) 
	{ 
		systemIsConsistent = flag; 
		cSystemData.GetCData().SetSystemIsConsistent(flag);
		if (flag = false) { postProcessData.postProcessDataReady = flag; }	//do not draw system anymore
	}

	//merged with SetSystemIsConsistent //! Function called e.g. by AddNode/Object/..., ModifyNode/Object/... to signal that the system has changed and consistency is not guaranteed
	void SystemHasChanged() 
	{
		SetSystemIsConsistent(false);						//do not compute or access nodal dof lists, etc.
	}
	
	// reset system; everything done in MainSystem
	void Initialize() 
	{
		SetSystemIsConsistent(false);
		postProcessData.postProcessDataReady = false;
		postProcessData.simulationFinished = false;

		postProcessData.updateCounter = 1; //done synchronized with visualizationSystem.graphicsData.visualizationCounter
	}


    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // CSystem computational functions
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//void Test() { pout << "CSystem test function called\n"; }

	//! Check if all references are valid (body->node number, marker->body/nodenumber, load->marker, etc.) for assemble;
	//  Function is called before main assemble functions
	bool CheckSystemIntegrity(const MainSystem& mainSystem);

	//! Prepare a newly created System of nodes, objects, loads, ... for computation
	void Assemble(const MainSystem& mainSystem);

	//! assign coordinate numbers to nodes (?and prepare LinkedDataVectors (of coordinates) for nodes)
	void AssembleCoordinates(const MainSystem& mainSystem);

	//! build ltg-coordinate lists for object with 'objectIndex' and set indices in ltg lists
	void AssembleObjectLTGLists(Index objectIndex, ArrayIndex& ltgListODE2, ArrayIndex& ltgListODE1, 
		ArrayIndex& ltgListAE, ArrayIndex& ltgListData);

	//! build ltg-coordinate lists for objects (used to build global ODE2RHS, MassMatrix, etc. vectors and matrices)
	void AssembleLTGLists(const MainSystem& mainSystem);

	////! NEEDED? prepare LinkedDataVectors for objects
	//void AssembleObjects();

	//! Use initial values of nodes to compute system-wide initial coordinate vectors
	void AssembleInitializeSystemCoordinates(const MainSystem& mainSystem);

	// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // CSystem computation functions
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //! compute system massmatrix and ADD to given massMatrix; matrix needs to have according size; set entries to zero beforehand, if only the mass matrix is required
	virtual void ComputeMassMatrix(TemporaryComputationData& temp, GeneralMatrix& massMatrix);
	//virtual void ComputeMassMatrixOLD(TemporaryComputationData& temp, Matrix& massMatrix);

	//! compute right-hand-side (RHS) of second order ordinary differential equations (ODE) for every object (used in numerical differentiation and in RHS computation); return true, if object has localODE2Rhs, false otherwise
	virtual bool ComputeObjectODE2RHS(TemporaryComputationData& temp, CObject* object, Vector& localODE2Rhs);
		
	//! compute right-hand-side (RHS) of second order ordinary differential equations (ODE) to 'ode2rhs' for ODE2 part
	virtual void ComputeODE2RHS(TemporaryComputationData& temp, Vector& ode2Rhs);

	//! compute right-hand-side (RHS) due to loads and add them to 'ode2rhs' for ODE2 part
	virtual void ComputeLoads(TemporaryComputationData& temp, Vector& ode2Rhs);

	//! add the projected action of Lagrange multipliers (reaction forces) to the ODE2 coordinates and add it to the ode2ReactionForces residual:
	//! ode2ReactionForces += C_{q2}^T * \lambda
	virtual void ComputeODE2ProjectedReactionForces(TemporaryComputationData& temp, const Vector& reactionForces, Vector& ode2ReactionForces);

	//! compute numerically the derivative of (C_{q2} * v), v being an arbitrary vector
	//! jacobianCqV = scalarFactor*d/dq2(C_{q2} * v)
	virtual void ComputeConstraintJacobianDerivative(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff, Vector& f0, Vector& f1, 
		const Vector& v, GeneralMatrix& jacobianCqV, Real scalarFactor = 1., Index rowOffset = 0, Index columnOffset = 0);

	//! compute (C_{q2} * v), v being an arbitrary vector
	virtual void ComputeConstraintJacobianTimesVector(TemporaryComputationData& temp, const Vector& v, Vector& result);

	//! PostNewtonStep: do this for every object (connector), which has a PostNewtonStep ->discontinuous iteration e.g. to resolve contact, friction or plasticity; returns an error (residual)
	virtual Real PostNewtonStep(TemporaryComputationData& temp);

	//! function called after discontinuous iterations have been completed for one step (e.g. to finalize history variables and set initial values for next step)
	virtual void PostDiscontinuousIterationStep();

	//! compute right-hand-side (RHS) of algebraic equations (AE) to vector 'AERhs'
	virtual void ComputeAlgebraicEquations(TemporaryComputationData& temp, Vector& algebraicEquations, bool velocityLevel = false);

	//! compute MarkerDataStructure for a given connector (using its markers); used in ComputeODE2RHS, GetOutputVariableConnector, etc.
	virtual void ComputeMarkerDataStructure(const CObjectConnector* connector, bool computeJacobian, MarkerDataStructure& markerDataStructure) const
	{ cSystemData.ComputeMarkerDataStructure(connector, computeJacobian, markerDataStructure); }

	// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    // Jacobians
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	//! compute numerical differentiation of ODE2RHS; result is a jacobian;  multiply the added entries with scalarFactor
	//! the jacobian is ADDed to the given matrix, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
	void NumericalJacobianODE2RHS(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff,
		Vector& f0, Vector& f1, GeneralMatrix& jacobianGM, Real scalarFactor = 1.); // ResizableMatrix& jacobian);
	//template<class TGeneralMatrix>
	//void NumericalJacobianODE2RHS(TemporaryComputationData& temp, const NumericalDifferentiation& numDiff,
	//	Vector& f0, Vector& f1, TGeneralMatrix& jacobianGM); // ResizableMatrix& jacobian);

	//! compute numerical differentiation of ODE2RHS with respect to velocity coordinates; result is a jacobian; multiply the added entries with scalarFactor
	//! the jacobian is ADDed to the given matrix, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
	void NumericalJacobianODE2RHS_t(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff,
		Vector& f0, Vector& f1, GeneralMatrix& jacobianGM, Real scalarFactor = 1.);

	//! numerical computation of constraint jacobian with respect to ODE2 and ODE1 (fillIntoSystemMatrix=true: also w.r.t. AE) coordinates
	//! the jacobian is ADDed to the given matrix, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
	//! factorODE2 is used to scale the ODE2-part of the jacobian (to avoid postmultiplication); 
	//! velocityLevel = velocityLevel constraints are used, if available; 
	//! fillIntoSystemMatrix=true: fill in g_q_ODE2, g_q_ODE2^T AND g_q_AE into system matrix at according positions
	//! fillIntoSystemMatrix=false: fill in g_q_ODE2 into jacobian matrix at (0,0)
	template<class TGeneralMatrix>
	void NumericalJacobianAE(TemporaryComputationData& temp, const NumericalDifferentiationSettings& numDiff,
		Vector& f0, Vector& f1, TGeneralMatrix& jacobianGM, Real factorAE_ODE2, Real factorAE_ODE2_t, bool velocityLevel = false, bool fillIntoSystemMatrix = false); //ResizableMatrix& jacobian

	////! compute numerical differentiation of AE with respect to ODE2 velocity coordinates; if fillIntoSystemMatrix==true, the jacobian is filled directly into the system matrix; result is a jacobian; THIS FUNCTION IS ONLY FOR COMPARISON (SLOW!!!)
	//void NumericalJacobianAE_ODE2_t(const NumericalDifferentiation& numDiff,
	//	TemporaryComputationData& temp, Vector& f0, Vector& f1, ResizableMatrix& jacobian, Real factor, bool velocityLevel = false);


	//! compute numerical differentiation of ODE2RHS w.r.t. ODE2 and ODE2_t coordinates; results are 2 jacobians
	//! the jacobian is ADDed to the given matrix, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
	//! The factors 'factor_ODE2' and 'factor_ODE2_t' are used to scale the two jacobians; if a factor is set to zero, the jacobian is not computed!
	void JacobianODE2RHS(TemporaryComputationData& temp, const NumericalDifferentiationSettings& newton, Real factorODE2, Real factorODE2_t,
		ResizableMatrix& jacobian_ODE2, ResizableMatrix& jacobian_ODE2_t, Real scalarFactor = 1.) {}; //used in future!

	//!compute per-object jacobians for object j, providing TemporaryComputationData;
	//! the jacobian is ADDed to the given matrix, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
	//! returns ltgAE and ltgODE2 lists, and several flags on object velocity level equation and which jacobian parts have been computed
	//! returns true, if jacobian is available, or false if not (e.g. body or ground object)
	virtual void ComputeObjectJacobianAE(Index j, TemporaryComputationData& temp,
		bool& objectUsesVelocityLevel, bool& flagAE_ODE2filled, bool& flagAE_ODE2_tFilled, bool& flagAE_AEfilled);

	//! compute constraint jacobian of AE with respect to ODE2 (fillIntoSystemMatrix=true: also w.r.t. ODE1 and AE) coordinates
	//! the jacobian is ADDed to the given matrix, which needs to have according size; set entries to zero beforehand in order to obtain only the jacobian
	//! newton.useNumericalDifferentiation: if true, numerical differentiation is used throughout; otherwise: analytical/function jacobian when available
	//! factorAE_ODE2 is used to scale the ODE2-part of the jacobian, depending on index2 or index3 formulation (to avoid later multiplication at system level); 
	//! factorAE_ODE2_t is used to scale the ODE2_t-part of the jacobian for velocity level constraints (to avoid later multiplication at system level); 
	//! velocityLevel = velocityLevel constraints are used, if available; 
	//! fillIntoSystemMatrix=true: fill in g_q_ODE2, g_q_ODE2^T AND g_q_AE into system matrix at according positions
	//! fillIntoSystemMatrix=false: fill in g_q_ODE2 into jacobian matrix at (0,0)
	void JacobianAE(TemporaryComputationData& temp, const NewtonSettings& newton, GeneralMatrix& jacobianGM,
		Real factorAE_ODE2, Real factorAE_ODE2_t, bool velocityLevel = false, bool fillIntoSystemMatrix = false);
	//template<class TGeneralMatrix>
	//void JacobianAE(TemporaryComputationData& temp, const Newton& newton, TGeneralMatrix& jacobianGM,
	//	Real factorAE_ODE2, Real factorAE_ODE2_t, bool velocityLevel = false, bool fillIntoSystemMatrix = false);


	// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	// Various functions
	// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


};



